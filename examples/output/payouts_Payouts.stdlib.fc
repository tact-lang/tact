#pragma version =0.4.2;
#pragma allow-post-modification;
#pragma compute-asm-ltr;

global (int, slice, int, slice) __tact_context;
global slice __tact_context_sender;
global cell __tact_context_sys;
global int __tact_randomized;

slice __tact_verify_address(slice address) inline {
    throw_unless(136, address.slice_bits() == 267);
    var h = address.preload_uint(11);
    throw_unless(136, (h == 1024) | (h == 1279));
    throw_unless(137, h == 1024);
    return address;
}

(slice, slice) __tact_load_address(slice cs) inline {
    slice raw = cs~load_msg_addr();
    return (cs, __tact_verify_address(raw));
}

builder __tact_store_address(builder b, slice address) inline {
    return b.store_slice(__tact_verify_address(address));
}

slice __tact_create_address(int chain, int hash) inline {
    var b = begin_cell();
    b = b.store_uint(2, 2);
    b = b.store_uint(0, 1);
    b = b.store_int(chain, 8);
    b = b.store_uint(hash, 256);
    var addr = b.end_cell().begin_parse();
    return __tact_verify_address(addr);
}

slice __tact_compute_contract_address(int chain, cell code, cell data) inline {
    var b = begin_cell();
    b = b.store_uint(0, 2);
    b = b.store_uint(3, 2);
    b = b.store_uint(0, 1);
    b = b.store_ref(code);
    b = b.store_ref(data);
    var hash = cell_hash(b.end_cell());
    return __tact_create_address(chain, hash);
}

int __tact_my_balance() inline {
    return pair_first(get_balance());
}

forall X -> X __tact_not_null(X x) inline {
    throw_if(128, null?(x)); return x;
}

(int, slice, int, slice) __tact_context_get() inline {
    return __tact_context;
}

slice __tact_context_get_sender() inline {
    return __tact_context_sender;
}

builder __tact_store_bool(builder b, int v) inline {
    return b.store_int(v, 1);
}

int __tact_slice_eq_bits(slice a, slice b) inline {
    return equal_slice_bits(a, b);
}

cell __tact_dict_set_code(cell dict, int id, cell code) inline {
    return udict_set_ref(dict, 16, id, code);
}

cell __tact_dict_get_code(cell dict, int id) inline {
    var (data, ok) = udict_get_ref?(dict, 16, id);
    throw_unless(135, ok);
    return data;
}

slice $global_contractAddress((cell, cell) $s) impure inline_ref {
    var (($s'code, $s'data)) = $s;
    return __tact_compute_contract_address(0, $s'code, $s'data);
}

() $global_send((int, slice, int, int, cell, cell, cell) $params) impure inline_ref {
    var (($params'bounce, $params'to, $params'value, $params'mode, $params'body, $params'code, $params'data)) = $params;
    builder $b = begin_cell();
    $b = store_int($b, 1, 2);
    $b = __tact_store_bool($b, $params'bounce);
    $b = store_int($b, 0, 3);
    $b = __tact_store_address($b, $params'to);
    $b = store_coins($b, $params'value);
    $b = store_int($b, 0, ((((1 + 4) + 4) + 64) + 32));
    if (( ((~ null?($params'code))) ? (true) : ((~ null?($params'data))) )) {
        $b = __tact_store_bool($b, true);
        builder $bc = begin_cell();
        $bc = __tact_store_bool($bc, false);
        $bc = __tact_store_bool($bc, false);
        if ((~ null?($params'code))) {
            $bc = __tact_store_bool($bc, true);
            $bc = store_ref($bc, __tact_not_null($params'code));
        } else {
            $bc = __tact_store_bool($bc, false);
        }
        if ((~ null?($params'data))) {
            $bc = __tact_store_bool($bc, true);
            $bc = store_ref($bc, __tact_not_null($params'data));
        } else {
            $bc = __tact_store_bool($bc, false);
        }
        $bc = __tact_store_bool($bc, false);
        $b = __tact_store_bool($b, true);
        $b = store_ref($b, end_cell($bc));
    } else {
        $b = __tact_store_bool($b, false);
    }
    cell $body = $params'body;
    if ((~ null?($body))) {
        $b = __tact_store_bool($b, true);
        $b = store_ref($b, __tact_not_null($body));
    } else {
        $b = __tact_store_bool($b, false);
    }
    cell $c = end_cell($b);
    send_raw_message($c, $params'mode);
}

slice $Builder$_fun_asSlice(builder $self) impure inline_ref {
    var ($self) = $self;
    return begin_parse(end_cell($self));
}

cell $Builder$_fun_asCell(builder $self) impure inline_ref {
    var ($self) = $self;
    return end_cell($self);
}

slice $Slice$_fun_fromBase64(slice $self) impure inline_ref {
    var ($self) = $self;
    int $size = (slice_bits($self) / 8);
    builder $result = begin_cell();
    repeat ($size) {
        int $code = $self~load_uint(8);
        if (( (($code >= 65)) ? (($code <= 90)) : (false) )) {
            $result = store_uint($result, ($code - 65), 6);
        } elseif (( (($code >= 97)) ? (($code <= 122)) : (false) )) {
            $result = store_uint($result, ($code - (97 - 26)), 6);
        } elseif (( (($code >= 48)) ? (($code <= 57)) : (false) )) {
            $result = store_uint($result, ($code + (52 - 48)), 6);
        } elseif (( (($code == 45)) ? (true) : (($code == 43)) )) {
            $result = store_uint($result, 62, 6);
        } elseif (( (($code == 95)) ? (true) : (($code == 47)) )) {
            $result = store_uint($result, 63, 6);
        } elseif (($code == 61)) {
        } else {
            throw(134);
        }
    }
    int $total = builder_bits($result);
    int $padding = ($total % 8);
    if (($padding != 0)) {
        slice $s = $Builder$_fun_asSlice($result);
        return $s~load_bits(($total - $padding));
    } else {
        return $Builder$_fun_asSlice($result);
    }
}

slice $String$_fun_fromBase64(slice $self) impure inline_ref {
    var ($self) = $self;
    return $Slice$_fun_fromBase64(__tact_str_to_slice($self));
}