import { readFileSync } from "fs";
import { resolve } from "path";
import Mustache from "mustache";
import type { ABIArgument, ContractABI, ABIReceiver } from "@ton/core";
import type { WrappersConstantDescription } from "@/bindings/writeTypescript";
import type { CompilerContext } from "@/context/context";
import type { TypeDescription } from "@/types/types";

function getReceiverFunctionName(receiver: ABIReceiver): string {
    const receiverType = receiver.receiver; // 'internal' or 'external'
    const messageKind = receiver.message.kind; // 'empty', 'typed', 'text', 'any'

    let name = receiverType.charAt(0).toUpperCase() + receiverType.slice(1); // Internal or External

    switch (messageKind) {
        case "empty":
            name += "Empty";
            break;
        case "typed":
            name += "Message";
            name += receiver.message.type ?? "Typed";
            break;
        case "text":
            name += "Text";
            if (receiver.message.text) {
                const cleanText = receiver.message.text.replace(
                    /[^a-zA-Z0-9]/g,
                    "",
                );
                name += cleanText.charAt(0).toUpperCase() + cleanText.slice(1);
            }
            break;
        case "any":
            name += "Any";
            break;
        default:
            name += "Unknown";
    }

    return name;
}

export function writeTests(
    abi: ContractABI,
    _ctx: CompilerContext,
    _constants: readonly WrappersConstantDescription[],
    _contract: undefined | TypeDescription,
    generatedContractPath: string,
    _init?: {
        code: string;
        system: string | null;
        args: ABIArgument[];
        prefix?:
            | {
                  value: number;
                  bits: number;
              }
            | undefined;
    },
) {
    const contractName = abi.name ?? "Contract";

    const templateData = {
        contractName,
        imports: [
            `{ ${contractName} } from '../${generatedContractPath}'`,
            '{ Blockchain, createShardAccount } from "@ton/sandbox"',
        ],
        receivers: abi.receivers?.map(getReceiverFunctionName) ?? [],
        getters: abi.getters?.map((g) => g.name) ?? [],
        receiverBlocks: (abi.receivers ?? []).map((r) => {
            const fn = getReceiverFunctionName(r);
            return `const test${fn} = async () => {
    describe("${fn}", () => {
        const setup = async () => {
            return await globalSetup();
        };

        // !!THIS FILE IS GENERATED BY TACT. THIS FILE IS REGENERATED EVERY TIME, COPY IT TO YOUR PROJECT MANUALLY!!
        // TODO: You can write tests for ${fn} here

        it("should perform correctly", async () => {
            const { blockchain, contract, owner, notOwner } = await setup();
        });
    });
};
`;
        }),
        getterBlocks: (abi.getters ?? []).map((g) => {
            const fn = g.name;
            return `const getterTest${fn} = async () => {
    describe("${fn}", () => {
        const setup = async () => {
            return await globalSetup();
        };

        // !!THIS FILE IS GENERATED BY TACT. THIS FILE IS REGENERATED EVERY TIME, COPY IT TO YOUR PROJECT MANUALLY!!
        // TODO: You can write tests for ${fn} here

        it("should perform correctly", async () => {
            const { blockchain, contract, owner, notOwner } = await setup();
        });
    });
};
`;
        }),
    };

    const templatePath = resolve(__dirname, "templates", "test.mustache");
    const template = readFileSync(templatePath, "utf-8");
    const rendered = Mustache.render(template, templateData);

    return rendered;
}
