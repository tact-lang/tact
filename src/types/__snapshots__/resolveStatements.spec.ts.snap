// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`resolveStatements should fail statements for assign-augmented-const-contract 1`] = `
"<unknown>:8:9: Modifications of constant expressions are not allowed
Line 8, col 9:
  7 |     fun bar() {
> 8 |         self.foo += 1 // <-- trying to assign to a constant
              ^~~~~~~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for assign-augmented-const-global 1`] = `
"<unknown>:6:5: Modifications of constant expressions are not allowed
Line 6, col 5:
  5 | fun bar() {
> 6 |     foo += 1 // <-- trying to assign to a constant
          ^~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for assign-augmented-const-struct-contract 1`] = `
"<unknown>:12:9: Modifications of constant expressions are not allowed
Line 12, col 9:
  11 |         self.baz.x += 1; // ok
> 12 |         self.foo.y -= 1 // <-- trying to assign to a constant
               ^~~~~~~~~~
  13 |     }
"
`;

exports[`resolveStatements should fail statements for assign-augmented-const-struct-global 1`] = `
"<unknown>:10:5: Modifications of constant expressions are not allowed
Line 10, col 5:
   9 |     baz.x += 1; // ok
> 10 |     foo.y -= 1 // <-- trying to assign to a constant
           ^~~~~
  11 | }
"
`;

exports[`resolveStatements should fail statements for assign-const-contract 1`] = `
"<unknown>:8:9: Modifications of constant expressions are not allowed
Line 8, col 9:
  7 |     fun bar() {
> 8 |         self.foo = 43 // <-- trying to assign to a constant
              ^~~~~~~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for assign-const-global 1`] = `
"<unknown>:6:5: Modifications of constant expressions are not allowed
Line 6, col 5:
  5 | fun bar() {
> 6 |     foo = 43 // <-- trying to assign to a constant
          ^~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for assign-const-struct-contract 1`] = `
"<unknown>:12:9: Modifications of constant expressions are not allowed
Line 12, col 9:
  11 |         self.baz.x = 1; // ok
> 12 |         self.foo.y = 42 // <-- trying to assign to a constant
               ^~~~~~~~~~
  13 |     }
"
`;

exports[`resolveStatements should fail statements for assign-const-struct-global 1`] = `
"<unknown>:10:5: Modifications of constant expressions are not allowed
Line 10, col 5:
   9 |     baz.x = 1; // ok
> 10 |     foo.y = 42 // <-- trying to assign to a constant
           ^~~~~
  11 | }
"
`;

exports[`resolveStatements should fail statements for bounced-type-is-smaller 1`] = `
"<unknown>:23:22: Type bounced<"A"> does not have a field named "c"
Line 23, col 22:
  22 |     let y: Bool = src.b;
> 23 |     let z: Int = src.c;
                            ^
  24 |   }
"
`;

exports[`resolveStatements should fail statements for contract-initof-wrong-arg 1`] = `
"<unknown>:26:25: Invalid type "String" for argument "owner"
Line 26, col 25:
  25 |     get fun newInit(): StateInit {
> 26 |         return initOf A("hello");
                               ^~~~~~~
  27 |     }
"
`;

exports[`resolveStatements should fail statements for expr-bitwise-not-bool 1`] = `
"<unknown>:5:12: Invalid type "Bool" for unary operator "~"
Line 5, col 12:
  4 | fun test(a: Bool): Int {
> 5 |     return ~a;
                 ^~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-branch-mismatch 1`] = `
"<unknown>:5:43: Non-matching types "Bool" and "Int" for ternary branches
Line 5, col 43:
  4 | fun sample(): Int {
> 5 |     return (true ? true : false) ? true : 3;
                                                ^
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-branch-mismatch-nested1 1`] = `
"<unknown>:5:24: Non-matching types "Int" and "Bool" for ternary branches
Line 5, col 24:
  4 | fun sample(): Int {
> 5 |     return (true ? 1 : false) ? 2 : 3;
                             ^~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-branch-mismatch-nested2 1`] = `
"<unknown>:5:39: Non-matching types "Bool" and "Int" for ternary branches
Line 5, col 39:
  4 | fun sample(): Int {
> 5 |     return true ? 1 : (false ? true : 2);
                                            ^
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-non-optional-result-expected1 1`] = `
"<unknown>:6:5: Type mismatch: "Int?" is not assignable to "Int"
Line 6, col 5:
  5 |     let cond: Bool = true;
> 6 |     return cond ? 42 : x;
          ^~~~~~~~~~~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-non-optional-result-expected2 1`] = `
"<unknown>:6:5: Type mismatch: "Int?" is not assignable to "Int"
Line 6, col 5:
  5 |     let cond: Bool = true;
> 6 |     return cond ? x : 42;
          ^~~~~~~~~~~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-non-optional-result-expected3 1`] = `
"<unknown>:6:5: Type mismatch: "Int?" is not assignable to "Int"
Line 6, col 5:
  5 |     let cond: Bool = true;
> 6 |     let baz: Int = cond ? 42 : null;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  7 |     return baz!!;
"
`;

exports[`resolveStatements should fail statements for expr-conditional-result-mismatch 1`] = `
"<unknown>:5:5: Type mismatch: "Bool" is not assignable to "Int"
Line 5, col 5:
  4 | fun sample(): Int {
> 5 |     return (true ? true : false) ? true : false;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-conditional-void-branches copy 1`] = `
"<unknown>:6:19: Expressions of "<void>" type cannot be used for conditional expression
Line 6, col 19:
  5 | fun bar(): Int {
> 6 |     let voidVar = true ? foo() : foo();
                        ^~~~~~~~~~~~~~~~~~~~
  7 |     return 42;
"
`;

exports[`resolveStatements should fail statements for expr-eq-bounced 1`] = `
"<unknown>:6:10: Expressions of "bounced<S>" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 6, col 10:
  5 | fun foo(b: bounced<S>): Bool {
> 6 |   return b == b;
               ^~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-builder 1`] = `
"<unknown>:7:16: Expressions of "Builder" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 16:
  6 |     get fun foo(s: Builder): Bool {
> 7 |         return s == s;
                     ^~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-contract 1`] = `
"<unknown>:10:16: Expressions of "Test" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 10, col 16:
   9 |     get fun foo(): Bool {
> 10 |         return self == self;
                      ^~~~~~~~~~~~
  11 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-int-bool 1`] = `
"<unknown>:5:12: Incompatible types "Int" and "Bool" for binary operator "=="
Line 5, col 12:
  4 | fun foo(x: Int): Bool {
> 5 |     return x == true;
                 ^~~~~~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-map-map 1`] = `
"<unknown>:6:12: Incompatible types "map<Int, Address>" and "map<Address, Int>" for binary operator "=="
Line 6, col 12:
  5 | fun foo(m1: map<Int, Address>, m2: map<Address, Int>): Bool {
> 6 |     return m1 == m2;
                 ^~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-null-1 1`] = `
"<unknown>:18:13: Expressions of "S" type cannot be used for (non)equality operator "!="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 18, col 13:
  17 |     get fun test(): Int {
> 18 |         if (self.s != null) {
                   ^~~~~~~~~~~~~~
  19 |             return self.s.a;
"
`;

exports[`resolveStatements should fail statements for expr-eq-null-2 1`] = `
"<unknown>:18:13: Expressions of "S" type cannot be used for (non)equality operator "!="
See https://docs.tact-lang.org/book/operators#binary-equality
Line 18, col 13:
  17 |     get fun test(): Int {
> 18 |         if (null != self.s) {
                   ^~~~~~~~~~~~~~
  19 |             return self.s.a;
"
`;

exports[`resolveStatements should fail statements for expr-eq-null-3 1`] = `
"<unknown>:5:9: Incompatible types "<null>" and "Int" for binary operator "=="
Line 5, col 9:
  4 |     let x: Int = 42;
> 5 |     if (null == x) { return }
              ^~~~~~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-null-bounced 1`] = `
"<unknown>:7:10: Expressions of "bounced<S>" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 10:
  6 | fun foo(b: bounced<S>): Bool {
> 7 |   return b == null;
               ^~~~~~~~~
  8 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-optional-builder 1`] = `
"<unknown>:7:16: Expressions of "Builder?" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 16:
  6 |     get fun foo(s: Builder?): Bool {
> 7 |         return s == s;
                     ^~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-optional-stringbuilder 1`] = `
"<unknown>:7:16: Expressions of "StringBuilder?" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 16:
  6 |     get fun foo(s: StringBuilder?): Bool {
> 7 |         return s == s;
                     ^~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-optional-struct 1`] = `
"<unknown>:10:16: Expressions of "S?" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 10, col 16:
   9 |         let s: S? = S {x: 42, y: 0};
> 10 |         return s == s;
                      ^~~~~~
  11 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-optional-struct-null 1`] = `
"<unknown>:7:16: Expressions of "S" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 16:
  6 |     if (s != null) {
> 7 |         return s!! == null
                     ^~~~~~~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-stringbuilder 1`] = `
"<unknown>:7:16: Expressions of "StringBuilder" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 16:
  6 |     get fun foo(s: StringBuilder): Bool {
> 7 |         return s == s;
                     ^~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-struct 1`] = `
"<unknown>:10:16: Expressions of "S" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 10, col 16:
   9 |         let s: S = S {x: 42, y: 0};
> 10 |         return s == s;
                      ^~~~~~
  11 |     }
"
`;

exports[`resolveStatements should fail statements for expr-eq-void-null 1`] = `
"<unknown>:6:12: Expressions of "<void>" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 6, col 12:
  5 | fun baz(): Bool {
> 6 |     return foo() == null
                 ^~~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-void1 1`] = `
"<unknown>:7:12: Expressions of "<void>" type cannot be used for (non)equality operator "=="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 12:
  6 | fun baz(): Bool {
> 7 |     return foo() == bar()
                 ^~~~~~~~~~~~~~
  8 | }
"
`;

exports[`resolveStatements should fail statements for expr-eq-void2 1`] = `
"<unknown>:7:12: Expressions of "<void>" type cannot be used for (non)equality operator "!="
 See https://docs.tact-lang.org/book/operators#binary-equality
Line 7, col 12:
  6 | fun baz(): Bool {
> 7 |     return foo() != bar()
                 ^~~~~~~~~~~~~~
  8 | }
"
`;

exports[`resolveStatements should fail statements for expr-field-does-not-exist 1`] = `
"<unknown>:14:7: Type "Slice" does not have a field named "bits"
Line 14, col 7:
  13 |     let s: Slice = "123".asSlice();
> 14 |     s.bits;
             ^~~~
  15 | }
"
`;

exports[`resolveStatements should fail statements for expr-field-does-not-exist-but-method-does 1`] = `
"<unknown>:17:5: Type "Slice" does not have a field named "bits", did you mean "bits()" instead?
Line 17, col 5:
  16 |     let s: Slice = "123".asSlice();
> 17 |     s.bits;
           ^~~~~~
  18 | }
"
`;

exports[`resolveStatements should fail statements for expr-internal-fun-call-bool-param.tact 1`] = `
"<unknown>:20:27: Invalid type "Bool" for argument "b"
Line 20, col 27:
  19 |     fun f2(a: Int): Int {
> 20 |         return self.f1(a, true);
                                 ^~~~
  21 |     }
"
`;

exports[`resolveStatements should fail statements for expr-map-del-method-is-non-void 1`] = `
"<unknown>:6:5: Type mismatch: "Bool" is not assignable to "<void>"
Line 6, col 5:
  5 |     m.set(1, 2);
> 6 |     return m.del(1);
          ^~~~~~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for expr-map-exists-method-not-bool 1`] = `
"<unknown>:7:5: Type mismatch: "Bool" is not assignable to "Int"
Line 7, col 5:
  6 |     m.set(1, 2);
> 7 |     return m.exists(1);
          ^~~~~~~~~~~~~~~~~~~
  8 | }
"
`;

exports[`resolveStatements should fail statements for expr-map-exists-method-on-not-map 1`] = `
"<unknown>:5:12: Type "Int" does not have a function named "exists"
Line 5, col 12:
  4 | fun test(): Bool {
> 5 |     return 42.exists(1);
                 ^~~~~~~~~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for expr-method-does-not-exist-but-field-does 1`] = `
"<unknown>:13:5: Type "S" does not have a function named "x()", did you mean field "x" instead?
Line 13, col 5:
  12 |     let s: S = S{ x: 1 };
> 13 |     s.x();
           ^~~~~
  14 | }
"
`;

exports[`resolveStatements should fail statements for expr-module-fun-call-bool-param 1`] = `
"<unknown>:13:18: Invalid type "Bool" for argument "b"
Line 13, col 18:
  12 | fun f2(a: Int): Int {
> 13 |     return f1(a, true);
                        ^~~~
  14 | }
"
`;

exports[`resolveStatements should fail statements for expr-struct-duplicate-field 1`] = `
"<unknown>:17:9: Duplicate fields "a"
Line 17, col 9:
  16 |         a: 1,
> 17 |         a: 2,
               ^~~~
  18 |         b: 3
"
`;

exports[`resolveStatements should fail statements for expr-struct-impossible-field-punning 1`] = `
"<unknown>:14:26: Unknown fields "b" in type "A"
Line 14, col 26:
  13 | fun function() {
> 14 |     let D: A = A { x: a, b };
                                ^
  15 | }
"
`;

exports[`resolveStatements should fail statements for expr-struct-missing-field 1`] = `
"<unknown>:16:25: Missing field "c" in type "SomeStruct"
Line 16, col 25:
  15 | fun main() {
> 16 |     let a: SomeStruct = SomeStruct{
                               ^~~~~~~~~~~
  17 |         a: 1,
"
`;

exports[`resolveStatements should fail statements for expr-struct-wrong-field-type 1`] = `
"<unknown>:17:9: Invalid type "Bool" for field "b" with type "Int" in type "SomeStruct"
Line 17, col 9:
  16 |         a: 1,
> 17 |         b: false // Invalid type
               ^~~~~~~~
  18 |     };
"
`;

exports[`resolveStatements should fail statements for expr-var-int-bool 1`] = `
"<unknown>:9:5: Type mismatch: "Int" is not assignable to "Bool"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     return x;
           ^~~~~~~~~
  10 | }
"
`;

exports[`resolveStatements should fail statements for expr-wrong-arity-internal-fun 1`] = `
"<unknown>:20:16: Function "f1" expects 2 arguments, got 1
Line 20, col 16:
  19 |     fun f2(a: Int): Int {
> 20 |         return self.f1(a);
                      ^~~~~~~~~~
  21 |     }
"
`;

exports[`resolveStatements should fail statements for expr-wrong-arity-module-fun 1`] = `
"<unknown>:13:12: Function "f1" expects 2 arguments, got 1
Line 13, col 12:
  12 | fun f2(a: Int): Int {
> 13 |     return f1(a);
                  ^~~~~
  14 | }
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-if 1`] = `
"<unknown>:10:5: Field "value" is not set
Line 10, col 5:
   9 |     value: Int;
> 10 |     init(arg: Bool) {
           ^~~~~~~~~~~~~~~~~
  11 |         if (arg) {
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-implicit-init 1`] = `
"<unknown>:4:1: Field "test_field" is not set
Line 4, col 1:
  3 | 
> 4 | contract MyContract {
      ^~~~~~~~~~~~~~~~~~~~~
  5 |     counter: Int = 0;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-missing-storage-var 1`] = `
"<unknown>:10:5: Field "value" is not set
Line 10, col 5:
   9 |     value: Int;
> 10 |     init() {
           ^~~~~~~~
  11 | 
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-augmented-assign1 1`] = `
"<unknown>:8:27: Field "value" is not initialized
Line 8, col 27:
  7 |     init() {
> 8 |         self.value = self.value + 1;
                                ^~~~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-augmented-assign2 1`] = `
"<unknown>:7:5: Field "value" is not set
Line 7, col 5:
  6 |     value: Int;
> 7 |     init() {
          ^~~~~~~~
  8 |         self.value += 1;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-override-fun-call 1`] = `
"<unknown>:15:9: Cannot access self before init
Line 15, col 9:
  14 |     init(arg: Bool) {
> 15 |         self.execute();
               ^~~~~~~~~~~~~~
  16 |         self.value = 1;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-struct1 1`] = `
"<unknown>:17:27: Field "value2" is not initialized
Line 17, col 27:
  16 |     init(arg: Bool) {
> 17 |         self.value = self.value2.a + 1;
                                 ^~~~~~
  18 |         self.value2 = A{ a: 1, b: 2 };
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-struct2 1`] = `
"<unknown>:17:40: Field "value" is not initialized
Line 17, col 40:
  16 |     init(arg: Bool) {
> 17 |         self.value2 = A{ a: 1, b: self.value };
                                              ^~~~~
  18 |         self.value = self.value2.a + 1;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-var 1`] = `
"<unknown>:12:27: Field "value2" is not initialized
Line 12, col 27:
  11 |     init(arg: Bool) {
> 12 |         self.value = self.value2 + 1;
                                 ^~~~~~
  13 |         self.value2 = 10;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-used-uninit-storage-var-fun-call 1`] = `
"<unknown>:16:9: Cannot access self before init
Line 16, col 9:
  15 |     init(arg: Bool) {
> 16 |         self.update();
               ^~~~~~~~~~~~~
  17 |         self.value = 1;
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-with-if-else 1`] = `
"<unknown>:10:5: Field "value" is not set
Line 10, col 5:
   9 |     value: Int;
> 10 |     init(arg: Bool) {
           ^~~~~~~~~~~~~~~~~
  11 |         if (arg) {
"
`;

exports[`resolveStatements should fail statements for init-vars-analysis-with-if-elseif 1`] = `
"<unknown>:10:5: Field "value" is not set
Line 10, col 5:
   9 |     value: Int;
> 10 |     init(arg: Bool) {
           ^~~~~~~~~~~~~~~~~
  11 |         if (arg) {
"
`;

exports[`resolveStatements should fail statements for return-analysis-catch-if 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     try {
"
`;

exports[`resolveStatements should fail statements for return-analysis-do-if 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     do {
"
`;

exports[`resolveStatements should fail statements for return-analysis-if 1`] = `
"<unknown>:6:5: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 6, col 5:
  5 | contract Foo {
> 6 |     get fun notAlwaysReachableReturn(b: Bool): Int {
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  7 |         if b {
"
`;

exports[`resolveStatements should fail statements for return-analysis-non-void1 1`] = `
"<unknown>:6:5: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 6, col 5:
  5 | contract Foo {
> 6 |     get fun noReturn(): Int {
          ^~~~~~~~~~~~~~~~~~~~~~~~~
  7 |         // ERROR: no return statement
"
`;

exports[`resolveStatements should fail statements for return-analysis-non-void2 1`] = `
"<unknown>:6:5: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 6, col 5:
  5 | contract Foo {
> 6 |     get fun noReturn(): Int {
          ^~~~~~~~~~~~~~~~~~~~~~~~~
  7 |         let x: Int = 42;
"
`;

exports[`resolveStatements should fail statements for return-analysis-repeat 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(n: Int): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     repeat (n) {
"
`;

exports[`resolveStatements should fail statements for return-analysis-separate-ifs 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     if (b) {
"
`;

exports[`resolveStatements should fail statements for return-analysis-throw-wrapped 1`] = `
"<unknown>:15:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 15, col 1:
  14 | 
> 15 | fun notAlwaysReachableReturn(b: Bool): Int {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  16 |     throwWrapped(42);
"
`;

exports[`resolveStatements should fail statements for return-analysis-try1 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     try {
"
`;

exports[`resolveStatements should fail statements for return-analysis-try2 1`] = `
"<unknown>:7:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 7, col 1:
  6 | 
> 7 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  8 |     try {
"
`;

exports[`resolveStatements should fail statements for return-analysis-while 1`] = `
"<unknown>:4:1: Function does not always return a result. Adding 'return' statement(s) should fix the issue.
Line 4, col 1:
  3 | 
> 4 | fun notAlwaysReachableReturn(b: Bool): Int {
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  5 |     while (b) {
"
`;

exports[`resolveStatements should fail statements for stmt-assgn-int-string 1`] = `
"<unknown>:9:5: Type mismatch: "String" is not assignable to "Int"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     x = "hello world";
           ^~~~~~~~~~~~~~~~~~
  10 |     return true;
"
`;

exports[`resolveStatements should fail statements for stmt-augmented-assgn-bool 1`] = `
"<unknown>:5:5: Type error: Augmented assignment is only allowed for Int type
Line 5, col 5:
  4 |     let a: Bool = false;
> 5 |     a %= true;
          ^~~~~~~~~~
  6 |     return a;
"
`;

exports[`resolveStatements should fail statements for stmt-augmented-assgn-string 1`] = `
"<unknown>:5:5: Type error: Augmented assignment is only allowed for Int type
Line 5, col 5:
  4 |     let a: String = "foo";
> 5 |     a %= "bar";
          ^~~~~~~~~~~
  6 |     return a;
"
`;

exports[`resolveStatements should fail statements for stmt-conditional-expr-stmt-void1 1`] = `
"<unknown>:5:5: Expressions of "<void>" type cannot be used for conditional expression
Line 5, col 5:
  4 | fun baz() {
> 5 |     true ? foo() : bar();
          ^~~~~~~~~~~~~~~~~~~~
  6 | }
"
`;

exports[`resolveStatements should fail statements for stmt-do-int 1`] = `
"<unknown>:9:5: Type mismatch: "Int" is not assignable to "Bool"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     do {
           ^~~~
  10 |         x = x + 1;
"
`;

exports[`resolveStatements should fail statements for stmt-foreach-non-map 1`] = `
"<unknown>:8:22: foreach can only be used on maps, but "x" has type "Int"
Line 8, col 22:
  7 | fun foo(x: Int) {
> 8 |     foreach (k, v in x) {
                           ^
  9 |         throw(1042);
"
`;

exports[`resolveStatements should fail statements for stmt-foreach-non-path-map 1`] = `
"<unknown>:12:22: foreach is only allowed over maps that are path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"
Line 12, col 22:
  11 | fun foo(x: Int) {
> 12 |     foreach (k, v in mapFun()) {
                            ^~~~~~~~
  13 |         throw(1042);
"
`;

exports[`resolveStatements should fail statements for stmt-if-int 1`] = `
"<unknown>:9:5: Type mismatch: "Int" is not assignable to "Bool"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     if (x) {
           ^~~~~~~~
  10 |         x = x + 1;
"
`;

exports[`resolveStatements should fail statements for stmt-let-unknown-type-inference 1`] = `
"<unknown>:8:5: Cannot infer type for "a"
Line 8, col 5:
  7 | fun test() {
> 8 |     let a = null;
          ^~~~~~~~~~~~~
  9 | }
"
`;

exports[`resolveStatements should fail statements for stmt-let-unknown-type-inference2 1`] = `
"<unknown>:8:5: Cannot infer type for "a"
Line 8, col 5:
  7 | fun test() {
> 8 |     let a = emptyMap();
          ^~~~~~~~~~~~~~~~~~~
  9 | }
"
`;

exports[`resolveStatements should fail statements for stmt-let-void-inference 1`] = `
"<unknown>:12:9: The inferred type of variable "voidVar" is "void", which is not allowed
Line 12, col 9:
  11 |     get fun foo(): Int {
> 12 |         let voidVar = foo();
               ^~~~~~~~~~~~~~~~~~~~
  13 |         return 42;
"
`;

exports[`resolveStatements should fail statements for stmt-let-wrong-rhs 1`] = `
"<unknown>:10:5: Type mismatch: "Int" is not assignable to "Bool"
Line 10, col 5:
   9 |     let a: Int = 0;
> 10 |     let b: Bool = 0;
           ^~~~~~~~~~~~~~~~
  11 | }
"
`;

exports[`resolveStatements should fail statements for stmt-repeat-bool 1`] = `
"<unknown>:9:5: Type mismatch: "Bool" is not assignable to "Int"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     repeat(true) {
           ^~~~~~~~~~~~~~
  10 |         x = x + 1;
"
`;

exports[`resolveStatements should fail statements for stmt-return-from-try-and-catch 1`] = `
"<unknown>:8:9: Type mismatch: "Int" is not assignable to "String"
Line 8, col 9:
  7 |     } catch (e) {
> 8 |         return e;
              ^~~~~~~~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for stmt-return-void1 1`] = `
"<unknown>:4:5: 'return' statement can only be used with non-void types
Line 4, col 5:
  3 | fun bar() {
> 4 |     return foo()
          ^~~~~~~~~~~~
  5 | }
"
`;

exports[`resolveStatements should fail statements for stmt-return-void2 1`] = `
"<unknown>:6:5: Type mismatch: "Int" is not assignable to "<void>"
Line 6, col 5:
  5 | fun bar() {
> 6 |     return foo()
          ^~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for stmt-return-void3 1`] = `
"<unknown>:3:18: The function fails to return a result of type "Int"
Line 3, col 18:
  2 | 
> 3 | fun bar(): Int { return }
                       ^~~~~~
  4 | 
"
`;

exports[`resolveStatements should fail statements for stmt-unboxing-expr-stmt-void 1`] = `
"<unknown>:4:5: Type "<void>" is not optional
Line 4, col 5:
  3 | fun bar() {
> 4 |     foo()!!
          ^~~~~~~
  5 | }
"
`;

exports[`resolveStatements should fail statements for stmt-while-int 1`] = `
"<unknown>:9:5: Type mismatch: "Int" is not assignable to "Bool"
Line 9, col 5:
   8 | fun isZero(x: Int): Bool {
>  9 |     while(x) {
           ^~~~~~~~~~
  10 |         x = x + 1;
"
`;

exports[`resolveStatements should fail statements for var-does-not-exist 1`] = `
"<unknown>:5:9: Unable to resolve id 'nonExistentVariable'
Line 5, col 9:
  4 |     receive() {
> 5 |         nonExistentVariable = 42;
              ^~~~~~~~~~~~~~~~~~~
  6 |     }
"
`;

exports[`resolveStatements should fail statements for var-does-not-exist2 1`] = `
"<unknown>:13:9: Unable to resolve id 'someField', did you mean 'self.someField'?
Line 13, col 9:
  12 |     receive() {
> 13 |         someField = 42;
               ^~~~~~~~~
  14 |     }
"
`;

exports[`resolveStatements should fail statements for var-does-not-exist3 1`] = `
"<unknown>:17:9: Unable to resolve id 'someField', did you mean 'self.someField'?
Line 17, col 9:
  16 |     receive() {
> 17 |         someField = 42;
               ^~~~~~~~~
  18 |     }
"
`;

exports[`resolveStatements should fail statements for var-does-not-exist4 1`] = `
"<unknown>:9:9: Unable to resolve id 'someField', did you mean 'self.someField'?
Line 9, col 9:
   8 |     receive() {
>  9 |         someField = 42;
               ^~~~~~~~~
  10 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-catch-does-not-shadow-outer-const 1`] = `
"<unknown>:10:13: Variable "e" is trying to shadow an existing constant with the same name
Line 10, col 13:
   9 |     } catch (err) {
> 10 |         let e: String = "rty";
                   ^
  11 |         return e;
"
`;

exports[`resolveStatements should fail statements for var-scope-catch-does-not-shadow-outer-var 1`] = `
"<unknown>:9:13: Variable already exists: "e"
Line 9, col 13:
   8 |     } catch (err) {
>  9 |         let e: String = "rty";
                   ^
  10 |         return "err";
"
`;

exports[`resolveStatements should fail statements for var-scope-catch-param-does-not-shadow-outer-var 1`] = `
"<unknown>:8:14: Variable already exists: "e"
Line 8, col 14:
  7 |         return e;
> 8 |     } catch (e) {
                   ^
  9 |         return e;
"
`;

exports[`resolveStatements should fail statements for var-scope-catch-param-is-not-visible-in-try 1`] = `
"<unknown>:5:16: Unable to resolve id 'e'
Line 5, col 16:
  4 |     try {
> 5 |         return e;
                     ^
  6 |     } catch (e) {
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-catch 1`] = `
"<unknown>:7:12: Variable "foo" is trying to shadow an existing constant with the same name
Line 7, col 12:
  6 |     try { }
> 7 |     catch (foo) {   // <-- \`foo\` shadows global const \`foo\`
                 ^~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-external-param 1`] = `
"<unknown>:9:15: Variable "foo" is trying to shadow an existing constant with the same name
Line 9, col 15:
   8 | contract Test {
>  9 |     external (foo: Message) { // <-- \`foo\` shadows global const \`foo\`
                     ^~~
  10 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-foreach 1`] = `
"<unknown>:7:14: Variable "foo" is trying to shadow an existing constant with the same name
Line 7, col 14:
  6 |     let m: map<Int, Int> = null;
> 7 |     foreach (foo, _ in m) {  // <--- attempt to shadow \`foo\` const
                   ^~~
  8 |         // do nothing
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-fun-param 1`] = `
"<unknown>:5:9: Variable "foo" is trying to shadow an existing constant with the same name
Line 5, col 9:
  4 | 
> 5 | fun bar(foo: Int): Int {  // <-- fun param \`foo\` shadows global const \`foo\`
              ^~~
  6 |     return foo;
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-let 1`] = `
"<unknown>:6:9: Variable "foo" is trying to shadow an existing constant with the same name
Line 6, col 9:
  5 | fun bar(): Int {
> 6 |     let foo = 43;  // <-- local var \`foo\` shadows global const \`foo\`
              ^~~
  7 |     return foo;
"
`;

exports[`resolveStatements should fail statements for var-scope-const-shadowing-receiver-param 1`] = `
"<unknown>:9:14: Variable "foo" is trying to shadow an existing constant with the same name
Line 9, col 14:
   8 | contract Test {
>  9 |     receive (foo: Message) { // <-- \`foo\` shadows global const \`foo\`
                    ^~~
  10 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-do-until-shadows-outer-const 1`] = `
"<unknown>:8:13: Variable "B" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     do {
> 8 |         let B: Int = a + 3;
                  ^
  9 |     } until (false);
"
`;

exports[`resolveStatements should fail statements for var-scope-do-until-shadows-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "b"
Line 7, col 13:
  6 |     do {
> 7 |         let b: Int = a + 3;
                  ^
  8 |     } until (false);
"
`;

exports[`resolveStatements should fail statements for var-scope-external-shadows-param 1`] = `
"<unknown>:8:13: Variable already exists: "foo"
Line 8, col 13:
  7 |     external (foo: Message) {
> 8 |         let foo: Int = 0;
                  ^~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-internal-var-does-not-escape 1`] = `
"<unknown>:8:12: Unable to resolve id 'x'
Line 8, col 12:
  7 |     }
> 8 |     return x;
                 ^
  9 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-key-does-not-escape 1`] = `
"<unknown>:8:12: Unable to resolve id 'k'
Line 8, col 12:
  7 |     }
> 8 |     return k;
                 ^
  9 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-key-shadows-map 1`] = `
"<unknown>:5:14: Variable already exists: "m"
Line 5, col 14:
  4 |     let m: map<Int, Int> = emptyMap();
> 5 |     foreach (m, v in m) {
                   ^
  6 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-key-shadows-outer-var 1`] = `
"<unknown>:6:14: Variable already exists: "a"
Line 6, col 14:
  5 |     let a: Int = 4;
> 6 |     foreach (a, v in m) {
                   ^
  7 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-shadows-outer-const 1`] = `
"<unknown>:8:13: Variable "m" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     foreach (k, v in m) {
> 8 |         let m: map<Int, Int> = emptyMap();
                  ^
  9 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-shadows-outer-map 1`] = `
"<unknown>:7:13: Variable already exists: "m"
Line 7, col 13:
  6 |     foreach (k, v in m) {
> 7 |         let m: map<Int, Int> = emptyMap();
                  ^
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-shadows-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "a"
Line 7, col 13:
  6 |     foreach (k, v in m) {
> 7 |         let a: Int = 5;
                  ^
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-val-does-not-escape 1`] = `
"<unknown>:8:12: Unable to resolve id 'v'
Line 8, col 12:
  7 |     }
> 8 |     return v;
                 ^
  9 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-val-shadows-const-map 1`] = `
"<unknown>:6:17: Variable "m" is trying to shadow an existing constant with the same name
Line 6, col 17:
  5 | fun test() {
> 6 |     foreach (k, m in m) {
                      ^
  7 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-val-shadows-key 1`] = `
"<unknown>:5:17: Variable already exists: "k"
Line 5, col 17:
  4 |     let m: map<Int, Int> = emptyMap();
> 5 |     foreach (k, k in m) {
                      ^
  6 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-val-shadows-map 1`] = `
"<unknown>:5:17: Variable already exists: "m"
Line 5, col 17:
  4 |     let m: map<Int, Int> = emptyMap();
> 5 |     foreach (k, m in m) {
                      ^
  6 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-foreach-val-shadows-outer-var 1`] = `
"<unknown>:6:17: Variable already exists: "a"
Line 6, col 17:
  5 |     let a: Int = 4;
> 6 |     foreach (k, a in m) {
                      ^
  7 |         // something
"
`;

exports[`resolveStatements should fail statements for var-scope-function-shadows-local-var 1`] = `
"<unknown>:5:9: Variable already exists: "c"
Line 5, col 9:
  4 |     let c: Int = 456;
> 5 |     let c: Int = 10;
              ^
  6 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-function-shadows-param 1`] = `
"<unknown>:4:9: Variable already exists: "b"
Line 4, col 9:
  3 | fun testFunction(a: Int, b: Int): Int {
> 4 |     let b: Int = 456;
              ^
  5 |     return b;
"
`;

exports[`resolveStatements should fail statements for var-scope-if-else-shadows-outer-const 1`] = `
"<unknown>:10:13: Variable "A" is trying to shadow an existing constant with the same name
Line 10, col 13:
   9 |     } else {
> 10 |         let A: Int = 2;
                   ^
  11 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-if-else-shadows-outer-var 1`] = `
"<unknown>:9:13: Variable already exists: "a"
Line 9, col 13:
   8 |     } else {
>  9 |         let a: Int = 2;
                   ^
  10 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-if-then-shadows-outer-const 1`] = `
"<unknown>:8:13: Variable "A" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     if (true) {
> 8 |         let A: Int = 2;
                  ^
  9 |     } else {
"
`;

exports[`resolveStatements should fail statements for var-scope-if-then-shadows-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "a"
Line 7, col 13:
  6 |     if (true) {
> 7 |         let a: Int = 2;
                  ^
  8 |     } else {
"
`;

exports[`resolveStatements should fail statements for var-scope-local-catch-param-does-not-escape 1`] = `
"<unknown>:9:12: Unable to resolve id 'e'
Line 9, col 12:
   8 |     }
>  9 |     return e;
                  ^
  10 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-local-loop-var-does-not-escape 1`] = `
"<unknown>:9:12: Unable to resolve id 'c'
Line 9, col 12:
   8 |     }
>  9 |     return c;
                  ^
  10 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-missing-storage-var 1`] = `
"<unknown>:5:14: Type "Test" does not have a field named "nonExistentField"
Line 5, col 14:
  4 |     init() {
> 5 |         self.nonExistentField = 42;
                   ^~~~~~~~~~~~~~~~
  6 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-no-toString-global-fun1 1`] = `
"<unknown>:7:9: Static function "toString" does not exist
Line 7, col 9:
  6 |     init() {
> 7 |         toString(); // non-existent function
              ^~~~~~~~~~
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-no-toString-global-fun2 1`] = `
"<unknown>:6:12: Static function "toString" does not exist. Perhaps you meant to call ".toString(...)" extension function?
Line 6, col 12:
  5 | extends fun toString(self: WrappedInt): Int {
> 6 |     return toString(self.x);
                 ^~~~~~~~~~~~~~~~
  7 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-no-valueOf-global-fun 1`] = `
"<unknown>:4:5: Static function "valueOf" does not exist
Line 4, col 5:
  3 | fun foo(x: Int) {
> 4 |     valueOf(x);
          ^~~~~~~~~~
  5 | }
"
`;

exports[`resolveStatements should fail statements for var-scope-rec-fun-shadowing-catch 1`] = `
"<unknown>:6:14: Variable cannot have the same name as its enclosing function: "rec"
Line 6, col 14:
  5 |         42/0;
> 6 |     } catch (rec) {  // <-- shadowing
                   ^~~
  7 |         return rec;
"
`;

exports[`resolveStatements should fail statements for var-scope-rec-fun-shadowing-foreach 1`] = `
"<unknown>:5:14: Variable cannot have the same name as its enclosing function: "rec"
Line 5, col 14:
  4 |     let m: map<Int, Int> = null;
> 5 |     foreach (rec, _ in m) {   // shadowing error
                   ^~~
  6 |         42/0;
"
`;

exports[`resolveStatements should fail statements for var-scope-rec-fun-shadowing-fun-param 1`] = `
"<unknown>:3:9: Variable cannot have the same name as its enclosing function: "rec"
Line 3, col 9:
  2 | 
> 3 | fun rec(rec: Int): Int { // <-- shadowing
              ^~~
  4 |     return rec;
"
`;

exports[`resolveStatements should fail statements for var-scope-rec-fun-shadowing-let 1`] = `
"<unknown>:4:9: Variable cannot have the same name as its enclosing function: "rec"
Line 4, col 9:
  3 | fun rec(): Int {
> 4 |     let rec: Int = 42;  // shadowing error
              ^~~
  5 |     return rec;
"
`;

exports[`resolveStatements should fail statements for var-scope-receiver-shadows-param 1`] = `
"<unknown>:8:13: Variable already exists: "foo"
Line 8, col 13:
  7 |     receive (foo: Message) {
> 8 |         let foo: Int = 0;
                  ^~~
  9 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-repeat-shadows-outer-const 1`] = `
"<unknown>:8:13: Variable "B" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     repeat (a) {
> 8 |         let B: Int = a + 3;
                  ^
  9 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-repeat-shadows-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "b"
Line 7, col 13:
  6 |     repeat (a) {
> 7 |         let b: Int = a + 3;
                  ^
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-try-does-not-shadow-outer-const 1`] = `
"<unknown>:8:13: Variable "e" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     try {
> 8 |         let e: String = "rty";
                  ^
  9 |         return e;
"
`;

exports[`resolveStatements should fail statements for var-scope-try-does-not-shadow-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "e"
Line 7, col 13:
  6 |     try {
> 7 |         let e: String = "rty";
                  ^
  8 |         return e;
"
`;

exports[`resolveStatements should fail statements for var-scope-while-shadows-outer-const 1`] = `
"<unknown>:8:13: Variable "B" is trying to shadow an existing constant with the same name
Line 8, col 13:
  7 |     while (true) {
> 8 |         let B: Int = a + 3;
                  ^
  9 |     }
"
`;

exports[`resolveStatements should fail statements for var-scope-while-shadows-outer-var 1`] = `
"<unknown>:7:13: Variable already exists: "b"
Line 7, col 13:
  6 |     while (true) {
> 7 |         let b: Int = a + 3;
                  ^
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-underscore-name-access 1`] = `
"<unknown>:6:16: Wildcard variable name '_' cannot be accessed
Line 6, col 16:
  5 |     foreach (_, _ in m) {
> 6 |         return _;
                     ^
  7 |     }
"
`;

exports[`resolveStatements should fail statements for var-underscore-name-access2 1`] = `
"<unknown>:7:14: Wildcard variable name '_' cannot be accessed
Line 7, col 14:
  6 |     foreach (_, v in m) {
> 7 |         x += _;
                   ^
  8 |     }
"
`;

exports[`resolveStatements should fail statements for var-underscore-name-access3 1`] = `
"<unknown>:9:12: Wildcard variable name '_' cannot be accessed
Line 9, col 12:
   8 |     let _: Int = someImpureFunction();
>  9 |     return _;
                  ^
  10 | }
"
`;

exports[`resolveStatements should fail statements for wf-type-let 1`] = `
"<unknown>:5:16: Invalid map type. Check https://docs.tact-lang.org/book/maps#allowed-types
Line 5, col 16:
  4 | fun foo() {
> 5 |     let m: map<String, Int> = null;
                     ^~~~~~
  6 | }
"
`;

exports[`resolveStatements should resolve statements for assign-self-mutating-method 1`] = `
[
  [
    "self",
    "Int",
  ],
  [
    "42",
    "Int",
  ],
  [
    "self",
    "IntWrapper",
  ],
  [
    "self.x",
    "Int",
  ],
  [
    "42",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for contract-receiver-bounced 1`] = `
[
  [
    "src",
    "bounced<A>",
  ],
  [
    "src.a",
    "Int",
  ],
  [
    "src",
    "bounced<A>",
  ],
  [
    "src.b",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-arith-bool-cmp 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "123 + 10",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "(123 + 10) / 10",
    "Int",
  ],
  [
    "x",
    "Int",
  ],
  [
    "(123 + 10) / 10 == x",
    "Bool",
  ],
  [
    "y",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "y > 0",
    "Bool",
  ],
  [
    "(123 + 10) / 10 == x && y > 0",
    "Bool",
  ],
  [
    "z",
    "Bool",
  ],
  [
    "(123 + 10) / 10 == x && y > 0 || z",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-conditional-with-subtyping 1`] = `
[
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "42",
    "Int",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "cond ? 42 : x",
    "Int?",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "42",
    "Int",
  ],
  [
    "cond ? x : 42",
    "Int?",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "42",
    "Int",
  ],
  [
    "cond ? null : 42",
    "Int?",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "42",
    "Int",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "cond ? 42 : null",
    "Int?",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "42",
    "Int",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "cond ? 42 : null",
    "Int?",
  ],
  [
    "baz",
    "Int?",
  ],
  [
    "baz!!",
    "Int",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "cond ? null : m",
    "map<Int, Int>",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "cond ? m : null",
    "map<Int, Int>",
  ],
  [
    "true",
    "Bool",
  ],
  [
    "cond",
    "Bool",
  ],
  [
    "42",
    "Int",
  ],
  [
    "Baz { b: 42 }",
    "Baz",
  ],
  [
    "Baz { b: 42 }.toCell()",
    "Cell",
  ],
  [
    "x",
    "Cell?",
  ],
  [
    "cond ? Baz { b: 42 }.toCell() : x",
    "Cell?",
  ],
  [
    "Bar {
        a: cond ? Baz { b: 42 }.toCell() : x
    }",
    "Bar",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-arith 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "123 + 10",
    "Int",
  ],
  [
    "x",
    "Int",
  ],
  [
    "123 + 10 == x",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-int-optional-int 1`] = `
[
  [
    "x",
    "Int?",
  ],
  [
    "y",
    "Int",
  ],
  [
    "x == y",
    "Bool",
  ],
  [
    "y",
    "Int",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "y == x",
    "Bool",
  ],
  [
    "x == y || y == x",
    "Bool",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "x == x",
    "Bool",
  ],
  [
    "x == y || y == x || x == x",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-literal 1`] = `
[
  [
    "x",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "x == 0",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-map-map 1`] = `
[
  [
    "m1",
    "map<Int, Address>",
  ],
  [
    "m2",
    "map<Int, Address>",
  ],
  [
    "m1 == m2",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-map-null 1`] = `
[
  [
    "m",
    "map<Int, Address>",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "m == null",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-null-null 1`] = `
[
  [
    "null",
    "<null>",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "null == null",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-optional-int-null 1`] = `
[
  [
    "x",
    "Int?",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "x == null",
    "Bool",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "x",
    "Int?",
  ],
  [
    "null == x",
    "Bool",
  ],
  [
    "x == null || null == x",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-eq-optional-struct-null 1`] = `
[
  [
    "s",
    "S?",
  ],
  [
    "null",
    "<null>",
  ],
  [
    "s != null",
    "Bool",
  ],
  [
    "s",
    "S?",
  ],
  [
    "s!!",
    "S",
  ],
  [
    "s!!.f",
    "Int",
  ],
  [
    "42",
    "Int",
  ],
  [
    "s!!.f == 42",
    "Bool",
  ],
  [
    "false",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-field-access-method-call 1`] = `
[
  [
    "p",
    "Point",
  ],
  [
    "p.x",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "p.x == 0",
    "Bool",
  ],
  [
    "p",
    "Point",
  ],
  [
    "p.y",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "p.y == 0",
    "Bool",
  ],
  [
    "p.x == 0 && p.y == 0",
    "Bool",
  ],
  [
    "p",
    "Point",
  ],
  [
    "p.toCell()",
    "Cell",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-maps-del-method 1`] = `
[
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "m.set(1, 2)",
    "<void>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "3",
    "Int",
  ],
  [
    "m.del(3)",
    "Bool",
  ],
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int as uint8>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "m.set(1, 2)",
    "<void>",
  ],
  [
    "m",
    "map<Int, Int as uint8>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "m.del(1)",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-maps-exists-method 1`] = `
[
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "m.set(1, 2)",
    "<void>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "m.exists(1)",
    "Bool",
  ],
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int as uint8>",
  ],
  [
    "1",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "m.set(1, 2)",
    "<void>",
  ],
  [
    "m",
    "map<Int, Int as uint8>",
  ],
  [
    "2",
    "Int",
  ],
  [
    "m.exists(2)",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for expr-struct-construction 1`] = `
[
  [
    "1",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "SomeStruct{
        a: 1,
        b: 2
    }",
    "SomeStruct",
  ],
]
`;

exports[`resolveStatements should resolve statements for init-vars-analysis-with-if 1`] = `
[
  [
    "arg",
    "Bool",
  ],
  [
    "self",
    "Contract",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "arg",
    "Bool",
  ],
  [
    "!arg",
    "Bool",
  ],
  [
    "self",
    "Contract",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "self",
    "Contract",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "3",
    "Int",
  ],
  [
    "self",
    "Contract2",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "self",
    "Contract2",
  ],
  [
    "self.value2",
    "S",
  ],
  [
    "1",
    "Int",
  ],
  [
    "self",
    "Contract2",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "S{ a: 1, b: self.value }",
    "S",
  ],
  [
    "self",
    "Contract3",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "self",
    "Contract3",
  ],
  [
    "self.update()",
    "<void>",
  ],
  [
    "self",
    "Contract3",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "self",
    "Contract3",
  ],
  [
    "self.value",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "self.value + 1",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-if-elseif 1`] = `
[
  [
    "b",
    "Bool",
  ],
  [
    "42",
    "Int",
  ],
  [
    "c",
    "Bool",
  ],
  [
    "43",
    "Int",
  ],
  [
    "d",
    "Bool",
  ],
  [
    "44",
    "Int",
  ],
  [
    "45",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-if-try-catch-do-loop 1`] = `
[
  [
    "b",
    "Bool",
  ],
  [
    "1",
    "Int",
  ],
  [
    "b",
    "Bool",
  ],
  [
    "0",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "b ? 0 : 1",
    "Int",
  ],
  [
    "1 / (b ? 0 : 1)",
    "Int",
  ],
  [
    "42",
    "Int",
  ],
  [
    "43",
    "Int",
  ],
  [
    "b",
    "Bool",
  ],
  [
    "!b",
    "Bool",
  ],
  [
    "44",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-no-return-in-void1 1`] = `[]`;

exports[`resolveStatements should resolve statements for return-analysis-no-return-in-void2 1`] = `
[
  [
    "42",
    "Int",
  ],
  [
    "x",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-throw1 1`] = `
[
  [
    "c",
    "Bool",
  ],
  [
    "200",
    "Int",
  ],
  [
    "throw(200)",
    "<void>",
  ],
  [
    "42",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-throw2 1`] = `
[
  [
    "c",
    "Bool",
  ],
  [
    "200",
    "Int",
  ],
  [
    "nativeThrow(200)",
    "<void>",
  ],
  [
    "42",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for return-analysis-try-catch 1`] = `
[
  [
    "0",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "42",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "43",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-augmented-assgn-numerical-type 1`] = `
[
  [
    "3",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-let-assgn 1`] = `
[
  [
    "x",
    "Int",
  ],
  [
    "y",
    "Int",
  ],
  [
    "x + y",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "b + 1",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "b > 0",
    "Bool",
  ],
  [
    "z",
    "Bool",
  ],
  [
    "b > 0 || z",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-let-assgn-unbox 1`] = `
[
  [
    "x",
    "Int",
  ],
  [
    "y",
    "Int",
  ],
  [
    "x + y",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "b + 1",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "b > 0",
    "Bool",
  ],
  [
    "z",
    "Bool",
  ],
  [
    "b > 0 || z",
    "Bool",
  ],
  [
    "w",
    "Int?",
  ],
  [
    "w!!",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "w!! > 0",
    "Bool",
  ],
  [
    "b > 0 || z || (w!! > 0)",
    "Bool",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-let-if-elseif 1`] = `
[
  [
    "10",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "0",
    "Int",
  ],
  [
    "a > 0",
    "Bool",
  ],
  [
    "a",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "-10",
    "Int",
  ],
  [
    "a < -10",
    "Bool",
  ],
  [
    "a",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "-1",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-let-map-type-inference 1`] = `
[
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "a",
    "map<Int, Int as uint32>",
  ],
]
`;

exports[`resolveStatements should resolve statements for stmt-let-nullable-type-inference 1`] = `
[
  [
    "null",
    "<null>",
  ],
  [
    "a",
    "Int?",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-scope-let-toString 1`] = `
[
  [
    "1",
    "Int",
  ],
  [
    "toString",
    "Int",
  ],
  [
    "dump(toString)",
    "<void>",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-scope-repeat 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "456",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "a + b",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "a + b",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-scope-repeat2 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "456",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "a",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "a + b",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-scope-toString-non-method 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "toString()",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-scope-valueOf-fun 1`] = `
[
  [
    "a",
    "Int",
  ],
  [
    "b",
    "Int",
  ],
  [
    "a + b",
    "Int",
  ],
  [
    "2",
    "Int",
  ],
  [
    "(a + b) / 2",
    "Int",
  ],
  [
    "1",
    "Int",
  ],
  [
    "10",
    "Int",
  ],
  [
    "valueOf(1, 10)",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-underscore-name-in-foreach 1`] = `
[
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-underscore-name-in-foreach2 1`] = `
[
  [
    "emptyMap()",
    "<null>",
  ],
  [
    "0",
    "Int",
  ],
  [
    "m",
    "map<Int, Int>",
  ],
  [
    "x",
    "Int",
  ],
  [
    "v",
    "Int",
  ],
  [
    "x",
    "Int",
  ],
]
`;

exports[`resolveStatements should resolve statements for var-underscore-name-in-let 1`] = `
[
  [
    "123",
    "Int",
  ],
  [
    "someImpureFunction()",
    "Int",
  ],
  [
    "someImpureFunction()",
    "Int",
  ],
  [
    "123",
    "Int",
  ],
]
`;
