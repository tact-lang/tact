FunC {
  Module = Pragma* Include* ModuleItem*

  //
  // Compiler pragmas and includes
  //

  Pragma = "#pragma" ("allow-post-modification" | "compute-asm-ltr") ";" --literal
         | "#pragma" ("version" | "not-version") versionRange ";" --versionRange
         | "#pragma" "test-version-set" stringLiteral ";" --versionString

  Include = "#include" stringLiteral ";"

  //
  // Top-level, module items
  //

  ModuleItem = GlobalVariablesDeclaration
             | ConstantsDefinition
             | AsmFunctionDefinition
             | FunctionDeclaration
             | FunctionDefinition

  GlobalVariablesDeclaration = "global" NonemptyListOf<GlobalVariableDeclaration, ","> ";"
  GlobalVariableDeclaration = TypeUniform? id

  ConstantsDefinition = "const" NonemptyListOf<ConstantDefinition, ","> ";"
  ConstantDefinition = ("slice" | "int")? id "=" Expression

  AsmFunctionDefinition = FunctionCommonPrefix "asm" AsmArrangement? (multiLineStringLiteral | stringLiteral)+ ";"

  AsmArrangement = "(" "->" integerLiteralDec+ ")" --returns
                 | "(" id+ ~"->" ")" --arguments
                 | "(" id+ "->" integerLiteralDec+ ")" --argumentsToReturns

  FunctionDeclaration = FunctionCommonPrefix ";"

  FunctionDefinition = FunctionCommonPrefix "{" Statement* "}"

  // Common prefix of function declarations and definitions
  FunctionCommonPrefix = Forall? Type functionId Parameters FunctionAttribute*

  // Called "specifiers" in https://docs.ton.org/develop/func/functions#specifiers
  FunctionAttribute = "impure" | "inline_ref" | "inline" | MethodIdValue | "method_id"
  MethodIdValue = "method_id" "(" integerLiteralNonNegative ")"

  //
  // Statements
  //

  Statement = StatementReturn
            | StatementBlock
            | StatementEmpty
            | StatementCondition
            | StatementRepeat
            | StatementUntil
            | StatementWhile
            | StatementTryCatch
            | StatementExpression

  StatementReturn = "return" Expression ";"
  StatementBlock = "{" Statement* "}"
  StatementEmpty = ";"
  StatementCondition = ("ifnot" | "if" ) Expression "{" Statement* "}" ("elseifnot" | "elseif") Expression "{" Statement* "}" --withElseCondition
                     | ("ifnot" | "if" ) Expression "{" Statement* "}" "else" "{" Statement* "}" --withElse
                     | ("ifnot" | "if" ) Expression "{" Statement* "}" --noElse
  StatementRepeat = "repeat" Expression "{" Statement* "}"
  StatementUntil = "do" "{" Statement* "}" "until" Expression ";"
  StatementWhile = "while" Expression "{" Statement* "}"
  StatementTryCatch = "try" "{" Statement* "}" "catch" "(" (unusedId | id) "," (unusedId | id) ")" "{" Statement* "}"
  StatementExpression = Expression ";"

  //
  // Expressions, ordered by precedence (from lowest to highest),
  // with comments referencing exact function names in C++ code of FunC's parser:
  // https://github.com/ton-blockchain/ton/blob/master/crypto/func/parse-func.cpp
  //

  // NOTE: they should parse exactly as FunC 0.4.4 does it, including the issues with precedences of ^ | and similar

  // parse_expr
  // Expression = integerLiteral | stringLiteral | id // FIXME temporary, for tests prior to expressions
  Expression = ExpressionAssign

  // parse_expr10
  ExpressionAssign = ExpressionConditional "="    ExpressionAssign --assign
                   | ExpressionConditional "+="   ExpressionAssign --addAssign
                   | ExpressionConditional "-="   ExpressionAssign --subAssign
                   | ExpressionConditional "*="   ExpressionAssign --mulAssign
                   | ExpressionConditional "/="   ExpressionAssign --divAssign
                   | ExpressionConditional "%="   ExpressionAssign --modAssign
                   | ExpressionConditional "~/="  ExpressionAssign --divRoundAssign
                   | ExpressionConditional "~%="  ExpressionAssign --modRoundAssign
                   | ExpressionConditional "^/="  ExpressionAssign --divCeilAssign
                   | ExpressionConditional "^%="  ExpressionAssign --modCeilAssign
                   | ExpressionConditional "&="   ExpressionAssign --bitwiseAndAssign
                   | ExpressionConditional "|="   ExpressionAssign --bitwiseOrAssign
                   | ExpressionConditional "^="   ExpressionAssign --bitwiseXorAssign
                   | ExpressionConditional "<<="  ExpressionAssign --shlAssign
                   | ExpressionConditional ">>="  ExpressionAssign --shrAssign
                   | ExpressionConditional "~>>=" ExpressionAssign --shrRoundAssign
                   | ExpressionConditional "^>>=" ExpressionAssign --shrCeilAssign
                   | ExpressionConditional

  // parse_expr13
  ExpressionConditional = ExpressionCompare "?" Expression ":" ExpressionConditional --ternary
                        | ExpressionCompare

  // parse_expr15
  ExpressionCompare = ExpressionBitwiseShift "=="  ExpressionBitwiseShift --eq
                    | ExpressionBitwiseShift "<=>" ExpressionBitwiseShift --spaceship
                    | ExpressionBitwiseShift "<="  ExpressionBitwiseShift --lte
                    | ExpressionBitwiseShift "<"   ExpressionBitwiseShift --lt
                    | ExpressionBitwiseShift ">="  ExpressionBitwiseShift --gte
                    | ExpressionBitwiseShift ">"   ExpressionBitwiseShift --gt
                    | ExpressionBitwiseShift "!="  ExpressionBitwiseShift --neq
                    | ExpressionBitwiseShift

  // parse_expr17
  ExpressionBitwiseShift = ExpressionAddBitwise ("<<"  ExpressionAddBitwise)+ --shl
                         | ExpressionAddBitwise (">>"  ExpressionAddBitwise)+ --shr
                         | ExpressionAddBitwise ("~>>" ExpressionAddBitwise)+ --shrRound
                         | ExpressionAddBitwise ("^>>" ExpressionAddBitwise)+ --shrCeil
                         | ExpressionAddBitwise

  // parse_expr20
  ExpressionAddBitwise = ("-" &whiteSpace)? ExpressionMulBitwise ("+" ExpressionMulBitwise)+ --add
                       | ("-" &whiteSpace)? ExpressionMulBitwise ("-" ExpressionMulBitwise)+ --sub
                       | ("-" &whiteSpace)? ExpressionMulBitwise ("|" ExpressionMulBitwise)+ --bitwiseOr
                       | ("-" &whiteSpace)? ExpressionMulBitwise ("^" ExpressionMulBitwise)+ --bitwiseXor
                       | ("-" &whiteSpace) ExpressionMulBitwise --minus
                       | ExpressionMulBitwise

  // parse_expr30
  ExpressionMulBitwise = ExpressionUnary ("*"  ExpressionUnary)+ --mul
                       | ExpressionUnary ("/%" ExpressionUnary)+ --divMod
                       | ExpressionUnary ("/"  ExpressionUnary)+ --div
                       | ExpressionUnary ("%"  ExpressionUnary)+ --mod
                       | ExpressionUnary ("~/" ExpressionUnary)+ --divRound
                       | ExpressionUnary ("~%" ExpressionUnary)+ --modRound
                       | ExpressionUnary ("^/" ExpressionUnary)+ --divCeil
                       | ExpressionUnary ("^%" ExpressionUnary)+ --modCeil
                       | ExpressionUnary ("&"  ExpressionUnary)+ --bitwiseAnd
                       | ExpressionUnary

  // parse_expr75
  ExpressionUnary = "~" &whiteSpace ExpressionMethodCall --bitwiseNot
                  | ExpressionMethodCall

  // parse_expr80
  ExpressionMethodCall = ExpressionSequence ("." | "~") id ExpressionPrimary --call
                       | ExpressionSequence

  // FIXME: Temporary definition for debugging purposes.
  ExpressionSequence = ExpressionPrimary

  // parse_expr90, FIXME: this is wrong and has to be re-made :)
  // TODO: function call
  // TODO: variable declaration
  // ExpressionSequence = ExpressionPrimary &"(" ExpressionPrimary --call
  //                    | ExpressionPrimary &"[" ExpressionPrimary --access
  //                    | ExpressionPrimary ~("." | "~") id ExpressionPrimary --id
  //                    | ExpressionPrimary

  // parse_expr100, order is important
  ExpressionPrimary =
                    // TODO: parens?
                    | integerLiteral | multiLineStringLiteral | stringLiteral | TypeUniform | id

  // ExpressionParens = "(" Expression ")"

  //
  // Miscellaneous syntactic rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // forall type1, ..., typeN ->
  Forall = "forall" NonemptyListOf<TypeVar, ","> "->"
  TypeVar = "type"? id

  // Parameters, with type holes prohibited during syntax analysis
  Parameters = "(" ListOf<Parameter, ","> ")"
  Parameter = Type id

  // Arguments -- TODO: unused, remove?
  // Arguments = "(" ListOf<Argument, ","> ")"
  // Argument = id

  // Mapped or unmapped builtin types or type variables,
  // where "mapped" refers to: https://docs.ton.org/develop/func/types#functional-type
  // and type variables refer to parametric polymorphism with `forall`
  Type = TypeBuiltin "->" Type --mapped
       | TypeBuiltin --builtin
       | id --var

  // Builtin types
  TypeBuiltin = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
              | Tensor | Tuple | hole | unit

  // Non-functional composite builtin types
  Tensor = "(" NonemptyListOf<Type, ","> ")"
  Tuple = "[" NonemptyListOf<Type, ","> "]"

  // Non-polymorphic, uniform types
  TypeUniform = TypeBuiltinUniform "->" TypeUniform --mapped
              | TypeBuiltinUniform --builtin

  TypeBuiltinUniform = "int" | "cell" | "slice" | "builder" | "cont" | "tuple"
                     | TensorUniform | TupleUniform | hole | unit

  TensorUniform = "(" NonemptyListOf<TypeUniform, ","> ")"

  TupleUniform = "[" NonemptyListOf<TypeUniform, ","> "]"

  //
  // Lexical rules, see: https://ohmjs.org/docs/syntax-reference#syntactic-lexical
  //

  // Special types
  hole = "_" | "var"
  unit = "()"

  // Function identifiers
  functionId = ~("\"" | "{-") ("." | "~")? (quotedId | plainId)

  // Identifiers, with invalidation (keywords, numbers, etc.) during syntax analysis
  // — this makes this parser closer to the C++ one, and also improves error messages

  id = ~("\"" | "{-" | "." | "~") (quotedId | plainId)

  quotedId = "`" (~("`" | "\n") any)+ "`"
  plainId = (~(whiteSpace | "(" | ")" | "[ | ]" | "," | "." | ";" | "~") any)+

  // Unused identifiers
  unusedId = "_"

  /*
    FunC can parse much more than Fift can handle. For example, _0x0 and _0 are valid identifiers in FunC, and using either of them compiles and is then interpreted fine by Fift. But if you use both, FunC still compiles, but Fift crashes.

    Same goes for plain identifiers using hashes # or emojis — you can have one FunC function with any of those combinations of characters, but you (generally) cannot have two or more of such functions.
  */

  // Version ranges
  versionRange = ("=" | "^" | "<=" | ">=" | "<" | ">")? integerLiteralDec ("." integerLiteralDec)? ("." integerLiteralDec)?

  // Integers
  integerLiteral = "-"? integerLiteralNonNegative
  integerLiteralNonNegative = integerLiteralHex | integerLiteralDec

  // hexDigit is defined in Ohm's built-in rules as: hexDigit = "0".."9" | "a".."f" | "A".."F"
  integerLiteralHex = "0x" hexDigit+

  // digit is defined in Ohm's built-in rules as: digit = "0".."9"
  integerLiteralDec = digit+

  // Strings
  stringLiteral = "\"" (~"\"" any)* "\"" stringType?
  multiLineStringLiteral = "\"\"\"" (~"\"\"\"" any)* "\"\"\"" stringType?

  stringType = "s" --sliceHex
             | "a" --sliceInternalAddress
             | "u" --intHex
             | "h" --int32Sha256
             | "H" --int256Sha256
             | "c" --intCrc32

  // Whitespace
  space += comment | lineTerminator
  whiteSpace = "\t" | " " | lineTerminator

  // Comments
  comment = ";;" (~lineTerminator any)* --singleLine
          | multiLineComment --multiLine

  // Nested multi-line comments
  multiLineComment = "{-" (~("-}" | "{-") any)* multiLineComment? (~"-}" any)* "-}"

  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
}
