// AUTOGENERATED, DO NOT EDIT, generated by ../generator/gen-converter.ts
import * as $ from "@/asm/text/util";
import * as c from "@/asm/runtime";
import { $ast } from "@/asm/text/grammar";
export const PUSHNAN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PUSHNAN(loc);
};
export const ADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADD(loc);
};
export const SUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUB(loc);
};
export const SUBR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBR(loc);
};
export const NEGATE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NEGATE(loc);
};
export const INC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.INC(loc);
};
export const DEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DEC(loc);
};
export const MUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MUL(loc);
};
export const POW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.POW2(loc);
};
export const AND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.AND(loc);
};
export const OR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.OR(loc);
};
export const XOR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.XOR(loc);
};
export const NOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NOT(loc);
};
export const FITSX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.FITSX(loc);
};
export const UFITSX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UFITSX(loc);
};
export const BITSIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BITSIZE(loc);
};
export const UBITSIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UBITSIZE(loc);
};
export const MIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MIN(loc);
};
export const MAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MAX(loc);
};
export const MINMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MINMAX(loc);
};
export const ABS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ABS(loc);
};
export const QADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADD(loc);
};
export const QSUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QSUB(loc);
};
export const QSUBR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QSUBR(loc);
};
export const QNEGATE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QNEGATE(loc);
};
export const QINC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QINC(loc);
};
export const QDEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDEC(loc);
};
export const QMUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMUL(loc);
};
export const QPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QPOW2(loc);
};
export const QAND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QAND(loc);
};
export const QOR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QOR(loc);
};
export const QXOR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QXOR(loc);
};
export const QNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QNOT(loc);
};
export const QFITSX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QFITSX(loc);
};
export const QUFITSX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QUFITSX(loc);
};
export const QBITSIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QBITSIZE(loc);
};
export const QUBITSIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QUBITSIZE(loc);
};
export const QMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMIN(loc);
};
export const QMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMAX(loc);
};
export const QMINMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMINMAX(loc);
};
export const QABS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QABS(loc);
};
export const SGN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SGN(loc);
};
export const LESS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LESS(loc);
};
export const EQUAL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.EQUAL(loc);
};
export const LEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LEQ(loc);
};
export const GREATER: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GREATER(loc);
};
export const NEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NEQ(loc);
};
export const GEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GEQ(loc);
};
export const CMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CMP(loc);
};
export const ISNAN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ISNAN(loc);
};
export const CHKNAN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHKNAN(loc);
};
export const QSGN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QSGN(loc);
};
export const QLESS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLESS(loc);
};
export const QEQUAL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QEQUAL(loc);
};
export const QLEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLEQ(loc);
};
export const QGREATER: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QGREATER(loc);
};
export const QNEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QNEQ(loc);
};
export const QGEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QGEQ(loc);
};
export const QCMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QCMP(loc);
};
export const SEMPTY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SEMPTY(loc);
};
export const SDEMPTY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDEMPTY(loc);
};
export const SREMPTY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SREMPTY(loc);
};
export const SDFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDFIRST(loc);
};
export const SDLEXCMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDLEXCMP(loc);
};
export const SDEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDEQ(loc);
};
export const SDPFX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPFX(loc);
};
export const SDPFXREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPFXREV(loc);
};
export const SDPPFX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPPFX(loc);
};
export const SDPPFXREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPPFXREV(loc);
};
export const SDSFX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDSFX(loc);
};
export const SDSFXREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDSFXREV(loc);
};
export const SDPSFX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPSFX(loc);
};
export const SDPSFXREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDPSFXREV(loc);
};
export const SDCNTLEAD0: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCNTLEAD0(loc);
};
export const SDCNTLEAD1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCNTLEAD1(loc);
};
export const SDCNTTRAIL0: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCNTTRAIL0(loc);
};
export const SDCNTTRAIL1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCNTTRAIL1(loc);
};
export const NEWC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NEWC(loc);
};
export const ENDC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ENDC(loc);
};
export const ENDCST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ENDCST(loc);
};
export const STBREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBREF(loc);
};
export const STB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STB(loc);
};
export const STREFR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STREFR(loc);
};
export const STBREFR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBREFR(loc);
};
export const STSLICER: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSLICER(loc);
};
export const STBR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBR(loc);
};
export const STREFQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STREFQ(loc);
};
export const STBREFQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBREFQ(loc);
};
export const STSLICEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSLICEQ(loc);
};
export const STBQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBQ(loc);
};
export const STREFRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STREFRQ(loc);
};
export const STBREFRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBREFRQ(loc);
};
export const STSLICERQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSLICERQ(loc);
};
export const STBRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STBRQ(loc);
};
export const ENDXC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ENDXC(loc);
};
export const BDEPTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BDEPTH(loc);
};
export const BBITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BBITS(loc);
};
export const BREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BREFS(loc);
};
export const BBITREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BBITREFS(loc);
};
export const BREMBITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BREMBITS(loc);
};
export const BREMREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BREMREFS(loc);
};
export const BREMBITREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BREMBITREFS(loc);
};
export const BCHKREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKREFS(loc);
};
export const BCHKBITREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKBITREFS(loc);
};
export const BCHKREFSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKREFSQ(loc);
};
export const BCHKBITREFSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKBITREFSQ(loc);
};
export const STZEROES: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STZEROES(loc);
};
export const STONES: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STONES(loc);
};
export const STSAME: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSAME(loc);
};
export const CTOS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CTOS(loc);
};
export const ENDS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ENDS(loc);
};
export const LDREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDREF(loc);
};
export const LDREFRTOS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDREFRTOS(loc);
};
export const SDCUTFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCUTFIRST(loc);
};
export const SDSKIPFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDSKIPFIRST(loc);
};
export const SDCUTLAST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDCUTLAST(loc);
};
export const SDSKIPLAST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDSKIPLAST(loc);
};
export const SDSUBSTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDSUBSTR(loc);
};
export const SCUTFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCUTFIRST(loc);
};
export const SSKIPFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SSKIPFIRST(loc);
};
export const SCUTLAST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCUTLAST(loc);
};
export const SSKIPLAST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SSKIPLAST(loc);
};
export const SUBSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBSLICE(loc);
};
export const SPLIT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SPLIT(loc);
};
export const SPLITQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SPLITQ(loc);
};
export const XCTOS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.XCTOS(loc);
};
export const XLOAD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.XLOAD(loc);
};
export const XLOADQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.XLOADQ(loc);
};
export const SCHKBITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKBITS(loc);
};
export const SCHKREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKREFS(loc);
};
export const SCHKBITREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKBITREFS(loc);
};
export const SCHKBITSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKBITSQ(loc);
};
export const SCHKREFSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKREFSQ(loc);
};
export const SCHKBITREFSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SCHKBITREFSQ(loc);
};
export const PLDREFVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDREFVAR(loc);
};
export const SBITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SBITS(loc);
};
export const SREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SREFS(loc);
};
export const SBITREFS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SBITREFS(loc);
};
export const LDZEROES: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDZEROES(loc);
};
export const LDONES: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDONES(loc);
};
export const LDSAME: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDSAME(loc);
};
export const SDEPTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDEPTH(loc);
};
export const CDEPTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CDEPTH(loc);
};
export const CLEVEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CLEVEL(loc);
};
export const CLEVELMASK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CLEVELMASK(loc);
};
export const CHASHIX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHASHIX(loc);
};
export const CDEPTHIX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CDEPTHIX(loc);
};
export const EXECUTE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.EXECUTE(loc);
};
export const JMPX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.JMPX(loc);
};
export const RET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RET(loc);
};
export const RETALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RETALT(loc);
};
export const RETBOOL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RETBOOL(loc);
};
export const CALLCC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CALLCC(loc);
};
export const JMPXDATA: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.JMPXDATA(loc);
};
export const CALLXVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CALLXVARARGS(loc);
};
export const RETVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RETVARARGS(loc);
};
export const JMPXVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.JMPXVARARGS(loc);
};
export const CALLCCVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CALLCCVARARGS(loc);
};
export const RETDATA: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RETDATA(loc);
};
export const RUNVMX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RUNVMX(loc);
};
export const IFRET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFRET(loc);
};
export const IFNOTRET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFNOTRET(loc);
};
export const IF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IF(loc);
};
export const IFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFNOT(loc);
};
export const IFJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFJMP(loc);
};
export const IFNOTJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFNOTJMP(loc);
};
export const IFELSE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFELSE(loc);
};
export const CONDSEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONDSEL(loc);
};
export const CONDSELCHK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONDSELCHK(loc);
};
export const IFRETALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFRETALT(loc);
};
export const IFNOTRETALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.IFNOTRETALT(loc);
};
export const REPEAT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REPEAT(loc);
};
export const REPEATEND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REPEATEND(loc);
};
export const UNTIL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNTIL(loc);
};
export const UNTILEND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNTILEND(loc);
};
export const WHILE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.WHILE(loc);
};
export const WHILEEND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.WHILEEND(loc);
};
export const AGAIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.AGAIN(loc);
};
export const AGAINEND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.AGAINEND(loc);
};
export const REPEATBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REPEATBRK(loc);
};
export const REPEATENDBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REPEATENDBRK(loc);
};
export const UNTILBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNTILBRK(loc);
};
export const UNTILENDBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNTILENDBRK(loc);
};
export const WHILEBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.WHILEBRK(loc);
};
export const WHILEENDBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.WHILEENDBRK(loc);
};
export const AGAINBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.AGAINBRK(loc);
};
export const AGAINENDBRK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.AGAINENDBRK(loc);
};
export const RETURNVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RETURNVARARGS(loc);
};
export const SETCONTVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETCONTVARARGS(loc);
};
export const SETNUMVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETNUMVARARGS(loc);
};
export const BLESS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLESS(loc);
};
export const BLESSVARARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLESSVARARGS(loc);
};
export const PUSHCTRX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PUSHCTRX(loc);
};
export const POPCTRX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.POPCTRX(loc);
};
export const SETCONTCTRX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETCONTCTRX(loc);
};
export const SETCONTCTRMANYX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETCONTCTRMANYX(loc);
};
export const BOOLAND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BOOLAND(loc);
};
export const BOOLOR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BOOLOR(loc);
};
export const COMPOSBOTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.COMPOSBOTH(loc);
};
export const ATEXIT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ATEXIT(loc);
};
export const ATEXITALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ATEXITALT(loc);
};
export const SETEXITALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETEXITALT(loc);
};
export const THENRET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THENRET(loc);
};
export const THENRETALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THENRETALT(loc);
};
export const INVERT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.INVERT(loc);
};
export const BOOLEVAL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BOOLEVAL(loc);
};
export const SAMEALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SAMEALT(loc);
};
export const SAMEALTSAVE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SAMEALTSAVE(loc);
};
export const TRY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TRY(loc);
};
export const SETCPX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETCPX(loc);
};
export const STDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STDICT(loc);
};
export const SKIPDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SKIPDICT(loc);
};
export const LDDICTS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDDICTS(loc);
};
export const PLDDICTS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDDICTS(loc);
};
export const LDDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDDICT(loc);
};
export const PLDDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDDICT(loc);
};
export const LDDICTQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDDICTQ(loc);
};
export const PLDDICTQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDDICTQ(loc);
};
export const PFXDICTSET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTSET(loc);
};
export const PFXDICTREPLACE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTREPLACE(loc);
};
export const PFXDICTADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTADD(loc);
};
export const PFXDICTDEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTDEL(loc);
};
export const PFXDICTGETQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTGETQ(loc);
};
export const PFXDICTGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTGET(loc);
};
export const PFXDICTGETJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTGETJMP(loc);
};
export const PFXDICTGETEXEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PFXDICTGETEXEC(loc);
};
export const NOP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NOP(loc);
};
export const SWAP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SWAP(loc);
};
export const DUP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DUP(loc);
};
export const OVER: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.OVER(loc);
};
export const DROP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DROP(loc);
};
export const NIP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NIP(loc);
};
export const ROT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ROT(loc);
};
export const ROTREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ROTREV(loc);
};
export const PICK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PICK(loc);
};
export const ROLL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ROLL(loc);
};
export const ROLLREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ROLLREV(loc);
};
export const BLKSWX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLKSWX(loc);
};
export const REVX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REVX(loc);
};
export const DROPX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DROPX(loc);
};
export const TUCK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TUCK(loc);
};
export const XCHGX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.XCHGX(loc);
};
export const DEPTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DEPTH(loc);
};
export const CHKDEPTH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHKDEPTH(loc);
};
export const ONLYTOPX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ONLYTOPX(loc);
};
export const ONLYX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ONLYX(loc);
};
export const ACCEPT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ACCEPT(loc);
};
export const SETGASLIMIT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETGASLIMIT(loc);
};
export const GASCONSUMED: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GASCONSUMED(loc);
};
export const COMMIT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.COMMIT(loc);
};
export const NOW: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NOW(loc);
};
export const BLOCKLT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLOCKLT(loc);
};
export const LTIME: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LTIME(loc);
};
export const RANDSEED: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RANDSEED(loc);
};
export const BALANCE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BALANCE(loc);
};
export const MYADDR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MYADDR(loc);
};
export const CONFIGROOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONFIGROOT(loc);
};
export const MYCODE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MYCODE(loc);
};
export const INCOMINGVALUE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.INCOMINGVALUE(loc);
};
export const STORAGEFEES: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STORAGEFEES(loc);
};
export const PREVBLOCKSINFOTUPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PREVBLOCKSINFOTUPLE(loc);
};
export const UNPACKEDCONFIGTUPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNPACKEDCONFIGTUPLE(loc);
};
export const DUEPAYMENT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DUEPAYMENT(loc);
};
export const CONFIGDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONFIGDICT(loc);
};
export const CONFIGPARAM: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONFIGPARAM(loc);
};
export const CONFIGOPTPARAM: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CONFIGOPTPARAM(loc);
};
export const PREVMCBLOCKS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PREVMCBLOCKS(loc);
};
export const PREVKEYBLOCK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PREVKEYBLOCK(loc);
};
export const PREVMCBLOCKS_100: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PREVMCBLOCKS_100(loc);
};
export const GLOBALID: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GLOBALID(loc);
};
export const GETGASFEE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETGASFEE(loc);
};
export const GETSTORAGEFEE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETSTORAGEFEE(loc);
};
export const GETFORWARDFEE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETFORWARDFEE(loc);
};
export const GETPRECOMPILEDGAS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETPRECOMPILEDGAS(loc);
};
export const GETORIGINALFWDFEE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETORIGINALFWDFEE(loc);
};
export const GETGASFEESIMPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETGASFEESIMPLE(loc);
};
export const GETFORWARDFEESIMPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETFORWARDFEESIMPLE(loc);
};
export const GETGLOBVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.GETGLOBVAR(loc);
};
export const SETGLOBVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETGLOBVAR(loc);
};
export const RANDU256: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RANDU256(loc);
};
export const RAND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RAND(loc);
};
export const SETRAND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETRAND(loc);
};
export const ADDRAND: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDRAND(loc);
};
export const HASHCU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.HASHCU(loc);
};
export const HASHSU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.HASHSU(loc);
};
export const SHA256U: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SHA256U(loc);
};
export const CHKSIGNU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHKSIGNU(loc);
};
export const CHKSIGNS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHKSIGNS(loc);
};
export const ECRECOVER: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ECRECOVER(loc);
};
export const SECP256K1_XONLY_PUBKEY_TWEAK_ADD: $.Convert = (
    ctx,
    instr,
    loc,
) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SECP256K1_XONLY_PUBKEY_TWEAK_ADD(loc);
};
export const P256_CHKSIGNU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.P256_CHKSIGNU(loc);
};
export const P256_CHKSIGNS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.P256_CHKSIGNS(loc);
};
export const RIST255_FROMHASH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_FROMHASH(loc);
};
export const RIST255_VALIDATE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_VALIDATE(loc);
};
export const RIST255_ADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_ADD(loc);
};
export const RIST255_SUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_SUB(loc);
};
export const RIST255_MUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_MUL(loc);
};
export const RIST255_MULBASE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_MULBASE(loc);
};
export const RIST255_PUSHL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_PUSHL(loc);
};
export const RIST255_QVALIDATE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_QVALIDATE(loc);
};
export const RIST255_QADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_QADD(loc);
};
export const RIST255_QSUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_QSUB(loc);
};
export const RIST255_QMUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_QMUL(loc);
};
export const RIST255_QMULBASE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RIST255_QMULBASE(loc);
};
export const BLS_VERIFY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_VERIFY(loc);
};
export const BLS_AGGREGATE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_AGGREGATE(loc);
};
export const BLS_FASTAGGREGATEVERIFY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_FASTAGGREGATEVERIFY(loc);
};
export const BLS_AGGREGATEVERIFY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_AGGREGATEVERIFY(loc);
};
export const BLS_G1_ADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_ADD(loc);
};
export const BLS_G1_SUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_SUB(loc);
};
export const BLS_G1_NEG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_NEG(loc);
};
export const BLS_G1_MUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_MUL(loc);
};
export const BLS_G1_MULTIEXP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_MULTIEXP(loc);
};
export const BLS_G1_ZERO: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_ZERO(loc);
};
export const BLS_MAP_TO_G1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_MAP_TO_G1(loc);
};
export const BLS_G1_INGROUP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_INGROUP(loc);
};
export const BLS_G1_ISZERO: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G1_ISZERO(loc);
};
export const BLS_G2_ADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_ADD(loc);
};
export const BLS_G2_SUB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_SUB(loc);
};
export const BLS_G2_NEG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_NEG(loc);
};
export const BLS_G2_MUL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_MUL(loc);
};
export const BLS_G2_MULTIEXP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_MULTIEXP(loc);
};
export const BLS_G2_ZERO: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_ZERO(loc);
};
export const BLS_MAP_TO_G2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_MAP_TO_G2(loc);
};
export const BLS_G2_INGROUP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_INGROUP(loc);
};
export const BLS_G2_ISZERO: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_G2_ISZERO(loc);
};
export const BLS_PAIRING: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_PAIRING(loc);
};
export const BLS_PUSHR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BLS_PUSHR(loc);
};
export const CDATASIZEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CDATASIZEQ(loc);
};
export const CDATASIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CDATASIZE(loc);
};
export const SDATASIZEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDATASIZEQ(loc);
};
export const SDATASIZE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDATASIZE(loc);
};
export const LDGRAMS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDGRAMS(loc);
};
export const LDVARINT16: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDVARINT16(loc);
};
export const STGRAMS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STGRAMS(loc);
};
export const STVARINT16: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STVARINT16(loc);
};
export const LDVARUINT32: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDVARUINT32(loc);
};
export const LDVARINT32: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDVARINT32(loc);
};
export const STVARUINT32: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STVARUINT32(loc);
};
export const STVARINT32: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STVARINT32(loc);
};
export const LDMSGADDR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDMSGADDR(loc);
};
export const LDMSGADDRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDMSGADDRQ(loc);
};
export const PARSEMSGADDR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PARSEMSGADDR(loc);
};
export const PARSEMSGADDRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PARSEMSGADDRQ(loc);
};
export const REWRITESTDADDR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REWRITESTDADDR(loc);
};
export const REWRITESTDADDRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REWRITESTDADDRQ(loc);
};
export const REWRITEVARADDR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REWRITEVARADDR(loc);
};
export const REWRITEVARADDRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.REWRITEVARADDRQ(loc);
};
export const SENDRAWMSG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SENDRAWMSG(loc);
};
export const RAWRESERVE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RAWRESERVE(loc);
};
export const RAWRESERVEX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RAWRESERVEX(loc);
};
export const SETCODE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETCODE(loc);
};
export const SETLIBCODE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETLIBCODE(loc);
};
export const CHANGELIB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.CHANGELIB(loc);
};
export const SENDMSG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SENDMSG(loc);
};
export const PUSHNULL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PUSHNULL(loc);
};
export const ISNULL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ISNULL(loc);
};
export const TUPLEVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TUPLEVAR(loc);
};
export const INDEXVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.INDEXVAR(loc);
};
export const UNTUPLEVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNTUPLEVAR(loc);
};
export const UNPACKFIRSTVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.UNPACKFIRSTVAR(loc);
};
export const EXPLODEVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.EXPLODEVAR(loc);
};
export const SETINDEXVAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETINDEXVAR(loc);
};
export const INDEXVARQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.INDEXVARQ(loc);
};
export const SETINDEXVARQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SETINDEXVARQ(loc);
};
export const TLEN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TLEN(loc);
};
export const QTLEN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QTLEN(loc);
};
export const ISTUPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ISTUPLE(loc);
};
export const LAST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LAST(loc);
};
export const TPUSH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TPUSH(loc);
};
export const TPOP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.TPOP(loc);
};
export const NULLSWAPIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLSWAPIF(loc);
};
export const NULLSWAPIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLSWAPIFNOT(loc);
};
export const NULLROTRIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLROTRIF(loc);
};
export const NULLROTRIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLROTRIFNOT(loc);
};
export const NULLSWAPIF2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLSWAPIF2(loc);
};
export const NULLSWAPIFNOT2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLSWAPIFNOT2(loc);
};
export const NULLROTRIF2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLROTRIF2(loc);
};
export const NULLROTRIFNOT2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.NULLROTRIFNOT2(loc);
};
export const ADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDDIVMOD(loc);
};
export const ADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDDIVMODR(loc);
};
export const ADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDDIVMODC(loc);
};
export const DIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIV(loc);
};
export const DIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIVR(loc);
};
export const DIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIVC(loc);
};
export const MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MOD(loc);
};
export const MODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MODR(loc);
};
export const MODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MODC(loc);
};
export const DIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIVMOD(loc);
};
export const DIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIVMODR(loc);
};
export const DIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DIVMODC(loc);
};
export const QADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDDIVMOD(loc);
};
export const QADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDDIVMODR(loc);
};
export const QADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDDIVMODC(loc);
};
export const QDIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIV(loc);
};
export const QDIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIVR(loc);
};
export const QDIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIVC(loc);
};
export const QMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMOD(loc);
};
export const QMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMODR(loc);
};
export const QMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMODC(loc);
};
export const QDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIVMOD(loc);
};
export const QDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIVMODR(loc);
};
export const QDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QDIVMODC(loc);
};
export const ADDRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDRSHIFTMOD(loc);
};
export const ADDRSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDRSHIFTMODR(loc);
};
export const ADDRSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.ADDRSHIFTMODC(loc);
};
export const RSHIFTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFTR(loc);
};
export const RSHIFTC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFTC(loc);
};
export const MODPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MODPOW2(loc);
};
export const MODPOW2R: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MODPOW2R(loc);
};
export const MODPOW2C: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MODPOW2C(loc);
};
export const RSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFTMOD(loc);
};
export const RSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFTMODR(loc);
};
export const RSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFTMODC(loc);
};
export const QADDRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDRSHIFTMOD(loc);
};
export const QADDRSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDRSHIFTMODR(loc);
};
export const QADDRSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QADDRSHIFTMODC(loc);
};
export const QRSHIFTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFTR(loc);
};
export const QRSHIFTC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFTC(loc);
};
export const QMODPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMODPOW2(loc);
};
export const QMODPOW2R: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMODPOW2R(loc);
};
export const QMODPOW2C: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMODPOW2C(loc);
};
export const QRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFTMOD(loc);
};
export const QRSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFTMODR(loc);
};
export const QRSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFTMODC(loc);
};
export const MULADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDDIVMOD(loc);
};
export const MULADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDDIVMODR(loc);
};
export const MULADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDDIVMODC(loc);
};
export const MULDIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIV(loc);
};
export const MULDIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIVR(loc);
};
export const MULDIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIVC(loc);
};
export const MULMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMOD(loc);
};
export const MULMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMODR(loc);
};
export const MULMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMODC(loc);
};
export const MULDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIVMOD(loc);
};
export const MULDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIVMODR(loc);
};
export const MULDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULDIVMODC(loc);
};
export const QMULADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDDIVMOD(loc);
};
export const QMULADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDDIVMODR(loc);
};
export const QMULADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDDIVMODC(loc);
};
export const QMULDIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIV(loc);
};
export const QMULDIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIVR(loc);
};
export const QMULDIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIVC(loc);
};
export const QMULMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMOD(loc);
};
export const QMULMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMODR(loc);
};
export const QMULMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMODC(loc);
};
export const QMULDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIVMOD(loc);
};
export const QMULDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIVMODR(loc);
};
export const QMULDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULDIVMODC(loc);
};
export const MULADDRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDRSHIFTMOD(loc);
};
export const MULADDRSHIFTRMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDRSHIFTRMOD(loc);
};
export const MULADDRSHIFTCMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULADDRSHIFTCMOD(loc);
};
export const MULRSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFT(loc);
};
export const MULRSHIFTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFTR(loc);
};
export const MULRSHIFTC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFTC(loc);
};
export const MULMODPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMODPOW2(loc);
};
export const MULMODPOW2R: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMODPOW2R(loc);
};
export const MULMODPOW2C: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULMODPOW2C(loc);
};
export const MULRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFTMOD(loc);
};
export const MULRSHIFTRMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFTRMOD(loc);
};
export const MULRSHIFTCMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.MULRSHIFTCMOD(loc);
};
export const QMULADDRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDRSHIFTMOD(loc);
};
export const QMULADDRSHIFTRMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDRSHIFTRMOD(loc);
};
export const QMULADDRSHIFTCMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULADDRSHIFTCMOD(loc);
};
export const QMULRSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFT(loc);
};
export const QMULRSHIFTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFTR(loc);
};
export const QMULRSHIFTC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFTC(loc);
};
export const QMULMODPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMODPOW2(loc);
};
export const QMULMODPOW2R: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMODPOW2R(loc);
};
export const QMULMODPOW2C: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULMODPOW2C(loc);
};
export const QMULRSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFTMOD(loc);
};
export const QMULRSHIFTRMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFTRMOD(loc);
};
export const QMULRSHIFTCMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QMULRSHIFTCMOD(loc);
};
export const LSHIFTADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTADDDIVMOD(loc);
};
export const LSHIFTADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTADDDIVMODR(loc);
};
export const LSHIFTADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTADDDIVMODC(loc);
};
export const LSHIFTDIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIV(loc);
};
export const LSHIFTDIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIVR(loc);
};
export const LSHIFTDIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIVC(loc);
};
export const LSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTMOD(loc);
};
export const LSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTMODR(loc);
};
export const LSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTMODC(loc);
};
export const LSHIFTDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIVMOD(loc);
};
export const LSHIFTDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIVMODR(loc);
};
export const LSHIFTDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFTDIVMODC(loc);
};
export const QLSHIFTADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTADDDIVMOD(loc);
};
export const QLSHIFTADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTADDDIVMODR(loc);
};
export const QLSHIFTADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTADDDIVMODC(loc);
};
export const QLSHIFTDIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIV(loc);
};
export const QLSHIFTDIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIVR(loc);
};
export const QLSHIFTDIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIVC(loc);
};
export const QLSHIFTMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTMOD(loc);
};
export const QLSHIFTMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTMODR(loc);
};
export const QLSHIFTMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTMODC(loc);
};
export const QLSHIFTDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIVMOD(loc);
};
export const QLSHIFTDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIVMODR(loc);
};
export const QLSHIFTDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFTDIVMODC(loc);
};
export const STIX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STIX(loc);
};
export const STUX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STUX(loc);
};
export const STIXR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STIXR(loc);
};
export const STUXR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STUXR(loc);
};
export const STIXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STIXQ(loc);
};
export const STUXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STUXQ(loc);
};
export const STIXRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STIXRQ(loc);
};
export const STUXRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STUXRQ(loc);
};
export const STILE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STILE4(loc);
};
export const STULE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STULE4(loc);
};
export const STILE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STILE8(loc);
};
export const STULE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STULE8(loc);
};
export const LDIX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDIX(loc);
};
export const LDUX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDUX(loc);
};
export const PLDIX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDIX(loc);
};
export const PLDUX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDUX(loc);
};
export const LDIXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDIXQ(loc);
};
export const LDUXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDUXQ(loc);
};
export const PLDIXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDIXQ(loc);
};
export const PLDUXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDUXQ(loc);
};
export const LDSLICEX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDSLICEX(loc);
};
export const PLDSLICEX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDSLICEX(loc);
};
export const LDSLICEXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDSLICEXQ(loc);
};
export const PLDSLICEXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDSLICEXQ(loc);
};
export const LDILE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDILE4(loc);
};
export const LDULE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDULE4(loc);
};
export const LDILE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDILE8(loc);
};
export const LDULE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDULE8(loc);
};
export const PLDILE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDILE4(loc);
};
export const PLDULE4: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDULE4(loc);
};
export const PLDILE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDILE8(loc);
};
export const PLDULE8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDULE8(loc);
};
export const LDILE4Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDILE4Q(loc);
};
export const LDULE4Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDULE4Q(loc);
};
export const LDILE8Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDILE8Q(loc);
};
export const LDULE8Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LDULE8Q(loc);
};
export const PLDILE4Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDILE4Q(loc);
};
export const PLDULE4Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDULE4Q(loc);
};
export const PLDILE8Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDILE8Q(loc);
};
export const PLDULE8Q: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.PLDULE8Q(loc);
};
export const DICTIGETJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETJMP(loc);
};
export const DICTUGETJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETJMP(loc);
};
export const DICTIGETEXEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETEXEC(loc);
};
export const DICTUGETEXEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETEXEC(loc);
};
export const DICTIGETJMPZ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETJMPZ(loc);
};
export const DICTUGETJMPZ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETJMPZ(loc);
};
export const DICTIGETEXECZ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETEXECZ(loc);
};
export const DICTUGETEXECZ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETEXECZ(loc);
};
export const DICTGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGET(loc);
};
export const DICTGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETREF(loc);
};
export const DICTIGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGET(loc);
};
export const DICTIGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETREF(loc);
};
export const DICTUGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGET(loc);
};
export const DICTUGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETREF(loc);
};
export const DICTSET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSET(loc);
};
export const DICTSETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETREF(loc);
};
export const DICTISET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISET(loc);
};
export const DICTISETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETREF(loc);
};
export const DICTUSET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSET(loc);
};
export const DICTUSETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETREF(loc);
};
export const DICTSETGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETGET(loc);
};
export const DICTSETGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETGETREF(loc);
};
export const DICTISETGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETGET(loc);
};
export const DICTISETGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETGETREF(loc);
};
export const DICTUSETGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETGET(loc);
};
export const DICTUSETGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETGETREF(loc);
};
export const DICTREPLACE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACE(loc);
};
export const DICTREPLACEREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACEREF(loc);
};
export const DICTIREPLACE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACE(loc);
};
export const DICTIREPLACEREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACEREF(loc);
};
export const DICTUREPLACE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACE(loc);
};
export const DICTUREPLACEREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACEREF(loc);
};
export const DICTREPLACEGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACEGET(loc);
};
export const DICTREPLACEGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACEGETREF(loc);
};
export const DICTIREPLACEGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACEGET(loc);
};
export const DICTIREPLACEGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACEGETREF(loc);
};
export const DICTUREPLACEGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACEGET(loc);
};
export const DICTUREPLACEGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACEGETREF(loc);
};
export const DICTADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADD(loc);
};
export const DICTADDREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADDREF(loc);
};
export const DICTIADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADD(loc);
};
export const DICTIADDREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADDREF(loc);
};
export const DICTUADD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADD(loc);
};
export const DICTUADDREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADDREF(loc);
};
export const DICTADDGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADDGET(loc);
};
export const DICTADDGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADDGETREF(loc);
};
export const DICTIADDGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADDGET(loc);
};
export const DICTIADDGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADDGETREF(loc);
};
export const DICTUADDGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADDGET(loc);
};
export const DICTUADDGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADDGETREF(loc);
};
export const DICTDELGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTDELGET(loc);
};
export const DICTDELGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTDELGETREF(loc);
};
export const DICTIDELGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIDELGET(loc);
};
export const DICTIDELGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIDELGETREF(loc);
};
export const DICTUDELGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUDELGET(loc);
};
export const DICTUDELGETREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUDELGETREF(loc);
};
export const DICTMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTMIN(loc);
};
export const DICTMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTMINREF(loc);
};
export const DICTIMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIMIN(loc);
};
export const DICTIMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIMINREF(loc);
};
export const DICTUMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUMIN(loc);
};
export const DICTUMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUMINREF(loc);
};
export const DICTMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTMAX(loc);
};
export const DICTMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTMAXREF(loc);
};
export const DICTIMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIMAX(loc);
};
export const DICTIMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIMAXREF(loc);
};
export const DICTUMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUMAX(loc);
};
export const DICTUMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUMAXREF(loc);
};
export const DICTREMMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREMMIN(loc);
};
export const DICTREMMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREMMINREF(loc);
};
export const DICTIREMMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREMMIN(loc);
};
export const DICTIREMMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREMMINREF(loc);
};
export const DICTUREMMIN: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREMMIN(loc);
};
export const DICTUREMMINREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREMMINREF(loc);
};
export const DICTREMMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREMMAX(loc);
};
export const DICTREMMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREMMAXREF(loc);
};
export const DICTIREMMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREMMAX(loc);
};
export const DICTIREMMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREMMAXREF(loc);
};
export const DICTUREMMAX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREMMAX(loc);
};
export const DICTUREMMAXREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREMMAXREF(loc);
};
export const DICTSETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETB(loc);
};
export const DICTISETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETB(loc);
};
export const DICTUSETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETB(loc);
};
export const DICTSETGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETGETB(loc);
};
export const DICTISETGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETGETB(loc);
};
export const DICTUSETGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETGETB(loc);
};
export const DICTREPLACEB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACEB(loc);
};
export const DICTIREPLACEB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACEB(loc);
};
export const DICTUREPLACEB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACEB(loc);
};
export const DICTREPLACEGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTREPLACEGETB(loc);
};
export const DICTIREPLACEGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIREPLACEGETB(loc);
};
export const DICTUREPLACEGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUREPLACEGETB(loc);
};
export const DICTADDB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADDB(loc);
};
export const DICTIADDB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADDB(loc);
};
export const DICTUADDB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADDB(loc);
};
export const DICTADDGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTADDGETB(loc);
};
export const DICTIADDGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIADDGETB(loc);
};
export const DICTUADDGETB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUADDGETB(loc);
};
export const DICTDEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTDEL(loc);
};
export const DICTIDEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIDEL(loc);
};
export const DICTUDEL: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUDEL(loc);
};
export const DICTGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETOPTREF(loc);
};
export const DICTIGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETOPTREF(loc);
};
export const DICTUGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETOPTREF(loc);
};
export const DICTSETGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTSETGETOPTREF(loc);
};
export const DICTISETGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTISETGETOPTREF(loc);
};
export const DICTUSETGETOPTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUSETGETOPTREF(loc);
};
export const SUBDICTGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTGET(loc);
};
export const SUBDICTIGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTIGET(loc);
};
export const SUBDICTUGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTUGET(loc);
};
export const SUBDICTRPGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTRPGET(loc);
};
export const SUBDICTIRPGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTIRPGET(loc);
};
export const SUBDICTURPGET: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SUBDICTURPGET(loc);
};
export const THROWANY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWANY(loc);
};
export const THROWARGANY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWARGANY(loc);
};
export const THROWANYIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWANYIFNOT(loc);
};
export const THROWARGANYIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWARGANYIFNOT(loc);
};
export const DICTGETNEXT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETNEXT(loc);
};
export const DICTGETNEXTEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETNEXTEQ(loc);
};
export const DICTGETPREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETPREV(loc);
};
export const DICTGETPREVEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTGETPREVEQ(loc);
};
export const DICTIGETNEXT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETNEXT(loc);
};
export const DICTIGETNEXTEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETNEXTEQ(loc);
};
export const DICTIGETPREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETPREV(loc);
};
export const DICTIGETPREVEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTIGETPREVEQ(loc);
};
export const DICTUGETNEXT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETNEXT(loc);
};
export const DICTUGETNEXTEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETNEXTEQ(loc);
};
export const DICTUGETPREV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETPREV(loc);
};
export const DICTUGETPREVEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DICTUGETPREVEQ(loc);
};
export const ADDINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.ADDINT(args, loc);
};
export const MULINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULINT(args, loc);
};
export const QADDINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QADDINT(args, loc);
};
export const QMULINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QMULINT(args, loc);
};
export const EQINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.EQINT(args, loc);
};
export const LESSINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LESSINT(args, loc);
};
export const GTINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.GTINT(args, loc);
};
export const NEQINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.NEQINT(args, loc);
};
export const QEQINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QEQINT(args, loc);
};
export const QLESSINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QLESSINT(args, loc);
};
export const QGTINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QGTINT(args, loc);
};
export const QNEQINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QNEQINT(args, loc);
};
export const PUSHPOW2DEC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHPOW2DEC(args, loc);
};
export const PUSHNEGPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHNEGPOW2(args, loc);
};
export const FITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.FITS(args, loc);
};
export const UFITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.UFITS(args, loc);
};
export const QFITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QFITS(args, loc);
};
export const QUFITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QUFITS(args, loc);
};
export const SETCONTCTRMANY: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETCONTCTRMANY(args, loc);
};
export const CALLCCARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.CALLCCARGS(args[0], args[1], loc);
};
export const TRYARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.TRYARGS(args[0], args[1], loc);
};
export const PLDREFIDX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDREFIDX(args, loc);
};
export const CHASHI: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.CHASHI(args, loc);
};
export const CDEPTHI: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.CDEPTHI(args, loc);
};
export const JMPDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.JMPDICT(args, loc);
};
export const PREPAREDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PREPAREDICT(args, loc);
};
export const THROWARG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWARG(args, loc);
};
export const THROWARGIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWARGIF(args, loc);
};
export const THROWARGIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWARGIFNOT(args, loc);
};
export const JMPXARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.JMPXARGS(args, loc);
};
export const RETARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RETARGS(args, loc);
};
export const RETURNARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RETURNARGS(args, loc);
};
export const BLKDROP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.BLKDROP(args, loc);
};
export const TUPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.TUPLE(args, loc);
};
export const INDEX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.INDEX(args, loc);
};
export const UNTUPLE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.UNTUPLE(args, loc);
};
export const UNPACKFIRST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.UNPACKFIRST(args, loc);
};
export const EXPLODE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.EXPLODE(args, loc);
};
export const SETINDEX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETINDEX(args, loc);
};
export const INDEXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.INDEXQ(args, loc);
};
export const SETINDEXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETINDEXQ(args, loc);
};
export const XC2PU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.XC2PU(args[0], args[1], args[2], loc);
};
export const XCPU2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.XCPU2(args[0], args[1], args[2], loc);
};
export const PUSH3: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.PUSH3(args[0], args[1], args[2], loc);
};
export const XCHG2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.XCHG2(args[0], args[1], loc);
};
export const XCPU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.XCPU(args[0], args[1], loc);
};
export const PUSH2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.PUSH2(args[0], args[1], loc);
};
export const PUXC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.PUXC(args[0], args[1], loc);
};
export const XCPUXC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.XCPUXC(args[0], args[1], args[2], loc);
};
export const PUXC2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.PUXC2(args[0], args[1], args[2], loc);
};
export const PUXCPU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.PUXCPU(args[0], args[1], args[2], loc);
};
export const PU2XC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.PU2XC(args[0], args[1], args[2], loc);
};
export const BLKSWAP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.BLKSWAP(args[0], args[1], loc);
};
export const REVERSE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.REVERSE(args[0], args[1], loc);
};
export const SETCONTARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.SETCONTARGS(args[0], args[1], loc);
};
export const BLESSARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.BLESSARGS(args[0], args[1], loc);
};
export const STIR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STIR(args, loc);
};
export const STUR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STUR(args, loc);
};
export const STIQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STIQ(args, loc);
};
export const STUQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STUQ(args, loc);
};
export const STIRQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STIRQ(args, loc);
};
export const STURQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STURQ(args, loc);
};
export const PLDI: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDI(args, loc);
};
export const PLDU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDU(args, loc);
};
export const LDIQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDIQ(args, loc);
};
export const LDUQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDUQ(args, loc);
};
export const PLDIQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDIQ(args, loc);
};
export const PLDUQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDUQ(args, loc);
};
export const PLDUZ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDUZ(args, loc);
};
export const PLDSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDSLICE(args, loc);
};
export const LDSLICEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDSLICEQ(args, loc);
};
export const PLDSLICEQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PLDSLICEQ(args, loc);
};
export const IFBITJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.IFBITJMP(args, loc);
};
export const IFNBITJMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.IFNBITJMP(args, loc);
};
export const INDEX2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.INDEX2(args[0], args[1], loc);
};
export const INDEX3: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeIntegerArgs(instr);
    return c.INDEX3(args[0], args[1], args[2], loc);
};
export const PUSHPOW2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHPOW2(args, loc);
};
export const BLKPUSH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.BLKPUSH(args[0], args[1], loc);
};
export const BLKDROP2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.BLKDROP2(args[0], args[1], loc);
};
export const GETGLOB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.GETGLOB(args, loc);
};
export const SETGLOB: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETGLOB(args, loc);
};
export const GETPARAM: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.GETPARAM(args, loc);
};
export const PUSHREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.PUSHREF(args, loc);
};
export const PUSHREFSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.PUSHREFSLICE(args, loc);
};
export const PUSHREFCONT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.PUSHREFCONT(args, loc);
};
export const CALLREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.CALLREF(args, loc);
};
export const JMPREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.JMPREF(args, loc);
};
export const JMPREFDATA: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.JMPREFDATA(args, loc);
};
export const IFREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFREF(args, loc);
};
export const IFNOTREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFNOTREF(args, loc);
};
export const IFJMPREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFJMPREF(args, loc);
};
export const IFNOTJMPREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFNOTJMPREF(args, loc);
};
export const IFREFELSE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFREFELSE(args, loc);
};
export const IFELSEREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.IFELSEREF(args, loc);
};
export const IFREFELSEREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoCodeSliceArgs(ctx, instr);
    return c.IFREFELSEREF(args[0], args[1], loc);
};
export const IFBITJMPREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.ifBitArgs(ctx, instr);
    return c.IFBITJMPREF(args[0], args[1], loc);
};
export const IFNBITJMPREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.ifBitArgs(ctx, instr);
    return c.IFNBITJMPREF(args[0], args[1], loc);
};
export const DICTPUSHCONST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.dictpushArg(ctx, instr);
    return c.DICTPUSHCONST(args[0], args[1], loc);
};
export const PFXDICTSWITCH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.dictpushArg(ctx, instr);
    return c.PFXDICTSWITCH(args[0], args[1], loc);
};
export const SDBEGINSX: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDBEGINSX(loc);
};
export const SDBEGINSXQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SDBEGINSXQ(loc);
};
export const SDBEGINS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.SDBEGINS(args, loc);
};
export const SDBEGINSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.SDBEGINSQ(args, loc);
};
export const STREFCONST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.STREFCONST(args, loc);
};
export const STREF2CONST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoCodeSliceArgs(ctx, instr);
    return c.STREF2CONST(args[0], args[1], loc);
};
export const THROWANYIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWANYIF(loc);
};
export const THROWARGANYIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.THROWARGANYIF(loc);
};
export const DEBUGSTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.debugstrArg(instr);
    return c.DEBUGSTR(args, loc);
};
export const SETCONTCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SETCONTCTR(args, loc);
};
export const SETRETCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SETRETCTR(args, loc);
};
export const SETALTCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SETALTCTR(args, loc);
};
export const POPSAVE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.POPSAVE(args, loc);
};
export const SAVECTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SAVECTR(args, loc);
};
export const SAVEALTCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SAVEALTCTR(args, loc);
};
export const SAVEBOTHCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.SAVEBOTHCTR(args, loc);
};
export const RUNVM: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RUNVM(args, loc);
};
export const SWAP2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.SWAP2(loc);
};
export const DROP2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DROP2(loc);
};
export const DUP2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DUP2(loc);
};
export const OVER2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.OVER2(loc);
};
export const ADDRSHIFT_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.ADDRSHIFT_MOD(args, loc);
};
export const ADDRSHIFTR_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.ADDRSHIFTR_MOD(args, loc);
};
export const ADDRSHIFTC_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.ADDRSHIFTC_MOD(args, loc);
};
export const RSHIFT_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFT_(args, loc);
};
export const RSHIFTR_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFTR_(args, loc);
};
export const RSHIFTC_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFTC_(args, loc);
};
export const MODPOW2_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MODPOW2_(args, loc);
};
export const MODPOW2R_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MODPOW2R_(args, loc);
};
export const MODPOW2C_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MODPOW2C_(args, loc);
};
export const RSHIFT_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFT_MOD(args, loc);
};
export const RSHIFTR_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFTR_MOD(args, loc);
};
export const RSHIFTC_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFTC_MOD(args, loc);
};
export const MULADDRSHIFT_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULADDRSHIFT_MOD(args, loc);
};
export const MULADDRSHIFTR_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULADDRSHIFTR_MOD(args, loc);
};
export const MULADDRSHIFTC_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULADDRSHIFTC_MOD(args, loc);
};
export const MULRSHIFT_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFT_(args, loc);
};
export const MULRSHIFTR_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFTR_(args, loc);
};
export const MULRSHIFTC_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFTC_(args, loc);
};
export const MULMODPOW2_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULMODPOW2_(args, loc);
};
export const MULMODPOW2R_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULMODPOW2R_(args, loc);
};
export const MULMODPOW2C_: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULMODPOW2C_(args, loc);
};
export const MULRSHIFT_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFT_MOD(args, loc);
};
export const MULRSHIFTR_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFTR_MOD(args, loc);
};
export const MULRSHIFTC_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.MULRSHIFTC_MOD(args, loc);
};
export const LSHIFT_ADDDIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_ADDDIVMOD(args, loc);
};
export const LSHIFT_ADDDIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_ADDDIVMODR(args, loc);
};
export const LSHIFT_ADDDIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_ADDDIVMODC(args, loc);
};
export const LSHIFT_DIV: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIV(args, loc);
};
export const LSHIFT_DIVR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIVR(args, loc);
};
export const LSHIFT_DIVC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIVC(args, loc);
};
export const LSHIFT_MOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_MOD(args, loc);
};
export const LSHIFT_MODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_MODR(args, loc);
};
export const LSHIFT_MODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_MODC(args, loc);
};
export const LSHIFT_DIVMOD: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIVMOD(args, loc);
};
export const LSHIFT_DIVMODR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIVMODR(args, loc);
};
export const LSHIFT_DIVMODC: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_DIVMODC(args, loc);
};
export const HASHEXT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.HASHEXT(args, loc);
};
export const HASHEXTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.HASHEXTR(args, loc);
};
export const HASHEXTA: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.HASHEXTA(args, loc);
};
export const HASHEXTAR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.HASHEXTAR(args, loc);
};
export const STREF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STREF(loc);
};
export const STREF_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STREF_ALT(loc);
};
export const STSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSLICE(loc);
};
export const STSLICE_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STSLICE_ALT(loc);
};
export const XCHG3: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.XCHG3(args[0], args[1], args[2], loc);
};
export const XCHG3_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 3) {
        throw new $.ParseError(loc, "Expected 3 arguments");
    }
    const args = $.threeStackArgs(instr);
    return c.XCHG3_ALT(args[0], args[1], args[2], loc);
};
export const STI: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STI(args, loc);
};
export const STI_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STI_ALT(args, loc);
};
export const STU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STU(args, loc);
};
export const STU_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.STU_ALT(args, loc);
};
export const LDI: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDI(args, loc);
};
export const LDI_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDI_ALT(args, loc);
};
export const LDU: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDU(args, loc);
};
export const LDU_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDU_ALT(args, loc);
};
export const LDSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDSLICE(args, loc);
};
export const LDSLICE_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LDSLICE_ALT(args, loc);
};
export const LSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.LSHIFT(loc);
};
export const LSHIFT_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.LSHIFT_1(args, loc);
};
export const QLSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QLSHIFT(loc);
};
export const QLSHIFT_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QLSHIFT_1(args, loc);
};
export const BCHKBITS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKBITS(loc);
};
export const BCHKBITS_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.BCHKBITS_1(args, loc);
};
export const BCHKBITSQ: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.BCHKBITSQ(loc);
};
export const BCHKBITSQ_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.BCHKBITSQ_1(args, loc);
};
export const RSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFT(loc);
};
export const RSHIFT_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.RSHIFT_1(args, loc);
};
export const RSHIFT_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.RSHIFT_ALT(loc);
};
export const QRSHIFT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFT(loc);
};
export const QRSHIFT_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.QRSHIFT_1(args, loc);
};
export const QRSHIFT_ALT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.QRSHIFT_ALT(loc);
};
export const CALLDICT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.CALLDICT(args, loc);
};
export const CALLDICT_LONG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.CALLDICT_LONG(args, loc);
};
export const THROW_SHORT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROW_SHORT(args, loc);
};
export const THROW: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROW(args, loc);
};
export const THROWIF_SHORT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWIF_SHORT(args, loc);
};
export const THROWIF: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWIF(args, loc);
};
export const THROWIFNOT_SHORT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWIFNOT_SHORT(args, loc);
};
export const THROWIFNOT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.THROWIFNOT(args, loc);
};
export const PUSHINT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHINT(args, loc);
};
export const PUSHINT_8: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHINT_8(args, loc);
};
export const PUSHINT_16: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.PUSHINT_16(args, loc);
};
export const PUSHINT_LONG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleBigIntArg(instr);
    return c.PUSHINT_LONG(args, loc);
};
export const XCHG_LONG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.XCHG_LONG(args, loc);
};
export const XCHG_0: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.XCHG_0(args, loc);
};
export const XCHG_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.XCHG_1(args[0], args[1], loc);
};
export const XCHG_3: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoStackArgs(instr);
    return c.XCHG_3(args[0], args[1], loc);
};
export const DUMPSTK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.DUMPSTK(loc);
};
export const DEBUG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.DEBUG(args, loc);
};
export const STRDUMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 0) {
        throw new $.ParseError(loc, "Expected 0 arguments");
    }
    return c.STRDUMP(loc);
};
export const DEBUG_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.DEBUG_1(args, loc);
};
export const DUMP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.DUMP(args, loc);
};
export const DEBUG_2: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.DEBUG_2(args, loc);
};
export const PUSHCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.PUSHCTR(args, loc);
};
export const PUSH: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.PUSH(args, loc);
};
export const PUSH_LONG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.PUSH_LONG(args, loc);
};
export const POPCTR: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleControlArg(instr);
    return c.POPCTR(args, loc);
};
export const POP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.POP(args, loc);
};
export const POP_LONG: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleStackArg(instr);
    return c.POP_LONG(args, loc);
};
export const CALLXARGS: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.CALLXARGS(args[0], args[1], loc);
};
export const CALLXARGS_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 2) {
        throw new $.ParseError(loc, "Expected 2 arguments");
    }
    const args = $.twoIntegerArgs(instr);
    return c.CALLXARGS_1(args[0], args[1], loc);
};
export const PUSHSLICE: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.PUSHSLICE(args, loc);
};
export const PUSHSLICE_REFS_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.PUSHSLICE_REFS_1(args, loc);
};
export const PUSHSLICE_LONG_1: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.PUSHSLICE_LONG_1(args, loc);
};
export const PUSHCONT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.PUSHCONT(args, loc);
};
export const PUSHCONT_SHORT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.codeSliceArg(ctx, instr);
    return c.PUSHCONT_SHORT(args, loc);
};
export const STSLICECONST: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.sliceArg(instr);
    return c.STSLICECONST(args, loc);
};
export const SETCP: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETCP(args, loc);
};
export const SETCP_SHORT: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.SETCP_SHORT(args, loc);
};
export const DEBUGMARK: $.Convert = (ctx, instr, loc) => {
    const argsLen = instr.args;
    if (argsLen.length !== 1) {
        throw new $.ParseError(loc, "Expected 1 argument");
    }
    const args = $.singleIntegerArg(instr);
    return c.DEBUGMARK(args, loc);
};
export const convertInstruction = (
    ctx: $.Ctx,
    instr: $ast.Instruction,
    loc: c.util.Loc,
) => {
    const name = instr.name.name;
    switch (name) {
        case "PUSHNAN":
            return PUSHNAN(ctx, instr, loc);
        case "ADD":
            return ADD(ctx, instr, loc);
        case "SUB":
            return SUB(ctx, instr, loc);
        case "SUBR":
            return SUBR(ctx, instr, loc);
        case "NEGATE":
            return NEGATE(ctx, instr, loc);
        case "INC":
            return INC(ctx, instr, loc);
        case "DEC":
            return DEC(ctx, instr, loc);
        case "MUL":
            return MUL(ctx, instr, loc);
        case "POW2":
            return POW2(ctx, instr, loc);
        case "AND":
            return AND(ctx, instr, loc);
        case "OR":
            return OR(ctx, instr, loc);
        case "XOR":
            return XOR(ctx, instr, loc);
        case "NOT":
            return NOT(ctx, instr, loc);
        case "FITSX":
            return FITSX(ctx, instr, loc);
        case "UFITSX":
            return UFITSX(ctx, instr, loc);
        case "BITSIZE":
            return BITSIZE(ctx, instr, loc);
        case "UBITSIZE":
            return UBITSIZE(ctx, instr, loc);
        case "MIN":
            return MIN(ctx, instr, loc);
        case "MAX":
            return MAX(ctx, instr, loc);
        case "MINMAX":
            return MINMAX(ctx, instr, loc);
        case "ABS":
            return ABS(ctx, instr, loc);
        case "QADD":
            return QADD(ctx, instr, loc);
        case "QSUB":
            return QSUB(ctx, instr, loc);
        case "QSUBR":
            return QSUBR(ctx, instr, loc);
        case "QNEGATE":
            return QNEGATE(ctx, instr, loc);
        case "QINC":
            return QINC(ctx, instr, loc);
        case "QDEC":
            return QDEC(ctx, instr, loc);
        case "QMUL":
            return QMUL(ctx, instr, loc);
        case "QPOW2":
            return QPOW2(ctx, instr, loc);
        case "QAND":
            return QAND(ctx, instr, loc);
        case "QOR":
            return QOR(ctx, instr, loc);
        case "QXOR":
            return QXOR(ctx, instr, loc);
        case "QNOT":
            return QNOT(ctx, instr, loc);
        case "QFITSX":
            return QFITSX(ctx, instr, loc);
        case "QUFITSX":
            return QUFITSX(ctx, instr, loc);
        case "QBITSIZE":
            return QBITSIZE(ctx, instr, loc);
        case "QUBITSIZE":
            return QUBITSIZE(ctx, instr, loc);
        case "QMIN":
            return QMIN(ctx, instr, loc);
        case "QMAX":
            return QMAX(ctx, instr, loc);
        case "QMINMAX":
            return QMINMAX(ctx, instr, loc);
        case "QABS":
            return QABS(ctx, instr, loc);
        case "SGN":
            return SGN(ctx, instr, loc);
        case "LESS":
            return LESS(ctx, instr, loc);
        case "EQUAL":
            return EQUAL(ctx, instr, loc);
        case "LEQ":
            return LEQ(ctx, instr, loc);
        case "GREATER":
            return GREATER(ctx, instr, loc);
        case "NEQ":
            return NEQ(ctx, instr, loc);
        case "GEQ":
            return GEQ(ctx, instr, loc);
        case "CMP":
            return CMP(ctx, instr, loc);
        case "ISNAN":
            return ISNAN(ctx, instr, loc);
        case "CHKNAN":
            return CHKNAN(ctx, instr, loc);
        case "QSGN":
            return QSGN(ctx, instr, loc);
        case "QLESS":
            return QLESS(ctx, instr, loc);
        case "QEQUAL":
            return QEQUAL(ctx, instr, loc);
        case "QLEQ":
            return QLEQ(ctx, instr, loc);
        case "QGREATER":
            return QGREATER(ctx, instr, loc);
        case "QNEQ":
            return QNEQ(ctx, instr, loc);
        case "QGEQ":
            return QGEQ(ctx, instr, loc);
        case "QCMP":
            return QCMP(ctx, instr, loc);
        case "SEMPTY":
            return SEMPTY(ctx, instr, loc);
        case "SDEMPTY":
            return SDEMPTY(ctx, instr, loc);
        case "SREMPTY":
            return SREMPTY(ctx, instr, loc);
        case "SDFIRST":
            return SDFIRST(ctx, instr, loc);
        case "SDLEXCMP":
            return SDLEXCMP(ctx, instr, loc);
        case "SDEQ":
            return SDEQ(ctx, instr, loc);
        case "SDPFX":
            return SDPFX(ctx, instr, loc);
        case "SDPFXREV":
            return SDPFXREV(ctx, instr, loc);
        case "SDPPFX":
            return SDPPFX(ctx, instr, loc);
        case "SDPPFXREV":
            return SDPPFXREV(ctx, instr, loc);
        case "SDSFX":
            return SDSFX(ctx, instr, loc);
        case "SDSFXREV":
            return SDSFXREV(ctx, instr, loc);
        case "SDPSFX":
            return SDPSFX(ctx, instr, loc);
        case "SDPSFXREV":
            return SDPSFXREV(ctx, instr, loc);
        case "SDCNTLEAD0":
            return SDCNTLEAD0(ctx, instr, loc);
        case "SDCNTLEAD1":
            return SDCNTLEAD1(ctx, instr, loc);
        case "SDCNTTRAIL0":
            return SDCNTTRAIL0(ctx, instr, loc);
        case "SDCNTTRAIL1":
            return SDCNTTRAIL1(ctx, instr, loc);
        case "NEWC":
            return NEWC(ctx, instr, loc);
        case "ENDC":
            return ENDC(ctx, instr, loc);
        case "ENDCST":
            return ENDCST(ctx, instr, loc);
        case "STBREF":
            return STBREF(ctx, instr, loc);
        case "STB":
            return STB(ctx, instr, loc);
        case "STREFR":
            return STREFR(ctx, instr, loc);
        case "STBREFR":
            return STBREFR(ctx, instr, loc);
        case "STSLICER":
            return STSLICER(ctx, instr, loc);
        case "STBR":
            return STBR(ctx, instr, loc);
        case "STREFQ":
            return STREFQ(ctx, instr, loc);
        case "STBREFQ":
            return STBREFQ(ctx, instr, loc);
        case "STSLICEQ":
            return STSLICEQ(ctx, instr, loc);
        case "STBQ":
            return STBQ(ctx, instr, loc);
        case "STREFRQ":
            return STREFRQ(ctx, instr, loc);
        case "STBREFRQ":
            return STBREFRQ(ctx, instr, loc);
        case "STSLICERQ":
            return STSLICERQ(ctx, instr, loc);
        case "STBRQ":
            return STBRQ(ctx, instr, loc);
        case "ENDXC":
            return ENDXC(ctx, instr, loc);
        case "BDEPTH":
            return BDEPTH(ctx, instr, loc);
        case "BBITS":
            return BBITS(ctx, instr, loc);
        case "BREFS":
            return BREFS(ctx, instr, loc);
        case "BBITREFS":
            return BBITREFS(ctx, instr, loc);
        case "BREMBITS":
            return BREMBITS(ctx, instr, loc);
        case "BREMREFS":
            return BREMREFS(ctx, instr, loc);
        case "BREMBITREFS":
            return BREMBITREFS(ctx, instr, loc);
        case "BCHKREFS":
            return BCHKREFS(ctx, instr, loc);
        case "BCHKBITREFS":
            return BCHKBITREFS(ctx, instr, loc);
        case "BCHKREFSQ":
            return BCHKREFSQ(ctx, instr, loc);
        case "BCHKBITREFSQ":
            return BCHKBITREFSQ(ctx, instr, loc);
        case "STZEROES":
            return STZEROES(ctx, instr, loc);
        case "STONES":
            return STONES(ctx, instr, loc);
        case "STSAME":
            return STSAME(ctx, instr, loc);
        case "CTOS":
            return CTOS(ctx, instr, loc);
        case "ENDS":
            return ENDS(ctx, instr, loc);
        case "LDREF":
            return LDREF(ctx, instr, loc);
        case "LDREFRTOS":
            return LDREFRTOS(ctx, instr, loc);
        case "SDCUTFIRST":
            return SDCUTFIRST(ctx, instr, loc);
        case "SDSKIPFIRST":
            return SDSKIPFIRST(ctx, instr, loc);
        case "SDCUTLAST":
            return SDCUTLAST(ctx, instr, loc);
        case "SDSKIPLAST":
            return SDSKIPLAST(ctx, instr, loc);
        case "SDSUBSTR":
            return SDSUBSTR(ctx, instr, loc);
        case "SCUTFIRST":
            return SCUTFIRST(ctx, instr, loc);
        case "SSKIPFIRST":
            return SSKIPFIRST(ctx, instr, loc);
        case "SCUTLAST":
            return SCUTLAST(ctx, instr, loc);
        case "SSKIPLAST":
            return SSKIPLAST(ctx, instr, loc);
        case "SUBSLICE":
            return SUBSLICE(ctx, instr, loc);
        case "SPLIT":
            return SPLIT(ctx, instr, loc);
        case "SPLITQ":
            return SPLITQ(ctx, instr, loc);
        case "XCTOS":
            return XCTOS(ctx, instr, loc);
        case "XLOAD":
            return XLOAD(ctx, instr, loc);
        case "XLOADQ":
            return XLOADQ(ctx, instr, loc);
        case "SCHKBITS":
            return SCHKBITS(ctx, instr, loc);
        case "SCHKREFS":
            return SCHKREFS(ctx, instr, loc);
        case "SCHKBITREFS":
            return SCHKBITREFS(ctx, instr, loc);
        case "SCHKBITSQ":
            return SCHKBITSQ(ctx, instr, loc);
        case "SCHKREFSQ":
            return SCHKREFSQ(ctx, instr, loc);
        case "SCHKBITREFSQ":
            return SCHKBITREFSQ(ctx, instr, loc);
        case "PLDREFVAR":
            return PLDREFVAR(ctx, instr, loc);
        case "SBITS":
            return SBITS(ctx, instr, loc);
        case "SREFS":
            return SREFS(ctx, instr, loc);
        case "SBITREFS":
            return SBITREFS(ctx, instr, loc);
        case "LDZEROES":
            return LDZEROES(ctx, instr, loc);
        case "LDONES":
            return LDONES(ctx, instr, loc);
        case "LDSAME":
            return LDSAME(ctx, instr, loc);
        case "SDEPTH":
            return SDEPTH(ctx, instr, loc);
        case "CDEPTH":
            return CDEPTH(ctx, instr, loc);
        case "CLEVEL":
            return CLEVEL(ctx, instr, loc);
        case "CLEVELMASK":
            return CLEVELMASK(ctx, instr, loc);
        case "CHASHIX":
            return CHASHIX(ctx, instr, loc);
        case "CDEPTHIX":
            return CDEPTHIX(ctx, instr, loc);
        case "EXECUTE":
            return EXECUTE(ctx, instr, loc);
        case "JMPX":
            return JMPX(ctx, instr, loc);
        case "RET":
            return RET(ctx, instr, loc);
        case "RETALT":
            return RETALT(ctx, instr, loc);
        case "RETBOOL":
            return RETBOOL(ctx, instr, loc);
        case "CALLCC":
            return CALLCC(ctx, instr, loc);
        case "JMPXDATA":
            return JMPXDATA(ctx, instr, loc);
        case "CALLXVARARGS":
            return CALLXVARARGS(ctx, instr, loc);
        case "RETVARARGS":
            return RETVARARGS(ctx, instr, loc);
        case "JMPXVARARGS":
            return JMPXVARARGS(ctx, instr, loc);
        case "CALLCCVARARGS":
            return CALLCCVARARGS(ctx, instr, loc);
        case "RETDATA":
            return RETDATA(ctx, instr, loc);
        case "RUNVMX":
            return RUNVMX(ctx, instr, loc);
        case "IFRET":
            return IFRET(ctx, instr, loc);
        case "IFNOTRET":
            return IFNOTRET(ctx, instr, loc);
        case "IF":
            return IF(ctx, instr, loc);
        case "IFNOT":
            return IFNOT(ctx, instr, loc);
        case "IFJMP":
            return IFJMP(ctx, instr, loc);
        case "IFNOTJMP":
            return IFNOTJMP(ctx, instr, loc);
        case "IFELSE":
            return IFELSE(ctx, instr, loc);
        case "CONDSEL":
            return CONDSEL(ctx, instr, loc);
        case "CONDSELCHK":
            return CONDSELCHK(ctx, instr, loc);
        case "IFRETALT":
            return IFRETALT(ctx, instr, loc);
        case "IFNOTRETALT":
            return IFNOTRETALT(ctx, instr, loc);
        case "REPEAT":
            return REPEAT(ctx, instr, loc);
        case "REPEATEND":
            return REPEATEND(ctx, instr, loc);
        case "UNTIL":
            return UNTIL(ctx, instr, loc);
        case "UNTILEND":
            return UNTILEND(ctx, instr, loc);
        case "WHILE":
            return WHILE(ctx, instr, loc);
        case "WHILEEND":
            return WHILEEND(ctx, instr, loc);
        case "AGAIN":
            return AGAIN(ctx, instr, loc);
        case "AGAINEND":
            return AGAINEND(ctx, instr, loc);
        case "REPEATBRK":
            return REPEATBRK(ctx, instr, loc);
        case "REPEATENDBRK":
            return REPEATENDBRK(ctx, instr, loc);
        case "UNTILBRK":
            return UNTILBRK(ctx, instr, loc);
        case "UNTILENDBRK":
            return UNTILENDBRK(ctx, instr, loc);
        case "WHILEBRK":
            return WHILEBRK(ctx, instr, loc);
        case "WHILEENDBRK":
            return WHILEENDBRK(ctx, instr, loc);
        case "AGAINBRK":
            return AGAINBRK(ctx, instr, loc);
        case "AGAINENDBRK":
            return AGAINENDBRK(ctx, instr, loc);
        case "RETURNVARARGS":
            return RETURNVARARGS(ctx, instr, loc);
        case "SETCONTVARARGS":
            return SETCONTVARARGS(ctx, instr, loc);
        case "SETNUMVARARGS":
            return SETNUMVARARGS(ctx, instr, loc);
        case "BLESS":
            return BLESS(ctx, instr, loc);
        case "BLESSVARARGS":
            return BLESSVARARGS(ctx, instr, loc);
        case "PUSHCTRX":
            return PUSHCTRX(ctx, instr, loc);
        case "POPCTRX":
            return POPCTRX(ctx, instr, loc);
        case "SETCONTCTRX":
            return SETCONTCTRX(ctx, instr, loc);
        case "SETCONTCTRMANYX":
            return SETCONTCTRMANYX(ctx, instr, loc);
        case "BOOLAND":
            return BOOLAND(ctx, instr, loc);
        case "BOOLOR":
            return BOOLOR(ctx, instr, loc);
        case "COMPOSBOTH":
            return COMPOSBOTH(ctx, instr, loc);
        case "ATEXIT":
            return ATEXIT(ctx, instr, loc);
        case "ATEXITALT":
            return ATEXITALT(ctx, instr, loc);
        case "SETEXITALT":
            return SETEXITALT(ctx, instr, loc);
        case "THENRET":
            return THENRET(ctx, instr, loc);
        case "THENRETALT":
            return THENRETALT(ctx, instr, loc);
        case "INVERT":
            return INVERT(ctx, instr, loc);
        case "BOOLEVAL":
            return BOOLEVAL(ctx, instr, loc);
        case "SAMEALT":
            return SAMEALT(ctx, instr, loc);
        case "SAMEALTSAVE":
            return SAMEALTSAVE(ctx, instr, loc);
        case "TRY":
            return TRY(ctx, instr, loc);
        case "SETCPX":
            return SETCPX(ctx, instr, loc);
        case "STDICT":
            return STDICT(ctx, instr, loc);
        case "SKIPDICT":
            return SKIPDICT(ctx, instr, loc);
        case "LDDICTS":
            return LDDICTS(ctx, instr, loc);
        case "PLDDICTS":
            return PLDDICTS(ctx, instr, loc);
        case "LDDICT":
            return LDDICT(ctx, instr, loc);
        case "PLDDICT":
            return PLDDICT(ctx, instr, loc);
        case "LDDICTQ":
            return LDDICTQ(ctx, instr, loc);
        case "PLDDICTQ":
            return PLDDICTQ(ctx, instr, loc);
        case "PFXDICTSET":
            return PFXDICTSET(ctx, instr, loc);
        case "PFXDICTREPLACE":
            return PFXDICTREPLACE(ctx, instr, loc);
        case "PFXDICTADD":
            return PFXDICTADD(ctx, instr, loc);
        case "PFXDICTDEL":
            return PFXDICTDEL(ctx, instr, loc);
        case "PFXDICTGETQ":
            return PFXDICTGETQ(ctx, instr, loc);
        case "PFXDICTGET":
            return PFXDICTGET(ctx, instr, loc);
        case "PFXDICTGETJMP":
            return PFXDICTGETJMP(ctx, instr, loc);
        case "PFXDICTGETEXEC":
            return PFXDICTGETEXEC(ctx, instr, loc);
        case "NOP":
            return NOP(ctx, instr, loc);
        case "SWAP":
            return SWAP(ctx, instr, loc);
        case "DUP":
            return DUP(ctx, instr, loc);
        case "OVER":
            return OVER(ctx, instr, loc);
        case "DROP":
            return DROP(ctx, instr, loc);
        case "NIP":
            return NIP(ctx, instr, loc);
        case "ROT":
            return ROT(ctx, instr, loc);
        case "ROTREV":
            return ROTREV(ctx, instr, loc);
        case "PICK":
            return PICK(ctx, instr, loc);
        case "ROLL":
            return ROLL(ctx, instr, loc);
        case "ROLLREV":
            return ROLLREV(ctx, instr, loc);
        case "BLKSWX":
            return BLKSWX(ctx, instr, loc);
        case "REVX":
            return REVX(ctx, instr, loc);
        case "DROPX":
            return DROPX(ctx, instr, loc);
        case "TUCK":
            return TUCK(ctx, instr, loc);
        case "XCHGX":
            return XCHGX(ctx, instr, loc);
        case "DEPTH":
            return DEPTH(ctx, instr, loc);
        case "CHKDEPTH":
            return CHKDEPTH(ctx, instr, loc);
        case "ONLYTOPX":
            return ONLYTOPX(ctx, instr, loc);
        case "ONLYX":
            return ONLYX(ctx, instr, loc);
        case "ACCEPT":
            return ACCEPT(ctx, instr, loc);
        case "SETGASLIMIT":
            return SETGASLIMIT(ctx, instr, loc);
        case "GASCONSUMED":
            return GASCONSUMED(ctx, instr, loc);
        case "COMMIT":
            return COMMIT(ctx, instr, loc);
        case "NOW":
            return NOW(ctx, instr, loc);
        case "BLOCKLT":
            return BLOCKLT(ctx, instr, loc);
        case "LTIME":
            return LTIME(ctx, instr, loc);
        case "RANDSEED":
            return RANDSEED(ctx, instr, loc);
        case "BALANCE":
            return BALANCE(ctx, instr, loc);
        case "MYADDR":
            return MYADDR(ctx, instr, loc);
        case "CONFIGROOT":
            return CONFIGROOT(ctx, instr, loc);
        case "MYCODE":
            return MYCODE(ctx, instr, loc);
        case "INCOMINGVALUE":
            return INCOMINGVALUE(ctx, instr, loc);
        case "STORAGEFEES":
            return STORAGEFEES(ctx, instr, loc);
        case "PREVBLOCKSINFOTUPLE":
            return PREVBLOCKSINFOTUPLE(ctx, instr, loc);
        case "UNPACKEDCONFIGTUPLE":
            return UNPACKEDCONFIGTUPLE(ctx, instr, loc);
        case "DUEPAYMENT":
            return DUEPAYMENT(ctx, instr, loc);
        case "CONFIGDICT":
            return CONFIGDICT(ctx, instr, loc);
        case "CONFIGPARAM":
            return CONFIGPARAM(ctx, instr, loc);
        case "CONFIGOPTPARAM":
            return CONFIGOPTPARAM(ctx, instr, loc);
        case "PREVMCBLOCKS":
            return PREVMCBLOCKS(ctx, instr, loc);
        case "PREVKEYBLOCK":
            return PREVKEYBLOCK(ctx, instr, loc);
        case "PREVMCBLOCKS_100":
            return PREVMCBLOCKS_100(ctx, instr, loc);
        case "GLOBALID":
            return GLOBALID(ctx, instr, loc);
        case "GETGASFEE":
            return GETGASFEE(ctx, instr, loc);
        case "GETSTORAGEFEE":
            return GETSTORAGEFEE(ctx, instr, loc);
        case "GETFORWARDFEE":
            return GETFORWARDFEE(ctx, instr, loc);
        case "GETPRECOMPILEDGAS":
            return GETPRECOMPILEDGAS(ctx, instr, loc);
        case "GETORIGINALFWDFEE":
            return GETORIGINALFWDFEE(ctx, instr, loc);
        case "GETGASFEESIMPLE":
            return GETGASFEESIMPLE(ctx, instr, loc);
        case "GETFORWARDFEESIMPLE":
            return GETFORWARDFEESIMPLE(ctx, instr, loc);
        case "GETGLOBVAR":
            return GETGLOBVAR(ctx, instr, loc);
        case "SETGLOBVAR":
            return SETGLOBVAR(ctx, instr, loc);
        case "RANDU256":
            return RANDU256(ctx, instr, loc);
        case "RAND":
            return RAND(ctx, instr, loc);
        case "SETRAND":
            return SETRAND(ctx, instr, loc);
        case "ADDRAND":
            return ADDRAND(ctx, instr, loc);
        case "HASHCU":
            return HASHCU(ctx, instr, loc);
        case "HASHSU":
            return HASHSU(ctx, instr, loc);
        case "SHA256U":
            return SHA256U(ctx, instr, loc);
        case "CHKSIGNU":
            return CHKSIGNU(ctx, instr, loc);
        case "CHKSIGNS":
            return CHKSIGNS(ctx, instr, loc);
        case "ECRECOVER":
            return ECRECOVER(ctx, instr, loc);
        case "SECP256K1_XONLY_PUBKEY_TWEAK_ADD":
            return SECP256K1_XONLY_PUBKEY_TWEAK_ADD(ctx, instr, loc);
        case "P256_CHKSIGNU":
            return P256_CHKSIGNU(ctx, instr, loc);
        case "P256_CHKSIGNS":
            return P256_CHKSIGNS(ctx, instr, loc);
        case "RIST255_FROMHASH":
            return RIST255_FROMHASH(ctx, instr, loc);
        case "RIST255_VALIDATE":
            return RIST255_VALIDATE(ctx, instr, loc);
        case "RIST255_ADD":
            return RIST255_ADD(ctx, instr, loc);
        case "RIST255_SUB":
            return RIST255_SUB(ctx, instr, loc);
        case "RIST255_MUL":
            return RIST255_MUL(ctx, instr, loc);
        case "RIST255_MULBASE":
            return RIST255_MULBASE(ctx, instr, loc);
        case "RIST255_PUSHL":
            return RIST255_PUSHL(ctx, instr, loc);
        case "RIST255_QVALIDATE":
            return RIST255_QVALIDATE(ctx, instr, loc);
        case "RIST255_QADD":
            return RIST255_QADD(ctx, instr, loc);
        case "RIST255_QSUB":
            return RIST255_QSUB(ctx, instr, loc);
        case "RIST255_QMUL":
            return RIST255_QMUL(ctx, instr, loc);
        case "RIST255_QMULBASE":
            return RIST255_QMULBASE(ctx, instr, loc);
        case "BLS_VERIFY":
            return BLS_VERIFY(ctx, instr, loc);
        case "BLS_AGGREGATE":
            return BLS_AGGREGATE(ctx, instr, loc);
        case "BLS_FASTAGGREGATEVERIFY":
            return BLS_FASTAGGREGATEVERIFY(ctx, instr, loc);
        case "BLS_AGGREGATEVERIFY":
            return BLS_AGGREGATEVERIFY(ctx, instr, loc);
        case "BLS_G1_ADD":
            return BLS_G1_ADD(ctx, instr, loc);
        case "BLS_G1_SUB":
            return BLS_G1_SUB(ctx, instr, loc);
        case "BLS_G1_NEG":
            return BLS_G1_NEG(ctx, instr, loc);
        case "BLS_G1_MUL":
            return BLS_G1_MUL(ctx, instr, loc);
        case "BLS_G1_MULTIEXP":
            return BLS_G1_MULTIEXP(ctx, instr, loc);
        case "BLS_G1_ZERO":
            return BLS_G1_ZERO(ctx, instr, loc);
        case "BLS_MAP_TO_G1":
            return BLS_MAP_TO_G1(ctx, instr, loc);
        case "BLS_G1_INGROUP":
            return BLS_G1_INGROUP(ctx, instr, loc);
        case "BLS_G1_ISZERO":
            return BLS_G1_ISZERO(ctx, instr, loc);
        case "BLS_G2_ADD":
            return BLS_G2_ADD(ctx, instr, loc);
        case "BLS_G2_SUB":
            return BLS_G2_SUB(ctx, instr, loc);
        case "BLS_G2_NEG":
            return BLS_G2_NEG(ctx, instr, loc);
        case "BLS_G2_MUL":
            return BLS_G2_MUL(ctx, instr, loc);
        case "BLS_G2_MULTIEXP":
            return BLS_G2_MULTIEXP(ctx, instr, loc);
        case "BLS_G2_ZERO":
            return BLS_G2_ZERO(ctx, instr, loc);
        case "BLS_MAP_TO_G2":
            return BLS_MAP_TO_G2(ctx, instr, loc);
        case "BLS_G2_INGROUP":
            return BLS_G2_INGROUP(ctx, instr, loc);
        case "BLS_G2_ISZERO":
            return BLS_G2_ISZERO(ctx, instr, loc);
        case "BLS_PAIRING":
            return BLS_PAIRING(ctx, instr, loc);
        case "BLS_PUSHR":
            return BLS_PUSHR(ctx, instr, loc);
        case "CDATASIZEQ":
            return CDATASIZEQ(ctx, instr, loc);
        case "CDATASIZE":
            return CDATASIZE(ctx, instr, loc);
        case "SDATASIZEQ":
            return SDATASIZEQ(ctx, instr, loc);
        case "SDATASIZE":
            return SDATASIZE(ctx, instr, loc);
        case "LDGRAMS":
            return LDGRAMS(ctx, instr, loc);
        case "LDVARINT16":
            return LDVARINT16(ctx, instr, loc);
        case "STGRAMS":
            return STGRAMS(ctx, instr, loc);
        case "STVARINT16":
            return STVARINT16(ctx, instr, loc);
        case "LDVARUINT32":
            return LDVARUINT32(ctx, instr, loc);
        case "LDVARINT32":
            return LDVARINT32(ctx, instr, loc);
        case "STVARUINT32":
            return STVARUINT32(ctx, instr, loc);
        case "STVARINT32":
            return STVARINT32(ctx, instr, loc);
        case "LDMSGADDR":
            return LDMSGADDR(ctx, instr, loc);
        case "LDMSGADDRQ":
            return LDMSGADDRQ(ctx, instr, loc);
        case "PARSEMSGADDR":
            return PARSEMSGADDR(ctx, instr, loc);
        case "PARSEMSGADDRQ":
            return PARSEMSGADDRQ(ctx, instr, loc);
        case "REWRITESTDADDR":
            return REWRITESTDADDR(ctx, instr, loc);
        case "REWRITESTDADDRQ":
            return REWRITESTDADDRQ(ctx, instr, loc);
        case "REWRITEVARADDR":
            return REWRITEVARADDR(ctx, instr, loc);
        case "REWRITEVARADDRQ":
            return REWRITEVARADDRQ(ctx, instr, loc);
        case "SENDRAWMSG":
            return SENDRAWMSG(ctx, instr, loc);
        case "RAWRESERVE":
            return RAWRESERVE(ctx, instr, loc);
        case "RAWRESERVEX":
            return RAWRESERVEX(ctx, instr, loc);
        case "SETCODE":
            return SETCODE(ctx, instr, loc);
        case "SETLIBCODE":
            return SETLIBCODE(ctx, instr, loc);
        case "CHANGELIB":
            return CHANGELIB(ctx, instr, loc);
        case "SENDMSG":
            return SENDMSG(ctx, instr, loc);
        case "PUSHNULL":
            return PUSHNULL(ctx, instr, loc);
        case "ISNULL":
            return ISNULL(ctx, instr, loc);
        case "TUPLEVAR":
            return TUPLEVAR(ctx, instr, loc);
        case "INDEXVAR":
            return INDEXVAR(ctx, instr, loc);
        case "UNTUPLEVAR":
            return UNTUPLEVAR(ctx, instr, loc);
        case "UNPACKFIRSTVAR":
            return UNPACKFIRSTVAR(ctx, instr, loc);
        case "EXPLODEVAR":
            return EXPLODEVAR(ctx, instr, loc);
        case "SETINDEXVAR":
            return SETINDEXVAR(ctx, instr, loc);
        case "INDEXVARQ":
            return INDEXVARQ(ctx, instr, loc);
        case "SETINDEXVARQ":
            return SETINDEXVARQ(ctx, instr, loc);
        case "TLEN":
            return TLEN(ctx, instr, loc);
        case "QTLEN":
            return QTLEN(ctx, instr, loc);
        case "ISTUPLE":
            return ISTUPLE(ctx, instr, loc);
        case "LAST":
            return LAST(ctx, instr, loc);
        case "TPUSH":
            return TPUSH(ctx, instr, loc);
        case "TPOP":
            return TPOP(ctx, instr, loc);
        case "NULLSWAPIF":
            return NULLSWAPIF(ctx, instr, loc);
        case "NULLSWAPIFNOT":
            return NULLSWAPIFNOT(ctx, instr, loc);
        case "NULLROTRIF":
            return NULLROTRIF(ctx, instr, loc);
        case "NULLROTRIFNOT":
            return NULLROTRIFNOT(ctx, instr, loc);
        case "NULLSWAPIF2":
            return NULLSWAPIF2(ctx, instr, loc);
        case "NULLSWAPIFNOT2":
            return NULLSWAPIFNOT2(ctx, instr, loc);
        case "NULLROTRIF2":
            return NULLROTRIF2(ctx, instr, loc);
        case "NULLROTRIFNOT2":
            return NULLROTRIFNOT2(ctx, instr, loc);
        case "ADDDIVMOD":
            return ADDDIVMOD(ctx, instr, loc);
        case "ADDDIVMODR":
            return ADDDIVMODR(ctx, instr, loc);
        case "ADDDIVMODC":
            return ADDDIVMODC(ctx, instr, loc);
        case "DIV":
            return DIV(ctx, instr, loc);
        case "DIVR":
            return DIVR(ctx, instr, loc);
        case "DIVC":
            return DIVC(ctx, instr, loc);
        case "MOD":
            return MOD(ctx, instr, loc);
        case "MODR":
            return MODR(ctx, instr, loc);
        case "MODC":
            return MODC(ctx, instr, loc);
        case "DIVMOD":
            return DIVMOD(ctx, instr, loc);
        case "DIVMODR":
            return DIVMODR(ctx, instr, loc);
        case "DIVMODC":
            return DIVMODC(ctx, instr, loc);
        case "QADDDIVMOD":
            return QADDDIVMOD(ctx, instr, loc);
        case "QADDDIVMODR":
            return QADDDIVMODR(ctx, instr, loc);
        case "QADDDIVMODC":
            return QADDDIVMODC(ctx, instr, loc);
        case "QDIV":
            return QDIV(ctx, instr, loc);
        case "QDIVR":
            return QDIVR(ctx, instr, loc);
        case "QDIVC":
            return QDIVC(ctx, instr, loc);
        case "QMOD":
            return QMOD(ctx, instr, loc);
        case "QMODR":
            return QMODR(ctx, instr, loc);
        case "QMODC":
            return QMODC(ctx, instr, loc);
        case "QDIVMOD":
            return QDIVMOD(ctx, instr, loc);
        case "QDIVMODR":
            return QDIVMODR(ctx, instr, loc);
        case "QDIVMODC":
            return QDIVMODC(ctx, instr, loc);
        case "ADDRSHIFTMOD":
            return ADDRSHIFTMOD(ctx, instr, loc);
        case "ADDRSHIFTMODR":
            return ADDRSHIFTMODR(ctx, instr, loc);
        case "ADDRSHIFTMODC":
            return ADDRSHIFTMODC(ctx, instr, loc);
        case "RSHIFTR":
            return RSHIFTR(ctx, instr, loc);
        case "RSHIFTC":
            return RSHIFTC(ctx, instr, loc);
        case "MODPOW2":
            return MODPOW2(ctx, instr, loc);
        case "MODPOW2R":
            return MODPOW2R(ctx, instr, loc);
        case "MODPOW2C":
            return MODPOW2C(ctx, instr, loc);
        case "RSHIFTMOD":
            return RSHIFTMOD(ctx, instr, loc);
        case "RSHIFTMODR":
            return RSHIFTMODR(ctx, instr, loc);
        case "RSHIFTMODC":
            return RSHIFTMODC(ctx, instr, loc);
        case "QADDRSHIFTMOD":
            return QADDRSHIFTMOD(ctx, instr, loc);
        case "QADDRSHIFTMODR":
            return QADDRSHIFTMODR(ctx, instr, loc);
        case "QADDRSHIFTMODC":
            return QADDRSHIFTMODC(ctx, instr, loc);
        case "QRSHIFTR":
            return QRSHIFTR(ctx, instr, loc);
        case "QRSHIFTC":
            return QRSHIFTC(ctx, instr, loc);
        case "QMODPOW2":
            return QMODPOW2(ctx, instr, loc);
        case "QMODPOW2R":
            return QMODPOW2R(ctx, instr, loc);
        case "QMODPOW2C":
            return QMODPOW2C(ctx, instr, loc);
        case "QRSHIFTMOD":
            return QRSHIFTMOD(ctx, instr, loc);
        case "QRSHIFTMODR":
            return QRSHIFTMODR(ctx, instr, loc);
        case "QRSHIFTMODC":
            return QRSHIFTMODC(ctx, instr, loc);
        case "MULADDDIVMOD":
            return MULADDDIVMOD(ctx, instr, loc);
        case "MULADDDIVMODR":
            return MULADDDIVMODR(ctx, instr, loc);
        case "MULADDDIVMODC":
            return MULADDDIVMODC(ctx, instr, loc);
        case "MULDIV":
            return MULDIV(ctx, instr, loc);
        case "MULDIVR":
            return MULDIVR(ctx, instr, loc);
        case "MULDIVC":
            return MULDIVC(ctx, instr, loc);
        case "MULMOD":
            return MULMOD(ctx, instr, loc);
        case "MULMODR":
            return MULMODR(ctx, instr, loc);
        case "MULMODC":
            return MULMODC(ctx, instr, loc);
        case "MULDIVMOD":
            return MULDIVMOD(ctx, instr, loc);
        case "MULDIVMODR":
            return MULDIVMODR(ctx, instr, loc);
        case "MULDIVMODC":
            return MULDIVMODC(ctx, instr, loc);
        case "QMULADDDIVMOD":
            return QMULADDDIVMOD(ctx, instr, loc);
        case "QMULADDDIVMODR":
            return QMULADDDIVMODR(ctx, instr, loc);
        case "QMULADDDIVMODC":
            return QMULADDDIVMODC(ctx, instr, loc);
        case "QMULDIV":
            return QMULDIV(ctx, instr, loc);
        case "QMULDIVR":
            return QMULDIVR(ctx, instr, loc);
        case "QMULDIVC":
            return QMULDIVC(ctx, instr, loc);
        case "QMULMOD":
            return QMULMOD(ctx, instr, loc);
        case "QMULMODR":
            return QMULMODR(ctx, instr, loc);
        case "QMULMODC":
            return QMULMODC(ctx, instr, loc);
        case "QMULDIVMOD":
            return QMULDIVMOD(ctx, instr, loc);
        case "QMULDIVMODR":
            return QMULDIVMODR(ctx, instr, loc);
        case "QMULDIVMODC":
            return QMULDIVMODC(ctx, instr, loc);
        case "MULADDRSHIFTMOD":
            return MULADDRSHIFTMOD(ctx, instr, loc);
        case "MULADDRSHIFTRMOD":
            return MULADDRSHIFTRMOD(ctx, instr, loc);
        case "MULADDRSHIFTCMOD":
            return MULADDRSHIFTCMOD(ctx, instr, loc);
        case "MULRSHIFT":
            return MULRSHIFT(ctx, instr, loc);
        case "MULRSHIFTR":
            return MULRSHIFTR(ctx, instr, loc);
        case "MULRSHIFTC":
            return MULRSHIFTC(ctx, instr, loc);
        case "MULMODPOW2":
            return MULMODPOW2(ctx, instr, loc);
        case "MULMODPOW2R":
            return MULMODPOW2R(ctx, instr, loc);
        case "MULMODPOW2C":
            return MULMODPOW2C(ctx, instr, loc);
        case "MULRSHIFTMOD":
            return MULRSHIFTMOD(ctx, instr, loc);
        case "MULRSHIFTRMOD":
            return MULRSHIFTRMOD(ctx, instr, loc);
        case "MULRSHIFTCMOD":
            return MULRSHIFTCMOD(ctx, instr, loc);
        case "QMULADDRSHIFTMOD":
            return QMULADDRSHIFTMOD(ctx, instr, loc);
        case "QMULADDRSHIFTRMOD":
            return QMULADDRSHIFTRMOD(ctx, instr, loc);
        case "QMULADDRSHIFTCMOD":
            return QMULADDRSHIFTCMOD(ctx, instr, loc);
        case "QMULRSHIFT":
            return QMULRSHIFT(ctx, instr, loc);
        case "QMULRSHIFTR":
            return QMULRSHIFTR(ctx, instr, loc);
        case "QMULRSHIFTC":
            return QMULRSHIFTC(ctx, instr, loc);
        case "QMULMODPOW2":
            return QMULMODPOW2(ctx, instr, loc);
        case "QMULMODPOW2R":
            return QMULMODPOW2R(ctx, instr, loc);
        case "QMULMODPOW2C":
            return QMULMODPOW2C(ctx, instr, loc);
        case "QMULRSHIFTMOD":
            return QMULRSHIFTMOD(ctx, instr, loc);
        case "QMULRSHIFTRMOD":
            return QMULRSHIFTRMOD(ctx, instr, loc);
        case "QMULRSHIFTCMOD":
            return QMULRSHIFTCMOD(ctx, instr, loc);
        case "LSHIFTADDDIVMOD":
            return LSHIFTADDDIVMOD(ctx, instr, loc);
        case "LSHIFTADDDIVMODR":
            return LSHIFTADDDIVMODR(ctx, instr, loc);
        case "LSHIFTADDDIVMODC":
            return LSHIFTADDDIVMODC(ctx, instr, loc);
        case "LSHIFTDIV":
            return LSHIFTDIV(ctx, instr, loc);
        case "LSHIFTDIVR":
            return LSHIFTDIVR(ctx, instr, loc);
        case "LSHIFTDIVC":
            return LSHIFTDIVC(ctx, instr, loc);
        case "LSHIFTMOD":
            return LSHIFTMOD(ctx, instr, loc);
        case "LSHIFTMODR":
            return LSHIFTMODR(ctx, instr, loc);
        case "LSHIFTMODC":
            return LSHIFTMODC(ctx, instr, loc);
        case "LSHIFTDIVMOD":
            return LSHIFTDIVMOD(ctx, instr, loc);
        case "LSHIFTDIVMODR":
            return LSHIFTDIVMODR(ctx, instr, loc);
        case "LSHIFTDIVMODC":
            return LSHIFTDIVMODC(ctx, instr, loc);
        case "QLSHIFTADDDIVMOD":
            return QLSHIFTADDDIVMOD(ctx, instr, loc);
        case "QLSHIFTADDDIVMODR":
            return QLSHIFTADDDIVMODR(ctx, instr, loc);
        case "QLSHIFTADDDIVMODC":
            return QLSHIFTADDDIVMODC(ctx, instr, loc);
        case "QLSHIFTDIV":
            return QLSHIFTDIV(ctx, instr, loc);
        case "QLSHIFTDIVR":
            return QLSHIFTDIVR(ctx, instr, loc);
        case "QLSHIFTDIVC":
            return QLSHIFTDIVC(ctx, instr, loc);
        case "QLSHIFTMOD":
            return QLSHIFTMOD(ctx, instr, loc);
        case "QLSHIFTMODR":
            return QLSHIFTMODR(ctx, instr, loc);
        case "QLSHIFTMODC":
            return QLSHIFTMODC(ctx, instr, loc);
        case "QLSHIFTDIVMOD":
            return QLSHIFTDIVMOD(ctx, instr, loc);
        case "QLSHIFTDIVMODR":
            return QLSHIFTDIVMODR(ctx, instr, loc);
        case "QLSHIFTDIVMODC":
            return QLSHIFTDIVMODC(ctx, instr, loc);
        case "STIX":
            return STIX(ctx, instr, loc);
        case "STUX":
            return STUX(ctx, instr, loc);
        case "STIXR":
            return STIXR(ctx, instr, loc);
        case "STUXR":
            return STUXR(ctx, instr, loc);
        case "STIXQ":
            return STIXQ(ctx, instr, loc);
        case "STUXQ":
            return STUXQ(ctx, instr, loc);
        case "STIXRQ":
            return STIXRQ(ctx, instr, loc);
        case "STUXRQ":
            return STUXRQ(ctx, instr, loc);
        case "STILE4":
            return STILE4(ctx, instr, loc);
        case "STULE4":
            return STULE4(ctx, instr, loc);
        case "STILE8":
            return STILE8(ctx, instr, loc);
        case "STULE8":
            return STULE8(ctx, instr, loc);
        case "LDIX":
            return LDIX(ctx, instr, loc);
        case "LDUX":
            return LDUX(ctx, instr, loc);
        case "PLDIX":
            return PLDIX(ctx, instr, loc);
        case "PLDUX":
            return PLDUX(ctx, instr, loc);
        case "LDIXQ":
            return LDIXQ(ctx, instr, loc);
        case "LDUXQ":
            return LDUXQ(ctx, instr, loc);
        case "PLDIXQ":
            return PLDIXQ(ctx, instr, loc);
        case "PLDUXQ":
            return PLDUXQ(ctx, instr, loc);
        case "LDSLICEX":
            return LDSLICEX(ctx, instr, loc);
        case "PLDSLICEX":
            return PLDSLICEX(ctx, instr, loc);
        case "LDSLICEXQ":
            return LDSLICEXQ(ctx, instr, loc);
        case "PLDSLICEXQ":
            return PLDSLICEXQ(ctx, instr, loc);
        case "LDILE4":
            return LDILE4(ctx, instr, loc);
        case "LDULE4":
            return LDULE4(ctx, instr, loc);
        case "LDILE8":
            return LDILE8(ctx, instr, loc);
        case "LDULE8":
            return LDULE8(ctx, instr, loc);
        case "PLDILE4":
            return PLDILE4(ctx, instr, loc);
        case "PLDULE4":
            return PLDULE4(ctx, instr, loc);
        case "PLDILE8":
            return PLDILE8(ctx, instr, loc);
        case "PLDULE8":
            return PLDULE8(ctx, instr, loc);
        case "LDILE4Q":
            return LDILE4Q(ctx, instr, loc);
        case "LDULE4Q":
            return LDULE4Q(ctx, instr, loc);
        case "LDILE8Q":
            return LDILE8Q(ctx, instr, loc);
        case "LDULE8Q":
            return LDULE8Q(ctx, instr, loc);
        case "PLDILE4Q":
            return PLDILE4Q(ctx, instr, loc);
        case "PLDULE4Q":
            return PLDULE4Q(ctx, instr, loc);
        case "PLDILE8Q":
            return PLDILE8Q(ctx, instr, loc);
        case "PLDULE8Q":
            return PLDULE8Q(ctx, instr, loc);
        case "DICTIGETJMP":
            return DICTIGETJMP(ctx, instr, loc);
        case "DICTUGETJMP":
            return DICTUGETJMP(ctx, instr, loc);
        case "DICTIGETEXEC":
            return DICTIGETEXEC(ctx, instr, loc);
        case "DICTUGETEXEC":
            return DICTUGETEXEC(ctx, instr, loc);
        case "DICTIGETJMPZ":
            return DICTIGETJMPZ(ctx, instr, loc);
        case "DICTUGETJMPZ":
            return DICTUGETJMPZ(ctx, instr, loc);
        case "DICTIGETEXECZ":
            return DICTIGETEXECZ(ctx, instr, loc);
        case "DICTUGETEXECZ":
            return DICTUGETEXECZ(ctx, instr, loc);
        case "DICTGET":
            return DICTGET(ctx, instr, loc);
        case "DICTGETREF":
            return DICTGETREF(ctx, instr, loc);
        case "DICTIGET":
            return DICTIGET(ctx, instr, loc);
        case "DICTIGETREF":
            return DICTIGETREF(ctx, instr, loc);
        case "DICTUGET":
            return DICTUGET(ctx, instr, loc);
        case "DICTUGETREF":
            return DICTUGETREF(ctx, instr, loc);
        case "DICTSET":
            return DICTSET(ctx, instr, loc);
        case "DICTSETREF":
            return DICTSETREF(ctx, instr, loc);
        case "DICTISET":
            return DICTISET(ctx, instr, loc);
        case "DICTISETREF":
            return DICTISETREF(ctx, instr, loc);
        case "DICTUSET":
            return DICTUSET(ctx, instr, loc);
        case "DICTUSETREF":
            return DICTUSETREF(ctx, instr, loc);
        case "DICTSETGET":
            return DICTSETGET(ctx, instr, loc);
        case "DICTSETGETREF":
            return DICTSETGETREF(ctx, instr, loc);
        case "DICTISETGET":
            return DICTISETGET(ctx, instr, loc);
        case "DICTISETGETREF":
            return DICTISETGETREF(ctx, instr, loc);
        case "DICTUSETGET":
            return DICTUSETGET(ctx, instr, loc);
        case "DICTUSETGETREF":
            return DICTUSETGETREF(ctx, instr, loc);
        case "DICTREPLACE":
            return DICTREPLACE(ctx, instr, loc);
        case "DICTREPLACEREF":
            return DICTREPLACEREF(ctx, instr, loc);
        case "DICTIREPLACE":
            return DICTIREPLACE(ctx, instr, loc);
        case "DICTIREPLACEREF":
            return DICTIREPLACEREF(ctx, instr, loc);
        case "DICTUREPLACE":
            return DICTUREPLACE(ctx, instr, loc);
        case "DICTUREPLACEREF":
            return DICTUREPLACEREF(ctx, instr, loc);
        case "DICTREPLACEGET":
            return DICTREPLACEGET(ctx, instr, loc);
        case "DICTREPLACEGETREF":
            return DICTREPLACEGETREF(ctx, instr, loc);
        case "DICTIREPLACEGET":
            return DICTIREPLACEGET(ctx, instr, loc);
        case "DICTIREPLACEGETREF":
            return DICTIREPLACEGETREF(ctx, instr, loc);
        case "DICTUREPLACEGET":
            return DICTUREPLACEGET(ctx, instr, loc);
        case "DICTUREPLACEGETREF":
            return DICTUREPLACEGETREF(ctx, instr, loc);
        case "DICTADD":
            return DICTADD(ctx, instr, loc);
        case "DICTADDREF":
            return DICTADDREF(ctx, instr, loc);
        case "DICTIADD":
            return DICTIADD(ctx, instr, loc);
        case "DICTIADDREF":
            return DICTIADDREF(ctx, instr, loc);
        case "DICTUADD":
            return DICTUADD(ctx, instr, loc);
        case "DICTUADDREF":
            return DICTUADDREF(ctx, instr, loc);
        case "DICTADDGET":
            return DICTADDGET(ctx, instr, loc);
        case "DICTADDGETREF":
            return DICTADDGETREF(ctx, instr, loc);
        case "DICTIADDGET":
            return DICTIADDGET(ctx, instr, loc);
        case "DICTIADDGETREF":
            return DICTIADDGETREF(ctx, instr, loc);
        case "DICTUADDGET":
            return DICTUADDGET(ctx, instr, loc);
        case "DICTUADDGETREF":
            return DICTUADDGETREF(ctx, instr, loc);
        case "DICTDELGET":
            return DICTDELGET(ctx, instr, loc);
        case "DICTDELGETREF":
            return DICTDELGETREF(ctx, instr, loc);
        case "DICTIDELGET":
            return DICTIDELGET(ctx, instr, loc);
        case "DICTIDELGETREF":
            return DICTIDELGETREF(ctx, instr, loc);
        case "DICTUDELGET":
            return DICTUDELGET(ctx, instr, loc);
        case "DICTUDELGETREF":
            return DICTUDELGETREF(ctx, instr, loc);
        case "DICTMIN":
            return DICTMIN(ctx, instr, loc);
        case "DICTMINREF":
            return DICTMINREF(ctx, instr, loc);
        case "DICTIMIN":
            return DICTIMIN(ctx, instr, loc);
        case "DICTIMINREF":
            return DICTIMINREF(ctx, instr, loc);
        case "DICTUMIN":
            return DICTUMIN(ctx, instr, loc);
        case "DICTUMINREF":
            return DICTUMINREF(ctx, instr, loc);
        case "DICTMAX":
            return DICTMAX(ctx, instr, loc);
        case "DICTMAXREF":
            return DICTMAXREF(ctx, instr, loc);
        case "DICTIMAX":
            return DICTIMAX(ctx, instr, loc);
        case "DICTIMAXREF":
            return DICTIMAXREF(ctx, instr, loc);
        case "DICTUMAX":
            return DICTUMAX(ctx, instr, loc);
        case "DICTUMAXREF":
            return DICTUMAXREF(ctx, instr, loc);
        case "DICTREMMIN":
            return DICTREMMIN(ctx, instr, loc);
        case "DICTREMMINREF":
            return DICTREMMINREF(ctx, instr, loc);
        case "DICTIREMMIN":
            return DICTIREMMIN(ctx, instr, loc);
        case "DICTIREMMINREF":
            return DICTIREMMINREF(ctx, instr, loc);
        case "DICTUREMMIN":
            return DICTUREMMIN(ctx, instr, loc);
        case "DICTUREMMINREF":
            return DICTUREMMINREF(ctx, instr, loc);
        case "DICTREMMAX":
            return DICTREMMAX(ctx, instr, loc);
        case "DICTREMMAXREF":
            return DICTREMMAXREF(ctx, instr, loc);
        case "DICTIREMMAX":
            return DICTIREMMAX(ctx, instr, loc);
        case "DICTIREMMAXREF":
            return DICTIREMMAXREF(ctx, instr, loc);
        case "DICTUREMMAX":
            return DICTUREMMAX(ctx, instr, loc);
        case "DICTUREMMAXREF":
            return DICTUREMMAXREF(ctx, instr, loc);
        case "DICTSETB":
            return DICTSETB(ctx, instr, loc);
        case "DICTISETB":
            return DICTISETB(ctx, instr, loc);
        case "DICTUSETB":
            return DICTUSETB(ctx, instr, loc);
        case "DICTSETGETB":
            return DICTSETGETB(ctx, instr, loc);
        case "DICTISETGETB":
            return DICTISETGETB(ctx, instr, loc);
        case "DICTUSETGETB":
            return DICTUSETGETB(ctx, instr, loc);
        case "DICTREPLACEB":
            return DICTREPLACEB(ctx, instr, loc);
        case "DICTIREPLACEB":
            return DICTIREPLACEB(ctx, instr, loc);
        case "DICTUREPLACEB":
            return DICTUREPLACEB(ctx, instr, loc);
        case "DICTREPLACEGETB":
            return DICTREPLACEGETB(ctx, instr, loc);
        case "DICTIREPLACEGETB":
            return DICTIREPLACEGETB(ctx, instr, loc);
        case "DICTUREPLACEGETB":
            return DICTUREPLACEGETB(ctx, instr, loc);
        case "DICTADDB":
            return DICTADDB(ctx, instr, loc);
        case "DICTIADDB":
            return DICTIADDB(ctx, instr, loc);
        case "DICTUADDB":
            return DICTUADDB(ctx, instr, loc);
        case "DICTADDGETB":
            return DICTADDGETB(ctx, instr, loc);
        case "DICTIADDGETB":
            return DICTIADDGETB(ctx, instr, loc);
        case "DICTUADDGETB":
            return DICTUADDGETB(ctx, instr, loc);
        case "DICTDEL":
            return DICTDEL(ctx, instr, loc);
        case "DICTIDEL":
            return DICTIDEL(ctx, instr, loc);
        case "DICTUDEL":
            return DICTUDEL(ctx, instr, loc);
        case "DICTGETOPTREF":
            return DICTGETOPTREF(ctx, instr, loc);
        case "DICTIGETOPTREF":
            return DICTIGETOPTREF(ctx, instr, loc);
        case "DICTUGETOPTREF":
            return DICTUGETOPTREF(ctx, instr, loc);
        case "DICTSETGETOPTREF":
            return DICTSETGETOPTREF(ctx, instr, loc);
        case "DICTISETGETOPTREF":
            return DICTISETGETOPTREF(ctx, instr, loc);
        case "DICTUSETGETOPTREF":
            return DICTUSETGETOPTREF(ctx, instr, loc);
        case "SUBDICTGET":
            return SUBDICTGET(ctx, instr, loc);
        case "SUBDICTIGET":
            return SUBDICTIGET(ctx, instr, loc);
        case "SUBDICTUGET":
            return SUBDICTUGET(ctx, instr, loc);
        case "SUBDICTRPGET":
            return SUBDICTRPGET(ctx, instr, loc);
        case "SUBDICTIRPGET":
            return SUBDICTIRPGET(ctx, instr, loc);
        case "SUBDICTURPGET":
            return SUBDICTURPGET(ctx, instr, loc);
        case "THROWANY":
            return THROWANY(ctx, instr, loc);
        case "THROWARGANY":
            return THROWARGANY(ctx, instr, loc);
        case "THROWANYIFNOT":
            return THROWANYIFNOT(ctx, instr, loc);
        case "THROWARGANYIFNOT":
            return THROWARGANYIFNOT(ctx, instr, loc);
        case "DICTGETNEXT":
            return DICTGETNEXT(ctx, instr, loc);
        case "DICTGETNEXTEQ":
            return DICTGETNEXTEQ(ctx, instr, loc);
        case "DICTGETPREV":
            return DICTGETPREV(ctx, instr, loc);
        case "DICTGETPREVEQ":
            return DICTGETPREVEQ(ctx, instr, loc);
        case "DICTIGETNEXT":
            return DICTIGETNEXT(ctx, instr, loc);
        case "DICTIGETNEXTEQ":
            return DICTIGETNEXTEQ(ctx, instr, loc);
        case "DICTIGETPREV":
            return DICTIGETPREV(ctx, instr, loc);
        case "DICTIGETPREVEQ":
            return DICTIGETPREVEQ(ctx, instr, loc);
        case "DICTUGETNEXT":
            return DICTUGETNEXT(ctx, instr, loc);
        case "DICTUGETNEXTEQ":
            return DICTUGETNEXTEQ(ctx, instr, loc);
        case "DICTUGETPREV":
            return DICTUGETPREV(ctx, instr, loc);
        case "DICTUGETPREVEQ":
            return DICTUGETPREVEQ(ctx, instr, loc);
        case "ADDINT":
            return ADDINT(ctx, instr, loc);
        case "MULINT":
            return MULINT(ctx, instr, loc);
        case "QADDINT":
            return QADDINT(ctx, instr, loc);
        case "QMULINT":
            return QMULINT(ctx, instr, loc);
        case "EQINT":
            return EQINT(ctx, instr, loc);
        case "LESSINT":
            return LESSINT(ctx, instr, loc);
        case "GTINT":
            return GTINT(ctx, instr, loc);
        case "NEQINT":
            return NEQINT(ctx, instr, loc);
        case "QEQINT":
            return QEQINT(ctx, instr, loc);
        case "QLESSINT":
            return QLESSINT(ctx, instr, loc);
        case "QGTINT":
            return QGTINT(ctx, instr, loc);
        case "QNEQINT":
            return QNEQINT(ctx, instr, loc);
        case "PUSHPOW2DEC":
            return PUSHPOW2DEC(ctx, instr, loc);
        case "PUSHNEGPOW2":
            return PUSHNEGPOW2(ctx, instr, loc);
        case "FITS":
            return FITS(ctx, instr, loc);
        case "UFITS":
            return UFITS(ctx, instr, loc);
        case "QFITS":
            return QFITS(ctx, instr, loc);
        case "QUFITS":
            return QUFITS(ctx, instr, loc);
        case "SETCONTCTRMANY":
            return SETCONTCTRMANY(ctx, instr, loc);
        case "CALLCCARGS":
            return CALLCCARGS(ctx, instr, loc);
        case "TRYARGS":
            return TRYARGS(ctx, instr, loc);
        case "PLDREFIDX":
            return PLDREFIDX(ctx, instr, loc);
        case "CHASHI":
            return CHASHI(ctx, instr, loc);
        case "CDEPTHI":
            return CDEPTHI(ctx, instr, loc);
        case "JMPDICT":
            return JMPDICT(ctx, instr, loc);
        case "PREPAREDICT":
            return PREPAREDICT(ctx, instr, loc);
        case "THROWARG":
            return THROWARG(ctx, instr, loc);
        case "THROWARGIF":
            return THROWARGIF(ctx, instr, loc);
        case "THROWARGIFNOT":
            return THROWARGIFNOT(ctx, instr, loc);
        case "JMPXARGS":
            return JMPXARGS(ctx, instr, loc);
        case "RETARGS":
            return RETARGS(ctx, instr, loc);
        case "RETURNARGS":
            return RETURNARGS(ctx, instr, loc);
        case "BLKDROP":
            return BLKDROP(ctx, instr, loc);
        case "TUPLE":
            return TUPLE(ctx, instr, loc);
        case "INDEX":
            return INDEX(ctx, instr, loc);
        case "UNTUPLE":
            return UNTUPLE(ctx, instr, loc);
        case "UNPACKFIRST":
            return UNPACKFIRST(ctx, instr, loc);
        case "EXPLODE":
            return EXPLODE(ctx, instr, loc);
        case "SETINDEX":
            return SETINDEX(ctx, instr, loc);
        case "INDEXQ":
            return INDEXQ(ctx, instr, loc);
        case "SETINDEXQ":
            return SETINDEXQ(ctx, instr, loc);
        case "XC2PU":
            return XC2PU(ctx, instr, loc);
        case "XCPU2":
            return XCPU2(ctx, instr, loc);
        case "PUSH3":
            return PUSH3(ctx, instr, loc);
        case "XCHG2":
            return XCHG2(ctx, instr, loc);
        case "XCPU":
            return XCPU(ctx, instr, loc);
        case "PUSH2":
            return PUSH2(ctx, instr, loc);
        case "PUXC":
            return PUXC(ctx, instr, loc);
        case "XCPUXC":
            return XCPUXC(ctx, instr, loc);
        case "PUXC2":
            return PUXC2(ctx, instr, loc);
        case "PUXCPU":
            return PUXCPU(ctx, instr, loc);
        case "PU2XC":
            return PU2XC(ctx, instr, loc);
        case "BLKSWAP":
            return BLKSWAP(ctx, instr, loc);
        case "REVERSE":
            return REVERSE(ctx, instr, loc);
        case "SETCONTARGS":
            return SETCONTARGS(ctx, instr, loc);
        case "BLESSARGS":
            return BLESSARGS(ctx, instr, loc);
        case "STIR":
            return STIR(ctx, instr, loc);
        case "STUR":
            return STUR(ctx, instr, loc);
        case "STIQ":
            return STIQ(ctx, instr, loc);
        case "STUQ":
            return STUQ(ctx, instr, loc);
        case "STIRQ":
            return STIRQ(ctx, instr, loc);
        case "STURQ":
            return STURQ(ctx, instr, loc);
        case "PLDI":
            return PLDI(ctx, instr, loc);
        case "PLDU":
            return PLDU(ctx, instr, loc);
        case "LDIQ":
            return LDIQ(ctx, instr, loc);
        case "LDUQ":
            return LDUQ(ctx, instr, loc);
        case "PLDIQ":
            return PLDIQ(ctx, instr, loc);
        case "PLDUQ":
            return PLDUQ(ctx, instr, loc);
        case "PLDUZ":
            return PLDUZ(ctx, instr, loc);
        case "PLDSLICE":
            return PLDSLICE(ctx, instr, loc);
        case "LDSLICEQ":
            return LDSLICEQ(ctx, instr, loc);
        case "PLDSLICEQ":
            return PLDSLICEQ(ctx, instr, loc);
        case "IFBITJMP":
            return IFBITJMP(ctx, instr, loc);
        case "IFNBITJMP":
            return IFNBITJMP(ctx, instr, loc);
        case "INDEX2":
            return INDEX2(ctx, instr, loc);
        case "INDEX3":
            return INDEX3(ctx, instr, loc);
        case "PUSHPOW2":
            return PUSHPOW2(ctx, instr, loc);
        case "BLKPUSH":
            return BLKPUSH(ctx, instr, loc);
        case "BLKDROP2":
            return BLKDROP2(ctx, instr, loc);
        case "GETGLOB":
            return GETGLOB(ctx, instr, loc);
        case "SETGLOB":
            return SETGLOB(ctx, instr, loc);
        case "GETPARAM":
            return GETPARAM(ctx, instr, loc);
        case "PUSHREF":
            return PUSHREF(ctx, instr, loc);
        case "PUSHREFSLICE":
            return PUSHREFSLICE(ctx, instr, loc);
        case "PUSHREFCONT":
            return PUSHREFCONT(ctx, instr, loc);
        case "CALLREF":
            return CALLREF(ctx, instr, loc);
        case "JMPREF":
            return JMPREF(ctx, instr, loc);
        case "JMPREFDATA":
            return JMPREFDATA(ctx, instr, loc);
        case "IFREF":
            return IFREF(ctx, instr, loc);
        case "IFNOTREF":
            return IFNOTREF(ctx, instr, loc);
        case "IFJMPREF":
            return IFJMPREF(ctx, instr, loc);
        case "IFNOTJMPREF":
            return IFNOTJMPREF(ctx, instr, loc);
        case "IFREFELSE":
            return IFREFELSE(ctx, instr, loc);
        case "IFELSEREF":
            return IFELSEREF(ctx, instr, loc);
        case "IFREFELSEREF":
            return IFREFELSEREF(ctx, instr, loc);
        case "IFBITJMPREF":
            return IFBITJMPREF(ctx, instr, loc);
        case "IFNBITJMPREF":
            return IFNBITJMPREF(ctx, instr, loc);
        case "DICTPUSHCONST":
            return DICTPUSHCONST(ctx, instr, loc);
        case "PFXDICTSWITCH":
            return PFXDICTSWITCH(ctx, instr, loc);
        case "SDBEGINSX":
            return SDBEGINSX(ctx, instr, loc);
        case "SDBEGINSXQ":
            return SDBEGINSXQ(ctx, instr, loc);
        case "SDBEGINS":
            return SDBEGINS(ctx, instr, loc);
        case "SDBEGINSQ":
            return SDBEGINSQ(ctx, instr, loc);
        case "STREFCONST":
            return STREFCONST(ctx, instr, loc);
        case "STREF2CONST":
            return STREF2CONST(ctx, instr, loc);
        case "THROWANYIF":
            return THROWANYIF(ctx, instr, loc);
        case "THROWARGANYIF":
            return THROWARGANYIF(ctx, instr, loc);
        case "DEBUGSTR":
            return DEBUGSTR(ctx, instr, loc);
        case "SETCONTCTR":
            return SETCONTCTR(ctx, instr, loc);
        case "SETRETCTR":
            return SETRETCTR(ctx, instr, loc);
        case "SETALTCTR":
            return SETALTCTR(ctx, instr, loc);
        case "POPSAVE":
            return POPSAVE(ctx, instr, loc);
        case "SAVECTR":
            return SAVECTR(ctx, instr, loc);
        case "SAVEALTCTR":
            return SAVEALTCTR(ctx, instr, loc);
        case "SAVEBOTHCTR":
            return SAVEBOTHCTR(ctx, instr, loc);
        case "RUNVM":
            return RUNVM(ctx, instr, loc);
        case "SWAP2":
            return SWAP2(ctx, instr, loc);
        case "DROP2":
            return DROP2(ctx, instr, loc);
        case "DUP2":
            return DUP2(ctx, instr, loc);
        case "OVER2":
            return OVER2(ctx, instr, loc);
        case "ADDRSHIFT_MOD":
            return ADDRSHIFT_MOD(ctx, instr, loc);
        case "ADDRSHIFTR_MOD":
            return ADDRSHIFTR_MOD(ctx, instr, loc);
        case "ADDRSHIFTC_MOD":
            return ADDRSHIFTC_MOD(ctx, instr, loc);
        case "RSHIFT_":
            return RSHIFT_(ctx, instr, loc);
        case "RSHIFTR_":
            return RSHIFTR_(ctx, instr, loc);
        case "RSHIFTC_":
            return RSHIFTC_(ctx, instr, loc);
        case "MODPOW2_":
            return MODPOW2_(ctx, instr, loc);
        case "MODPOW2R_":
            return MODPOW2R_(ctx, instr, loc);
        case "MODPOW2C_":
            return MODPOW2C_(ctx, instr, loc);
        case "RSHIFT_MOD":
            return RSHIFT_MOD(ctx, instr, loc);
        case "RSHIFTR_MOD":
            return RSHIFTR_MOD(ctx, instr, loc);
        case "RSHIFTC_MOD":
            return RSHIFTC_MOD(ctx, instr, loc);
        case "MULADDRSHIFT_MOD":
            return MULADDRSHIFT_MOD(ctx, instr, loc);
        case "MULADDRSHIFTR_MOD":
            return MULADDRSHIFTR_MOD(ctx, instr, loc);
        case "MULADDRSHIFTC_MOD":
            return MULADDRSHIFTC_MOD(ctx, instr, loc);
        case "MULRSHIFT_":
            return MULRSHIFT_(ctx, instr, loc);
        case "MULRSHIFTR_":
            return MULRSHIFTR_(ctx, instr, loc);
        case "MULRSHIFTC_":
            return MULRSHIFTC_(ctx, instr, loc);
        case "MULMODPOW2_":
            return MULMODPOW2_(ctx, instr, loc);
        case "MULMODPOW2R_":
            return MULMODPOW2R_(ctx, instr, loc);
        case "MULMODPOW2C_":
            return MULMODPOW2C_(ctx, instr, loc);
        case "MULRSHIFT_MOD":
            return MULRSHIFT_MOD(ctx, instr, loc);
        case "MULRSHIFTR_MOD":
            return MULRSHIFTR_MOD(ctx, instr, loc);
        case "MULRSHIFTC_MOD":
            return MULRSHIFTC_MOD(ctx, instr, loc);
        case "LSHIFT_ADDDIVMOD":
            return LSHIFT_ADDDIVMOD(ctx, instr, loc);
        case "LSHIFT_ADDDIVMODR":
            return LSHIFT_ADDDIVMODR(ctx, instr, loc);
        case "LSHIFT_ADDDIVMODC":
            return LSHIFT_ADDDIVMODC(ctx, instr, loc);
        case "LSHIFT_DIV":
            return LSHIFT_DIV(ctx, instr, loc);
        case "LSHIFT_DIVR":
            return LSHIFT_DIVR(ctx, instr, loc);
        case "LSHIFT_DIVC":
            return LSHIFT_DIVC(ctx, instr, loc);
        case "LSHIFT_MOD":
            return LSHIFT_MOD(ctx, instr, loc);
        case "LSHIFT_MODR":
            return LSHIFT_MODR(ctx, instr, loc);
        case "LSHIFT_MODC":
            return LSHIFT_MODC(ctx, instr, loc);
        case "LSHIFT_DIVMOD":
            return LSHIFT_DIVMOD(ctx, instr, loc);
        case "LSHIFT_DIVMODR":
            return LSHIFT_DIVMODR(ctx, instr, loc);
        case "LSHIFT_DIVMODC":
            return LSHIFT_DIVMODC(ctx, instr, loc);
        case "HASHEXT":
            return HASHEXT(ctx, instr, loc);
        case "HASHEXTR":
            return HASHEXTR(ctx, instr, loc);
        case "HASHEXTA":
            return HASHEXTA(ctx, instr, loc);
        case "HASHEXTAR":
            return HASHEXTAR(ctx, instr, loc);
        case "STREF":
            return STREF(ctx, instr, loc);
        case "STREF_ALT":
            return STREF_ALT(ctx, instr, loc);
        case "STSLICE":
            return STSLICE(ctx, instr, loc);
        case "STSLICE_ALT":
            return STSLICE_ALT(ctx, instr, loc);
        case "XCHG3":
            return XCHG3(ctx, instr, loc);
        case "XCHG3_ALT":
            return XCHG3_ALT(ctx, instr, loc);
        case "STI":
            return STI(ctx, instr, loc);
        case "STI_ALT":
            return STI_ALT(ctx, instr, loc);
        case "STU":
            return STU(ctx, instr, loc);
        case "STU_ALT":
            return STU_ALT(ctx, instr, loc);
        case "LDI":
            return LDI(ctx, instr, loc);
        case "LDI_ALT":
            return LDI_ALT(ctx, instr, loc);
        case "LDU":
            return LDU(ctx, instr, loc);
        case "LDU_ALT":
            return LDU_ALT(ctx, instr, loc);
        case "LDSLICE":
            return LDSLICE(ctx, instr, loc);
        case "LDSLICE_ALT":
            return LDSLICE_ALT(ctx, instr, loc);
        case "LSHIFT":
            return LSHIFT(ctx, instr, loc);
        case "LSHIFT_1":
            return LSHIFT_1(ctx, instr, loc);
        case "QLSHIFT":
            return QLSHIFT(ctx, instr, loc);
        case "QLSHIFT_1":
            return QLSHIFT_1(ctx, instr, loc);
        case "BCHKBITS":
            return BCHKBITS(ctx, instr, loc);
        case "BCHKBITS_1":
            return BCHKBITS_1(ctx, instr, loc);
        case "BCHKBITSQ":
            return BCHKBITSQ(ctx, instr, loc);
        case "BCHKBITSQ_1":
            return BCHKBITSQ_1(ctx, instr, loc);
        case "RSHIFT":
            return RSHIFT(ctx, instr, loc);
        case "RSHIFT_1":
            return RSHIFT_1(ctx, instr, loc);
        case "RSHIFT_ALT":
            return RSHIFT_ALT(ctx, instr, loc);
        case "QRSHIFT":
            return QRSHIFT(ctx, instr, loc);
        case "QRSHIFT_1":
            return QRSHIFT_1(ctx, instr, loc);
        case "QRSHIFT_ALT":
            return QRSHIFT_ALT(ctx, instr, loc);
        case "CALLDICT":
            return CALLDICT(ctx, instr, loc);
        case "CALLDICT_LONG":
            return CALLDICT_LONG(ctx, instr, loc);
        case "THROW_SHORT":
            return THROW_SHORT(ctx, instr, loc);
        case "THROW":
            return THROW(ctx, instr, loc);
        case "THROWIF_SHORT":
            return THROWIF_SHORT(ctx, instr, loc);
        case "THROWIF":
            return THROWIF(ctx, instr, loc);
        case "THROWIFNOT_SHORT":
            return THROWIFNOT_SHORT(ctx, instr, loc);
        case "THROWIFNOT":
            return THROWIFNOT(ctx, instr, loc);
        case "PUSHINT":
            return PUSHINT(ctx, instr, loc);
        case "PUSHINT_8":
            return PUSHINT_8(ctx, instr, loc);
        case "PUSHINT_16":
            return PUSHINT_16(ctx, instr, loc);
        case "PUSHINT_LONG":
            return PUSHINT_LONG(ctx, instr, loc);
        case "XCHG_LONG":
            return XCHG_LONG(ctx, instr, loc);
        case "XCHG_0":
            return XCHG_0(ctx, instr, loc);
        case "XCHG_1":
            return XCHG_1(ctx, instr, loc);
        case "XCHG_3":
            return XCHG_3(ctx, instr, loc);
        case "DUMPSTK":
            return DUMPSTK(ctx, instr, loc);
        case "DEBUG":
            return DEBUG(ctx, instr, loc);
        case "STRDUMP":
            return STRDUMP(ctx, instr, loc);
        case "DEBUG_1":
            return DEBUG_1(ctx, instr, loc);
        case "DUMP":
            return DUMP(ctx, instr, loc);
        case "DEBUG_2":
            return DEBUG_2(ctx, instr, loc);
        case "PUSHCTR":
            return PUSHCTR(ctx, instr, loc);
        case "PUSH":
            return PUSH(ctx, instr, loc);
        case "PUSH_LONG":
            return PUSH_LONG(ctx, instr, loc);
        case "POPCTR":
            return POPCTR(ctx, instr, loc);
        case "POP":
            return POP(ctx, instr, loc);
        case "POP_LONG":
            return POP_LONG(ctx, instr, loc);
        case "CALLXARGS":
            return CALLXARGS(ctx, instr, loc);
        case "CALLXARGS_1":
            return CALLXARGS_1(ctx, instr, loc);
        case "PUSHSLICE":
            return PUSHSLICE(ctx, instr, loc);
        case "PUSHSLICE_REFS_1":
            return PUSHSLICE_REFS_1(ctx, instr, loc);
        case "PUSHSLICE_LONG_1":
            return PUSHSLICE_LONG_1(ctx, instr, loc);
        case "PUSHCONT":
            return PUSHCONT(ctx, instr, loc);
        case "PUSHCONT_SHORT":
            return PUSHCONT_SHORT(ctx, instr, loc);
        case "STSLICECONST":
            return STSLICECONST(ctx, instr, loc);
        case "SETCP":
            return SETCP(ctx, instr, loc);
        case "SETCP_SHORT":
            return SETCP_SHORT(ctx, instr, loc);
        case "DEBUGMARK":
            return DEBUGMARK(ctx, instr, loc);
    }
    throw new Error(`Unexpected instruction: ${name}`);
};
