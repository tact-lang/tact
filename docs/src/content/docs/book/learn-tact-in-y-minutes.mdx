---
title: Learn Tact in Y minutes
description: "Take a whirlwind tour of the Tact smart contract programming language. A scenic voyage inspired by the famous learnXinYminutes website."
---

Tact is a fresh programming language for TON Blockchain that is focused on efficiency and ease of development. It is a good fit for complex smart contracts, quick onboarding, and rapid prototyping.

You can try Tact without installing anything locally using the [Web IDE](https://ide.ton.org). In addition, most examples below have an "Open in Web IDE" button for your convenience.

## Comments

```tact
// Single-line (//) comments for occasional and casual annotations

/// Documentation comments that support Markdown
```

:::note

  There are also C-like multiline comments `/* ... */`, but their use is discouraged in favor of consecutive single-line documentation comments `///`.

:::

## "Hello, World!" {#hello-world}

```tact
// Defining a contract
contract HelloWorld {
    // Listens to incoming "ping" messages
    receive("ping") {
        // Sends a reply: "pong"
        reply("pong");
    }

    // Listens to incoming "hello" messages
    receive("hello") {
        // Sends a reply: "Hello, World!"
        reply("Hello, World!");
    }
}

// A helper inlined function to send text messages
inline fun reply(with: String) {
    message(MessageParameters{
        to: sender(),
        value: 0,
        mode: SendRemainingValue | SendIgnoreErrors,
        body: with.asComment(),
    });
}
```

:::note

  The text receivers shown above are expensive because they need to hash their contents to differentiate message bodies, and that is a costly operation.

  Later, see examples of cheaper and more controlled binary receivers that expect message structs: [Functions](#functions).

:::

## Primitive types

```tact
// There are two main groups of primitive types on TON: integers and cells.
// All other primitive types are derivatives of those two.

// ---
// Integers,
// always 257-bit signed in runtime operations,
// but may have different lengths in persistent contract's state (storage)
// ---

let one_plus_one: Int = 1 + 1; // 2
let two_by_two: Int = 2 / 2;   // 1
let three_by_two: Int = 3 / 2; // 1, because division operator floors

let one_billion = 1_000_000_000; // decimal
let binary_mask = 0b1_1111_1111; // binary
let permissions = 0o7_5_5;       // octal
let heHex = 0xFF80_0000_0000;    // hexadecimal

let nanoToncoin: Int = 1;    // 1 nanoToncoin = 0.000,000,001 Toncoin
let toncoin: Int = ton("1"); // 1 Toncoin = 1,000,000,000 nanoToncoin


// ---
// Booleans: true and false.
// They take only 1 bit in persistent storage.
// ---

let factual: Bool = !!(true || false);
let fax: Bool = true && factual;


// ---
// Addresses of smart contracts,
// deterministically obtained by combining the initial code and initial data.
// ---

// This is cheap:
let myAddr: Address = myAddress();

// This is very expensive on-chain, so prefer doing such calculations off-chain:
let myAddr2: Address = contractAddress(initOf MyContract());

// The results are the same:
myAddr == myAddr2; // true

// Now, let's convert the Address back to its components:
// * a workchain ID: 8-bit signed Int
// * and an account ID: 256-bit unsigned Int
//
// The workchain IDs in use on mainnet are 0 (basechain) and -1 (masterchain),
// although its possible to have more in the future.
//
// Most contracts operate on the basechain (workchain ID 0).

let addr: Address = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
let addrComponents: StdAddress = parseStdAddress(addr.asSlice());

addrComponents.workchain; // 0
addrComponents.address;   // 107...lots of digits...287

let addr2 = newAddress(addrComponents.workchain, addrComponents.address);
addr2 == addr; // true


// ---
// Cells, Builders, Slices
// ---

// Cell is an immutable data structure that can contain up to 1023 bits
// with up to 4 reference to other cells. Cyclic references are prohibited.
let emptyC: Cell = emptyCell(); // well, cannot do much with that

// Builder is an immutable primitive to construct (compose) cells.
let bb: Builder = beginCell()
    .storeUint(42, 6)  // storing 42 using 6 bits
    .storeInt(42, 7)   // storing 42 using 7 bits (signed Int)
    .storeBool(true)   // writing 1 as a single bit
    .storeBit(true)    // alias to storeBool()
    .storeCoins(40)    // common way of storing nanoToncoins
    .storeAddress(myAddress())
    .storeRef(emptyC); // storing a reference
let composed: Cell = bb.endCell();

// Slice is a mutable primitive to deconstruct (parse) cells.
let target: Slice = composed.asSlice(); // let's start parsing `composed` Cell


// The type ascription is optional for most cases except for maps and optional types,
// but we'll discuss those in the "Composite types" section below.
let fortyTwo = target.loadUint(6); // taking 6 bits out of the `target` Slice,
                                   // mutating it in the process

// If you don't want the result, you can ignore it with a wildcard.
let _ = target.loadInt(7);

// Finally, there are methods to skip the value, i.e., to discard it.
target.skipBool();

// Manual composition and parsing of Cells is tedious,
// error-prone and is generally not recommended.
// Instead, prefer using structures: struct and message struct types.
// See the "Composite types" section below for more info.


// ---
// Strings are immutable sequences of characters,
// which are useful to store texts to be used as special message bodies.
// ---

// String literals are wrapped in double-quotes and can have some escape sequences,
// but they intentionally cannot be concatenated via any operators.
let str: String = "I am a string literal, boo!";
let escape1 = "\\ \" \n \r \t \v \b \f \x00 through \xFF";
let escape2 = "\u0000 through \uFFFF and \u{0} through \u{FFFFFF}";

// Strings are useful for storing text,
// so they can be converted to a Cell type to be used as message bodies.
let noComments: Cell = "yes comments".asComment(); // prefixes a string with 32 zero bits


// ---
// It's cheaper to manipulate and prepare strings off-chain,
// but there are StringBuilders for composing them on-chain.
// ---

// The interfaces look similar to the Builders because, under the hood,
// StringBuilders are just Builders with a different set of functions exposed by Tact.
let sb: StringBuilder = beginString()
    .concat("You can be The Good Guy or the guy who saves the world...")
    .concat("You can't be both");

// You can append something to an existing StringBuilder too.
sb.append(". — Radcliffe");
let fullQuote: String = sb.toString();


// Finally, under the hood, Address and String types are a Slice,
// although with a well-defined distinct data layout for each.
//
// While implicit type conversions aren't allowed in Tact,
// there are extension functions that can be used for those purposes,
// such as String.asSlice() or Address.asSlice().
//
// Advanced users can introduce their own casts by using assembly functions.
// See the "Functions" section below for more info.
```

Read more: [Primitive types](/book/types#primitive-types).

## Composite types

### Optionals {#composite-optionals}

```tact
// An optional is a value than can be of any type or null.
// Null is a special value that represents the intentional absence of any other value.

// Int keys to Int values.
// Type ascription of optionals is mandatory.
let optionalVal: Int? = null;
optionalVal = 255;

// If you're certain that the value isn't null at a given moment,
// use the non-null assertion operator !! to access it.
dump(optionalVal!!);

// Declared but undefined optional variables and fields hold the null value by default.
let veryOptional: Bool?; // null
if (veryOptional != null) {
    // not happening
} else {
    // here we go
}

// You can make almost any variable or field optional by adding a question mark (?)
// after its type declaration. The only exceptions are map<K, V> and bounced<Message>,
// in which you cannot make the inner key/value type (in the case of a map)
// or the inner message struct (in the case of a bounced) optional.
```

Read more: [Optionals](/book/optionals).

### Maps {#composite-maps}

```tact
// The composite type map<K, V> is used to associate
// keys of type K with corresponding values of type V.

// A map of Int keys to Int values.
// Type ascription is mandatory.
let myMap: map<Int, Int> = emptyMap();

// Maps have a number of built-in methods.
myMap.set(0, 10);        // key 0 now points to value 10
myMap.set(0, 42);        // overriding the value under key 0 with 42
myMap.get(0)!!;          // 42, because get can return null if the key doesn't exist
myMap.replace(1, 55);    // false, because there was no key 1 and map didn't change
myMap.replaceGet(0, 10); // 42, because the key 0 exists and the old value there was 42
myMap.get(0)!!;          // 10, since we've just replaced the value with .replaceGet
myMap.del(0);            // true, because the map contained an entry under key 0
myMap.del(0);            // false and not an error, because deletion is idempotent
myMap.exists(0);         // false, there is no entry under key 0
myMap.isEmpty();         // true, there is no other entries

// In most cases, to compare two maps it's sufficient to use the shallow
// comparison via the equality == and inequality != operators.
myMap == emptyMap(); // true

// To traverse maps, the foreach statement is used.
// See the "Statements" section below for more info.
foreach (k, v in myMap) {
    // ...do something for each entry, if any
}

// There are many other allowed kinds of map value types for Int keys
let _: map<Int, Bool> = emptyMap();    // Int keys to Bool values
let _: map<Int, Cell> = emptyMap();    // Ints to Cells
let _: map<Int, Address> = emptyMap(); // Ints to Addresses
let _: map<Int, Struct> = emptyMap();  // Ints to some structs
let _: map<Int, Message> = emptyMap(); // Ints to some message structs

// And all the same value types for maps with Address keys are also allowed.
let _: map<Address, Int> = emptyMap();     // Address keys to Int values
let _: map<Address, Bool> = emptyMap();    // Addresses to Bools
let _: map<Address, Cell> = emptyMap();    // Addresses to Cells
let _: map<Address, Address> = emptyMap(); // Addresses to Addresses
let _: map<Address, Struct> = emptyMap();  // Addresses to some structs
let _: map<Address, Message> = emptyMap(); // Addresses to some message structs

// Under the hood, empty maps are nulls, which is why it's important to provide a type ascription.
let _: map<Int, Int> = null; // like emptyMap(), but less descriptive and generally discouraged

// Furthermore, as with many other types, maps are just Cells with a distinct data layout.
// Therefore, you can type cast any map back to its underlying Cell type.
myMap.asCell();

// To ignore possible differences in serialization logic of maps,
// there is a costly method that is guaranteed to compare correctly.
myMap.deepEquals(emptyMap()); // true, and for the explanation of it see the
                              // relevant section on the maps page in the Book.

// Serialization of integer keys or values is possible but only meaningful
// for maps as fields of structures and maps in the contract's persistent state.
// See the "Structs and message structs" and "Persistent state"
// sections below for more info.

// Finally, mind the limits — maps are quite gas-expensive
// and have an upper limit of around 32k entries for the whole contract.
//
// On TON, contracts are very limited in their state, and for large
// or unbounded (infinitely large) maps, it is better to use contract sharding
// and essentially make the entire blockchain part of your maps.
//
// See this approach in action for the Jetton (token)
// contract system by the end of this tour.
```

Read more:

* [Maps in the Book](/book/maps).
* [Map-based array data structure in the Cookbook](/cookbook/data-structures#array).

### Structs and message structs {#composite-structures}

```tact
// Structs and message structs allow multiple values to be packed together
// in a single type. They are very useful for (de)serialization of Cells
// and for usage as parameters or return types in functions.

// Struct containing a single value
struct One { number: Int; }

// Struct with default fields, fields of optional types, and nested structs
struct Params {
    name: String = "Satoshi"; // default value

    age: Int?; // field with an optional type Int?
               // and an implicit default value of null

    val: One; // nested struct One
}

// You can instruct how to (de)compose the Cells to and from structs
// by specifying certain serialization options after the `as` keyword.
struct SeriesXX {
    i64: Int as int64;  // signed 64-bit integer
    u32: Int as uint32; // unsigned 32-bit integer
    ufo51: Int as uint51; // uneven formats are allowed too,
                          // so this is an unsigned 51-bit integer

    // In general, uint1 through uint256 and int1 through int257
    // are valid serialization formats for integer values.
    maxi: Int as int257; // Int is serialized as int257 by default,
                         // but now it is explicitly specified

    // If this struct will be obtained from some Slice,
    // you can instruct the compiler to place the remainder of that Slice
    // as the last field of the struct, and even type cast the value
    // of that field to Cell, Builder or Slice at runtime.
    lastFieldName: Cell as remaining; // there can only be a single `remaining` field,
                                      // and it must be the last one in the struct
}

// The order of fields matters, as it corresponds to the resulting
// memory layout when the struct will be used to compose a Cell
// or to parse a Slice back to the struct.
struct Order {
    first: Int;     // 257 continuously laid out bits
    second: Cell;   // up to 1023 bits,
                    // which will be placed in a separate ref
                    // when composing a Cell
    third: Address; // 267 bits
}

// Message structs are almost the same as regular structs,
// but they have a 32-bit integer header in their serialization.
// This unique numeric ID is commonly referred to as an opcode (operation code),
// and it allows message structs to be used with special receiver functions
// that distinguish incoming messages based on this ID.
message ImplicitlyAssignedId {} // no fields,
                                // but not empty because of the automatically
                                // generated and implicitly set 32-bit Int opcode

// You can manually override an opcode with any compile-time expression
// that evaluates to a non-negative 32-bit integer.

// This message has an opcode of 898001897, which is the evaluated
// integer value of the specified compile-time expression.
message((crc32("Tact") + 42) & 0xFFFF_FFFF) MsgWithExprOpcode {
    // All the contents are defined identical to regular structs.
    field1: Int as uint4;         // serialization
    field2: Bool?;                // optionals
    field3: One;                  // nested structs
    field4: ImplicitlyAssignedId; // nested message structs
}

// Some usage examples.
fun usage() {
    // Instantiation of a struct.
    // Notice the lack of the "new" keyword used for this in many
    // other traditional languages.
    let val: One = One{ number: 50 };

    // You can omit the fields with default values.
    let _ = Params{ val }; // the field punning works —
                           // instead of `val: val` you could write just `val`

    // Convert a struct to a Cell or a Slice.
    let valCell = val.toCell();
    let valSlice = val.toSlice();

    // Obtain a struct from a Cell or a Slice.
    let _ = One.fromCell(valCell);
    let _ = One.fromSlice(valSlice);

    // Conversion works both ways.
    One.fromCell(val.toCell()).toCell() == valCell;
    One.fromSlice(val.toSlice()).toSlice() == valSlice;
}
```

Read more: [Structs and Messages](/book/structs-and-messages).

## Operators

```tact
// Let's omit the type ascriptions and let the compiler infer the types.
let five = 5; // = is an assignment operator,
              // but it can be a part of the assignment statement only,
              // because there is no assignment expression
let four = 4;

// Most operators below have augmented assignment versions, like +=, -=, etc.
// See the "Statements" section below for more info.

// Common arithmetic operators have predictable precedences.
five + four - five * four / five % four; // 9

// You can change order of operations with parentheses.
(five + (four - five)) * four / (five % four); // 16

// The % is the modulo, not the remainder operator.
1 % five;  // 1
1 % -five; // -4

// Negation and bitwise NOT.
-five;    // -5: negation of 5
~five;    // -6: bitwise NOT of 5
-(~five); // 6: bitwise NOT, then negation
~(-five); // 4: negation, then bitwise NOT

// Bitwise shifts.
five << 2; // 20
four >> 2; // 1
-four >> 2; // -1, because negation is applied first
            // and >> performs arithmetic or sign-propagating right shift

// Other common bitwise operators.
five & four; // 4, due to bitwise AND
five | four; // 5, due to bitwise OR
five ^ four; // 1, due to bitwise XOR

// Relations.
five == four;     // false
five != four;     // true
five > four;      // true
five < four;      // false
five - 1 >= four; // true
five - 1 <= four; // true

// Logical checks.
!(five == 5);       // false, because of the inverse ! operator
false && five == 5; // false, because && is short-circuited
true || five != 5;  // true, because || is also short-circuited

// Non-null assertion operator raises
// a compilation error if the value is null, but does nothing otherwise.
five!!; // 5

// Ternary operator ?: is right-associative.
false ? 1 : (false ? 2 : 3); // 3
false ? 1 : true ? 2 : 3;    // 2
```

Read more: [Operators](/book/operators).

## Expressions

```tact /StdAddress/
// Integer literals.
0; 42; 1_000; 020; // decimal, base 10
0xABC; 0xf; 0x001; // hexadecimal, base 16
0o777; 0o00000001; // octal, base 8
0b111010101111010; // binary, base 2

// Boolean literals.
true; false;

// String literals.
"foo"; "1234";
"\\ \" \n \r \t \v \b \f \x00 through \xFF";
"\u0000 through \uFFFF and \u{0} through \u{FFFFFF}";

// `null` and `self` literals.
null; // not an instance of a primitive type, but
      // a special value that represents the intentional absence
      // of any other value

self; // used to reference the current contract from within
      // and the value of the currently extended type inside
      // the extension function. See "Functions" section below for more.

// Identifiers, with usual naming conventions:
// They may contain Latin lowercase letters `a-z`,
// Latin uppercase letters `A-Z`, underscores `_`,
// and digits 0 - 9, but may not start with a digit.
// No other symbols are allowed, and Unicode identifiers are prohibited.
// They also cannot start with __gen or __tact since those prefixes
// are reserved by the Tact compiler.
azAZ09_;

// Instantiations or instance expressions of structs and message structs.
let addr = BasechainAddress{ hash: null, };

// Field access.
addr.hash; // null
self.storageReserve; // 0, a contract-level constant present in all contracts,
                     // because they implicitly inherit the BaseTrait
                     // that defines it.

// Extension function calls (methods).
self.storageReserve.toString(); // "0"
self.notify("Cashback".asComment()); // rather expensive,
                                     // use cashback() instead
"hey".asComment(); // allowed on literals

// Global function calls.
now(); // UNIX timestamp in seconds
cashback(sender());

// Some of the functions can be computed at compile-time given enough data.
sha256("hey, I'll produce the SHA256 number at compile-time");

// But there are special, compile-time-only functions.
let _: Address = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
let _: Cell = cell("");
let _: Slice = slice("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="); // a Slice with Hello world!
let _: Slice = rawSlice("000DEADBEEF000"); // CS{Cell{03f...430} bits: 588..644; refs: 1..1}
let _: Int = ascii("⚡"); // 14850721 or 0xE29AA1, 3 bytes in total
let _: Int = crc32("000DEADBEEF000"); // 1821923098
let _: Int = ton("1"); // 10^9 nanoToncoin, which is equivalent to one Toncoin,
                       // the main currency of TON Blockchain

// initOf, which obtains the initial code and initial data
// of the given contract, i.e., it's initial state.
initOf MyContract(); // StateInit{ code, data }

// codeOf, which only obtains the code.
codeOf MyContract;
```

Read more: [Expressions](/book/expressions).

## Statements and control flow {#statements}

```tact
// TODO: ... + + exit codes and try-catch (may be separated then)
// assignments and augmented assignments
// (move notes here!)
```

Read more: [Statements](/book/statements).

## Constants

```tact
// TODO: with a note on contract constants (later)
// (move notes here!)
```

Read more: [Constants](/book/constants).

## Functions

```tact
// TODO: ... + get fun, receive() {}
// (move notes here!)
```

Read more: [Functions](/book/functions).

## Contracts and traits

```tact
// TODO: move notes here
// TODO: contract structure
// TODO: traits
```

## Persistent state {#state}

```tact
// Contracts can define state variables that persist between contract calls,
// and thus commonly referred to as _storage_ variables.
// Contracts in TON pay rent in proportion to the amount of persistent space they consume,
// so compact representations via serialization are encouraged.

contract StateActor(
    // Persistent state variables
    // TODO: ...serialization options
) {

    // Contract constants, which do not consume space
    // in the persistent state — their values are always inlined in expressions
    // TODO: ...

    // TODO: a major point about runtime -- Int 257, etc.
    // Like, serialization formats only work for the state / incoming and outgoing messages,
    // but does not apply to the runtime stuff.
}
```

## TODO something about gas usage {#gas}

## Message exchange

```tact
// TODO: ... + message sending + reserve + receiving messages + refunds + child-parent interactions (or earlier)
// (move notes here!)
```

## Deployment

```tact
// TODO: ... + deploy + initOf + seqno/id
// (move notes here!)
```

## Debugging

```tact
// TODO: require, throw, emit, etc.
```

## Example contracts {#examples}

Let's put our newly acquired information of syntax and some semantics to the test.

### Counter contract {#examples-counter}

```tact
// Defining a new Message type, which has one field
// and an automatically assigned 32-bit opcode prefix
message Add {
    // unsigned integer value stored in 4 bytes
    amount: Int as uint32;
}

// Defining a contract
contract SimpleCounter(
    // Persistent state variables of the contract:
    counter: Int as uint32, // actual value of the counter
    id: Int as uint32, // a unique id to deploy multiple instances
                       // of this contract in a same workchain
    // their default or initial values are supplied during deployment
) {
    // Register a receiver of empty messages from other contracts.
    // It handles all messages with `null` body
    // and is very handy and cheap for the deployments.
    receive() {
        // Forward the remaining value in the
        // incoming message back to the sender
        cashback(sender());
    }

    // Register a binary receiver of the Add message body.
    // TODO: return to this in a short while
    // Receivers can Messages in Tact can be one of the two:
    // 1. Message type, as defined above
    // 2. String type, like "I am the message!"
    // 3. Raw Slice message, we'll get to it later
    receive(msg: Add) {
        self.counter += msg.amount; // <- increase the counter
        // Notify the caller that the receiver was executed and forward remaining value back
        self.notify("Cashback".asComment());
    }

    // This is a getter function, which are special external interface functions
    // that allow users to query information from the contract.
    get fun counter(): Int {
        return self.counter; // <- return the counter value
    }

    // Another getter function, but for the id:
    get fun id(): Int {
        return self.id; // <- return the id value
    }
}
```

### Jetton contracts {#examples-jetton}

The tokens on TON Blockchain are commonly called Jettons. The distinction is made because they work differently from ERC-20 tokens or others.

This is due to the scalable and distributed approach that works best on TON: instead of having a single giant contract with a big hashmap of addresses of token holders, Jettons instead have a single minter contract that creates individual contracts called Jetton wallets per each holder.

For more, refer to the following resources:

* [TON Jettons Processing](https://docs.ton.org/v3/guidelines/dapps/asset-processing/jettons) in TON Docs.
* Jetton standards: [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md), [TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md), and [TEP-89](https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md).

#### JettonWallet

```tact
// Child contract per each holder of N amount of given Jetton
contract JettonWallet(
    balance: Int as coins,
    owner: Address,
    master: Address,
) {
    receive(msg: JettonTransfer) {
        require(parseStdAddress(msg.destination.asSlice()).workchain == 0, "Invalid destination workchain");
        require(sender() == self.owner, "Incorrect sender");

        self.balance -= msg.amount;
        require(self.balance >= 0, "Incorrect balance after send");
        require(msg.forwardPayload.bits() >= 1, "Invalid forward payload");

        let ctx = context();
        let fwdCount = 1 + sign(msg.forwardTonAmount); // msg.forwardTonAmount is coins, so it's positive
        require(ctx.value >
            msg.forwardTonAmount +
            fwdCount * ctx.readForwardFee() +
            (2 * getComputeFee(gasForTransfer, false) + minTonsForStorage),
            "Insufficient amount of TON attached"
        );

        deploy(DeployParameters{
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: JettonTransferInternal{
                queryId: msg.queryId,
                amount: msg.amount,
                sender: self.owner,
                responseDestination: msg.responseDestination,
                forwardTonAmount: msg.forwardTonAmount,
                forwardPayload: msg.forwardPayload,
            }.toCell(),
            init: initOf JettonWallet(0, msg.destination, self.master),
        });
    }

    receive(msg: JettonTransferInternal) {
        self.balance += msg.amount;

        // This message should come only from master, or from other JettonWallet
        let wallet: StateInit = initOf JettonWallet(0, msg.sender, self.master);
        if (sender() != contractAddress(wallet)) {
            require(self.master == sender(), "Incorrect sender");
        }

        let ctx: Context = context();
        let msgValue: Int = ctx.value;
        let tonBalanceBeforeMsg = myBalance() - msgValue;

        if (msg.forwardTonAmount > 0) {
            let fwdFee: Int = ctx.readForwardFee();
            msgValue -= msg.forwardTonAmount + fwdFee;
            message(MessageParameters{
                to: self.owner,
                value: msg.forwardTonAmount,
                mode: SendPayGasSeparately,
                bounce: false,
                body: JettonNotification{ // 0x7362d09c -- Remind the new Owner
                    queryId: msg.queryId,
                    amount: msg.amount,
                    sender: msg.sender,
                    forwardPayload: msg.forwardPayload,
                }.toCell(),
            });
        }
        nativeReserve(max(tonBalanceBeforeMsg, minTonsForStorage), ReserveAtMost);
        // 0xd53276db -- Cashback to the original Sender
        if (msg.responseDestination != null && msgValue > 0) {
            message(MessageParameters{
                to: msg.responseDestination!!,
                value: msgValue,
                mode: SendRemainingBalance + SendIgnoreErrors,
                bounce: false,
                body: JettonExcesses{ queryId: msg.queryId }.toCell(),
            });
        }
    }

    receive(msg: JettonBurn) {
        require(sender() == self.owner, "Incorrect sender");

        self.balance -= msg.amount;
        require(self.balance >= 0, "Incorrect balance after send");

        let ctx = context();
        let fwdFee: Int = ctx.readForwardFee();
        require(ctx.value > (fwdFee + 2 * getComputeFee(gasForBurn, false)), "Insufficient amount of TON attached");

        message(MessageParameters{
            to: self.master,
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: JettonBurnNotification{
                queryId: msg.queryId,
                amount: msg.amount,
                sender: self.owner,
                responseDestination: msg.responseDestination,
            }.toCell(),
        });
    }

    bounced(msg: bounced<JettonTransferInternal>) { self.balance += msg.amount; }

    bounced(msg: bounced<JettonBurnNotification>) { self.balance += msg.amount; }

    get fun get_wallet_data(): JettonWalletData {
        return JettonWalletData{
            balance: self.balance,
            owner: self.owner,
            master: self.master,
            code: myCode()
        };
    }
}

//
// Helper structs, message structs and constants,
// which would otherwise be imported from another file
//

struct JettonWalletData {
    balance: Int;
    owner: Address;
    master: Address;
    code: Cell;
}

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell?;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

message(0x178d4519) JettonTransferInternal {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    responseDestination: Address?;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

message(0x7362d09c) JettonNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}

message(0x595f07bc) JettonBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    responseDestination: Address?;
    customPayload: Cell?;
}

message(0x7bdd97de) JettonBurnNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    responseDestination: Address?;
}

message(0xd53276db) JettonExcesses {
    queryId: Int as uint64;
}

const gasForBurn: Int = 6000;
const gasForTransfer: Int = 8000;
const minTonsForStorage: Int = ton("0.01");
```

#### JettonMinter

It is a parent contract that deploys individual [Jetton wallets](#jettonwallet) per each holder.

See: [`JettonMinter` in tact-lang/jetton repository](https://github.com/tact-lang/jetton/blob/main/sources/jetton_minter_discoverable.tact).
