---
title: Learn Tact in Y minutes
description: "Take a whirlwind tour of the Tact smart contract programming language. A scenic voyage inspired by the famous learnXinYminutes website."
---

Tact is a fresh programming language for TON Blockchain that is focused on efficiency and ease of development. It is a good fit for complex smart contracts, quick onboarding, and rapid prototyping.

You can try Tact without installing anything locally using the [Web IDE](https://ide.ton.org). In addition, most examples below have an "Open in Web IDE" button for your convenience.

## Comments

```tact
// Single-line (//) comments for occasional and casual annotations

/// Documentation comments that support Markdown
```

:::note

  There are also C-like multiline comments `/* ... */`, but their use is discouraged in favor of consecutive single-line documentation comments `///`.

:::

## "Hello, World!" {#hello-world}

```tact
// Defining a contract
contract HelloWorld {
    // Listens to incoming "ping" messages
    receive("ping") {
        // Sends a reply: "pong"
        reply("pong");
    }

    // Listens to incoming "hello" messages
    receive("hello") {
        // Sends a reply: "Hello, World!"
        reply("Hello, World!");
    }
}

// A helper inlined function to send text messages
inline fun reply(with: String) {
    message(MessageParameters{
        to: sender(),
        value: 0,
        mode: SendRemainingValue | SendIgnoreErrors,
        body: with.asComment(),
    });
}
```

:::note

  The text receivers shown above are expensive because they need to hash their contents to differentiate message bodies, and that is a costly operation.

  Later, see examples of cheaper and more controlled binary receivers that expect message structs: [Functions](#functions).

:::

## Primitive types

```tact
// There are two main groups of primitive types on TON: integers and cells.
// All other primitive types are derivatives of those two.

// ---
// Integers,
// always 257-bit signed in runtime operations,
// but may have different lengths in persistent contract's state (storage)
// ---

let one_plus_one: Int = 1 + 1; // 2
let two_by_two: Int = 2 / 2;   // 1
let three_by_two: Int = 3 / 2; // 1, because division operator floors

let one_billion = 1_000_000_000; // decimal
let binary_mask = 0b1_1111_1111; // binary
let permissions = 0o7_5_5;       // octal
let heHex = 0xFF80_0000_0000;    // hexadecimal

let nanoToncoin: Int = 1;    // 1 nanoToncoin = 0.000,000,001 Toncoin
let toncoin: Int = ton("1"); // 1 Toncoin = 1,000,000,000 nanoToncoin


// ---
// Booleans: true and false.
// They take only 1 bit in persistent storage.
// ---

let factual: Bool = !!(true || false);
let fax: Bool = true && factual;


// ---
// Addresses of smart contracts,
// deterministically obtained by combining the initial code and initial data.
// ---

// This is cheap:
let myAddr: Address = myAddress();

// This is very expensive on-chain, so prefer doing such calculations off-chain:
let myAddr2: Address = contractAddress(initOf MyContract());

// The results are the same:
myAddr == myAddr2; // true

// Now, let's convert the Address back to its components:
// * a workchain ID: 8-bit signed Int
// * and an account ID: 256-bit unsigned Int
//
// The workchain IDs in use on mainnet are 0 (basechain) and -1 (masterchain),
// although its possible to have more in the future.
//
// Most contracts operate on the basechain (workchain ID 0).

let addr: Address = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
let addrComponents: StdAddress = parseStdAddress(addr.asSlice());

addrComponents.workchain; // 0
addrComponents.address;   // 107...lots of digits...287

let addr2 = newAddress(addrComponents.workchain, addrComponents.address);
addr2 == addr; // true


// ---
// Cells, Builders, Slices
// ---

// Cell is an immutable data structure that can contain up to 1023 bits
// with up to 4 reference to other cells. Cyclic references are prohibited.
let emptyC: Cell = emptyCell(); // well, cannot do much with that

// Builder is an immutable primitive to construct (compose) cells.
let bb: Builder = beginCell()
    .storeUint(42, 6)  // storing 42 using 6 bits
    .storeInt(42, 7)   // storing 42 using 7 bits (signed Int)
    .storeBool(true)   // writing 1 as a single bit
    .storeBit(true)    // alias to storeBool()
    .storeCoins(40)    // common way of storing nanoToncoins
    .storeAddress(myAddress())
    .storeRef(emptyC); // storing a reference
let composed: Cell = bb.endCell();

// Slice is a mutable primitive to deconstruct (parse) cells.
let target: Slice = composed.asSlice(); // let's start parsing `composed` Cell


// The type ascription is optional for most cases except for maps and optional types,
// but we'll discuss those in the "Composite types" section below.
let fortyTwo = target.loadUint(6); // taking 6 bits out of the `target` Slice,
                                   // mutating it in the process

// If you don't want the result, you can ignore it with a wildcard.
let _ = target.loadInt(7);

// Finally, there are methods to skip the value, i.e., to discard it.
target.skipBool();

// Manual composition and parsing of Cells is tedious,
// error-prone and is generally not recommended.
// Instead, prefer using structures: struct and message struct types.
// See "Composite types" section below for more info.


// ---
// Strings are immutable sequences of characters,
// which are useful to store texts to be used as special message bodies.
// ---

// String literals are wrapped in double-quotes and can have some escape sequences,
// but they intentionally cannot be concatenated via any operators.
let str: String = "I am a string literal, boo!";
let escape1 = "\\ \" \n \r \t \v \b \f \x00 through \xFF";
let escape2 = "\u0000 through \uFFFF and \u{0} through \u{FFFFFF}";

// Strings are useful for storing text,
// so they can be converted to a Cell type to be used as message bodies.
let noComments: Cell = "yes comments".asComment(); // prefixes a string with 32 zero bits


// ---
// It's cheaper to manipulate and prepare strings off-chain,
// but there are StringBuilders for composing them on-chain.
// ---

// The interfaces look similar to the Builders because, under the hood,
// StringBuilders are just Builders with a different set of functions exposed by Tact.
let sb: StringBuilder = beginString()
    .concat("You can be The Good Guy or the guy who saves the world...")
    .concat("You can't be both");

// You can append something to an existing StringBuilder too.
sb.append(". — Radcliffe");
let fullQuote: String = sb.toString();


// Finally, under the hood, Address and String types are a Slice,
// although with a well-defined distinct data layout for each.
//
// While implicit type conversions aren't allowed in Tact,
// there are extension functions that can be used for those purposes,
// such as String.asSlice() or Address.asSlice().
//
// Advanced users can introduce their own casts by using assembly functions.
// See "Functions" section below for more info.
```

Read more: [Primitive types](/book/types#primitive-types).

## Composite types

### Optionals {#composite-optionals}

```tact
// TODO:
// (move notes here!)
```

Read more: [Optionals](/book/optionals).

### Maps {#composite-maps}

```tact
// TODO:
// (move notes here!)
```

Read more: [Maps](/book/maps).

### Structs and Messages {#composite-structures}

```tact
// TODO
// (move notes here!)
```

Read more: [Structs and Messages](/book/structs-and-messages).

## Operators

```tact
// Unary postfix  !!
// Unary prefix   !  ~
// Multiplicative *   /   %
// Additive       +   -
// Equality       ==  !=
// Bitwise AND    &
// Bitwise XOR    ^
// Bitwise OR     |
// Logical AND    &&
// Logical OR     ||
// Ternary        ?:
// Assignment     = and augmented assignment operators

// Let's omit the type ascriptions and let the compiler infer the types
let a = 5;
let b = 4;

// Common arithmetic operators have predictable precedences
a + b - a * b / a % b; // 9

// You can change order of operations with parentheses
(a + (b - a)) * b / (a % b); // 16

// The % is the modulo, not the remainder operator
1 % a;  // 1
1 % -a; // -4

// Shifts
a << 2; // 20
b >> 2; // 1

// Relations
// > >= < <=

// Logical checks
// !, !!, &&, ||, ==, !=

// ...

// Most of the above have augmented assignment versions,
// see the "Statements" section below.

// TODO:...
```

Read more: [Operators](/book/operators).

## Expressions

```tact
// TODO: ... + now, require, send (first use)
// (move notes here!)
```

Read more: [Expressions](/book/expressions).

## Statements

```tact
// TODO: ... + + exit codes and try-catch (may be separated then)
// (move notes here!)
```

Read more: [Statements](/book/statements).

## Constants

```tact
// TODO: with a note on contract constants (later)
// (move notes here!)
```

Read more: [Constants](/book/constants).

## Functions

```tact
// TODO: ... + get fun, receive() {}
// (move notes here!)
```

Read more: [Functions](/book/functions).

## Persistent state {#state}

```tact
// Contracts can define state variables that persist between contract calls, and thus commonly referred to as _storage_ variables.
// Contracts in TON pay rent in proportion to the amount of persistent space they consume, so compact representations via serialization are encouraged.

contract StateActor(
    // Persistent state variables
    // TODO: ...
) {

    // Contract constants, which do not consume space
    // in the persistent state — their values are always inlined in expressions
    // TODO: ...
}
```

## Contract structure {#contract}

```tact
// TODO: move notes here
```

## Deployment

```tact
// TODO: ... + deploy + initOf + seqno/id
// (move notes here!)
```

## Debugging

// TODO: require, throw, emit, etc.

## Message exchange

```tact
// TODO: ... + message sending + reserve + receiving messages + refunds + child-parent interactions (or earlier)
// (move notes here!)
```

## Example contracts {#examples}

Let's put our newly acquired information of syntax and some semantics to the test.

### Counter contract {#examples-counter}

```tact
// Defining a new Message type, which has one field
// and an automatically assigned 32-bit opcode prefix
message Add {
    // unsigned integer value stored in 4 bytes
    amount: Int as uint32;
}

// Defining a contract
contract SimpleCounter(
    // Persistent state variables of the contract:
    counter: Int as uint32, // actual value of the counter
    id: Int as uint32, // a unique id to deploy multiple instances
                       // of this contract in a same workchain
    // their default or initial values are supplied during deployment
) {
    // Register a receiver of empty messages from other contracts.
    // It handles all messages with `null` body
    // and is very handy and cheap for the deployments.
    receive() {
        // Forward the remaining value in the
        // incoming message back to the sender
        cashback(sender());
    }

    // Register a binary receiver of the Add message body.
    // TODO: return to this in a short while
    // Receivers can Messages in Tact can be one of the two:
    // 1. Message type, as defined above
    // 2. String type, like "I am the message!"
    // 3. Raw Slice message, we'll get to it later
    receive(msg: Add) {
        self.counter += msg.amount; // <- increase the counter
        // Notify the caller that the receiver was executed and forward remaining value back
        self.notify("Cashback".asComment());
    }

    // This is a getter function, which are special external interface functions
    // that allow users to query information from the contract.
    get fun counter(): Int {
        return self.counter; // <- return the counter value
    }

    // Another getter function, but for the id:
    get fun id(): Int {
        return self.id; // <- return the id value
    }
}
```

### Jetton contracts {#examples-jetton}

The tokens on TON Blockchain are commonly called Jettons. The distinction is made because they work differently from ERC-20 tokens or others.

This is due to the scalable and distributed approach that works best on TON: instead of having a single giant contract with a big hashmap of addresses of token holders, Jettons instead have a single minter contract that creates individual contracts called Jetton wallets per each holder.

For more, refer to the following resources:

* [TON Jettons Processing](https://docs.ton.org/v3/guidelines/dapps/asset-processing/jettons) in TON Docs.
* Jetton standards: [TEP-64](https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md), [TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md), and [TEP-89](https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md).

#### JettonWallet

```tact
// Child contract per each holder of N amount of given Jetton
contract JettonWallet(
    balance: Int as coins,
    owner: Address,
    master: Address,
) {
    receive(msg: JettonTransfer) {
        require(parseStdAddress(msg.destination.asSlice()).workchain == 0, "Invalid destination workchain");
        require(sender() == self.owner, "Incorrect sender");

        self.balance -= msg.amount;
        require(self.balance >= 0, "Incorrect balance after send");
        require(msg.forwardPayload.bits() >= 1, "Invalid forward payload");

        let ctx = context();
        let fwdCount = 1 + sign(msg.forwardTonAmount); // msg.forwardTonAmount is coins, so it's positive
        require(ctx.value >
            msg.forwardTonAmount +
            fwdCount * ctx.readForwardFee() +
            (2 * getComputeFee(gasForTransfer, false) + minTonsForStorage),
            "Insufficient amount of TON attached"
        );

        deploy(DeployParameters{
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: JettonTransferInternal{
                queryId: msg.queryId,
                amount: msg.amount,
                sender: self.owner,
                responseDestination: msg.responseDestination,
                forwardTonAmount: msg.forwardTonAmount,
                forwardPayload: msg.forwardPayload,
            }.toCell(),
            init: initOf JettonWallet(0, msg.destination, self.master),
        });
    }

    receive(msg: JettonTransferInternal) {
        self.balance += msg.amount;

        // This message should come only from master, or from other JettonWallet
        let wallet: StateInit = initOf JettonWallet(0, msg.sender, self.master);
        if (sender() != contractAddress(wallet)) {
            require(self.master == sender(), "Incorrect sender");
        }

        let ctx: Context = context();
        let msgValue: Int = ctx.value;
        let tonBalanceBeforeMsg = myBalance() - msgValue;

        if (msg.forwardTonAmount > 0) {
            let fwdFee: Int = ctx.readForwardFee();
            msgValue -= msg.forwardTonAmount + fwdFee;
            message(MessageParameters{
                to: self.owner,
                value: msg.forwardTonAmount,
                mode: SendPayGasSeparately,
                bounce: false,
                body: JettonNotification{ // 0x7362d09c -- Remind the new Owner
                    queryId: msg.queryId,
                    amount: msg.amount,
                    sender: msg.sender,
                    forwardPayload: msg.forwardPayload,
                }.toCell(),
            });
        }
        nativeReserve(max(tonBalanceBeforeMsg, minTonsForStorage), ReserveAtMost);
        // 0xd53276db -- Cashback to the original Sender
        if (msg.responseDestination != null && msgValue > 0) {
            message(MessageParameters{
                to: msg.responseDestination!!,
                value: msgValue,
                mode: SendRemainingBalance + SendIgnoreErrors,
                bounce: false,
                body: JettonExcesses{ queryId: msg.queryId }.toCell(),
            });
        }
    }

    receive(msg: JettonBurn) {
        require(sender() == self.owner, "Incorrect sender");

        self.balance -= msg.amount;
        require(self.balance >= 0, "Incorrect balance after send");

        let ctx = context();
        let fwdFee: Int = ctx.readForwardFee();
        require(ctx.value > (fwdFee + 2 * getComputeFee(gasForBurn, false)), "Insufficient amount of TON attached");

        message(MessageParameters{
            to: self.master,
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: JettonBurnNotification{
                queryId: msg.queryId,
                amount: msg.amount,
                sender: self.owner,
                responseDestination: msg.responseDestination,
            }.toCell(),
        });
    }

    bounced(msg: bounced<JettonTransferInternal>) { self.balance += msg.amount; }

    bounced(msg: bounced<JettonBurnNotification>) { self.balance += msg.amount; }

    get fun get_wallet_data(): JettonWalletData {
        return JettonWalletData{
            balance: self.balance,
            owner: self.owner,
            master: self.master,
            code: myCode()
        };
    }
}

//
// Helper structs, message structs and constants,
// which would otherwise be imported from another file
//

struct JettonData { totalSupply: Int; mintable: Bool; owner: Address; content: Cell; jettonWalletCode: Cell; }

struct JettonWalletData { balance: Int; owner: Address; master: Address; code: Cell; }

struct MaybeAddress { address: Address?; }

message(4) JettonUpdateContent {
    queryId: Int as uint64;
    content: Cell;
}

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell?;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

message(0x178d4519) JettonTransferInternal {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    responseDestination: Address?;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

message(0x7362d09c) JettonNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}

message(0x595f07bc) JettonBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    responseDestination: Address?;
    customPayload: Cell?;
}

message(0x7bdd97de) JettonBurnNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    responseDestination: Address?;
}

message(0xd53276db) JettonExcesses {
    queryId: Int as uint64;
}

message(0x2c76b973) ProvideWalletAddress {
    queryId: Int as uint64;
    ownerAddress: Address;
    includeAddress: Bool;
}

message(0xd1735400) TakeWalletAddress {
    queryId: Int as uint64;
    walletAddress: Address;
    ownerAddress: Cell?;
}

message(21) Mint {
    queryId: Int as uint64;
    receiver: Address;
    tonAmount: Int as coins;
    mintMessage: JettonTransferInternal;
}

message(22) CloseMinting {}

message(3) ChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}

const gasForBurn: Int = 6000;
const gasForDiscovery: Int = 6500;
const gasForTransfer: Int = 8000;
const minTonsForStorage: Int = ton("0.01");
```

#### JettonMinter

It is a parent contract that deploys individual [Jetton wallets](#jettonwallet) per each holder.

See: [`JettonMinter` in tact-lang/jetton repository](https://github.com/tact-lang/jetton/blob/main/sources/jetton_minter_discoverable.tact).
