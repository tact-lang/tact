---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters and storage functions, plus the many attributes that allow for great flexibility and expressivity of Tact language"
---

import { Badge } from '@astrojs/starlight/components';

Functions in Tact could be defined in different ways:

* Global static function
* Extension functions
* Mutation functions
* Native functions
* [Assembly functions](#asm)
* [Internal functions](/book/contracts#internal-functions)
* Receiver functions
* Getter functions

All functions, except for [receiver functions](#receiver-functions) can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

## Global static functions

You can define global function anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Virtual and abstract functions

You can allow the contract inheriting a [traits](/book/types#traits) to modify an internal function, if it has the `virtual{:tact}` keyword, using `override{:tact}`. The function can be also marked as `abstract{:tact}`, in which case the inheriting contract has to define its implementation:

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Overriding default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
````

## Extension function

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The name of the first argument MUST be named `self` and the type of this argument is the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Mutation functions

Mutation functions are performing mutation of a value replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Native functions

Native functions are direct bindings of FunC functions:

> **Note**
> Native functions could also be mutation and extension ones.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Assembly functions, `asm` {#asm}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

:::caution

  These are very advanced functions that require experience and vigilance in both definitions and usage. The logical errors in them are extremely hard to spot, the error messages are abysmal, and type checking isn't currently provided by Tact.

  That said, if you know what you're doing, they can offer you the smallest possible gas usage, the best performance and the most control over [TVM][tvm] execution. Remember — with great power comes great responsibility.

:::

Assembly functions (or `asm{:tact}` functions for short) are module-level functions that allow writing [Fift and TVM assembly](https://docs.ton.org/v3/documentation/smart-contracts/fift/fift-and-tvm-assembly) directly in Tact. Unlike all other functions, their bodies consist only of [Fift words][fift] and [TVM instructions][tvm-instructions], and don't use any [Tact statements](/book/statements).

```tact
// all assembly functions must start with "asm" keyword
// ↓
   asm fun answer(): Int { 42 INT }
//                         ------
//                         Notice, that the body contains
//                         only Fift words or TVM instructions
```

### Caveats {#asm-caveats}

The difference between Fift words and TVM instructions is that words are processed and computed at [compile-time](/ref/core-comptime), while instructions are converted to opcodes and embedded into the contract as part of its code. They are also visually different: TVM instructions are almost all uppercase.

```tact
/// Defines ++ word to be used elsewhere
asm fun definePlusPlus() {
    {   // Fift word, opens the definition of a new word
    INC // TVM instruction, increment
    }   // Fift word, closes the definition of a new word
    :   // Fift word, assigns the resulting definition
    ++  // A name for the new Fift word
}

/// Increments an Int and requires the `definePlusPlus()` to be called
/// at least once prior to calling this function!
asm fun inc(x: Int): Int { ++ }
//                         --
//                         Fift word, that is substituted with
//                         INC instruction at compile-time,
//                         which is then executed at run-time
//                         with the "x" as a parameter

/// Computes the Answer to Ultimate Question of Life, Universe and Everything
fun answer(): Int {
    // Since Fift allows silent shadowing,
    // defining ++ multiple times over is possible,
    // but beware — you can totally break anything
    // that way if not careful enough with the names
    definePlusPlus();
    definePlusPlus();
    definePlusPlus();

    // Now, let's use the ++
    return inc(41); // 42
}
```

:::caution

  Prefer to use _only_ [TVM instructions][tvm-instructions] only and _never_ define new Fift words or use existing ones, since it's very easy to confuse compile-time and run-time execution and forget which stack is used where and when — Fift's or TVM's.

:::

It is not necessary to enclose TVM instructions in double quotes. On the contrary, they are interpreted by Fift as strings, which is probably _not_ what you want:

```tact
// Puts the string "MYCODE" on Fift's stack at compile-time,
// where it gets discarded even before the compute phase starts
asm fun wrongMyCode() { "MYCODE" }

// Invokes the TVM instruction MYCODE during the compute phase,
// which returns the contract code as a Cell
asm fun myCode(): Cell { MYCODE }
```

The syntax for parameters and return values is the same as for other function kinds, but there is one caveat — argument values are pushed to the stack before the function body is executed, and return values are what's left on the stack afterward.

Since the bodies of `asm{:tact}` functions do not contain Tact statements, any direct references to parameters in function bodies will be recognized as Fift words, which can easily lead to very obscure error messages.

```tact
/// Simply returns back the value of `x`
asm fun identity(x: Int): Int { }

/// COMPILATION ERROR!
/// You could've thought that you're providing the value of `boc` to the function
/// and receiving it back, but actually there's a builtin Fift word `boc` which is
/// being used instead.
/// The `boc` would not be recognized as a parameter
/// even if such word didn't exist in Fift!
asm fun bocchiThe(boc: Cell): Cell { boc }

/// Loads a signed `l`-bit integer from Slice `s`,
/// and returns it with the remainder of `s`
asm fun sliceLoadInt(s: Slice, l: Int): IntSlice { LDIX }
//                   ↑         ↑
//                   |         Placed on the stack last
//                   Placed on the stack first

// Used to map onto values placed by LDIX on the stack
struct IntSlice { a: Int; b: Slice }
```

### Arrangements {#asm-arrangements}

Sometimes it's useful to change the order of arguments pushed to the stack or the order of return values. You can do that with `asm{:tact}` arrangements in the following manner:

```tact
// Changing the order of arguments to match the STDICT signature
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }

// Changing the order of return values of LDVARUINT16,
// capturing only the 2nd one as the return value of the whole function
asm(-> 1 0) extends mutates fun asmLoadCoins(self: Slice): Int { LDVARUINT16 }

// Changing the order of argument and return values
asm(self len -> 1 0) extends fun asmLoadInt(self: Slice, l: Int): SliceInt { LDIX }

// Used to map onto values placed by LDIX on the stack in reverse order
struct SliceInt { a: Slice; b: Int }

fun showcase() {
    let b = beginCell()
        .storeCoins(42)
        .storeInt(27, 10)
        .asmStoreDict(emptyMap());

    let s = b.asSlice();
    let coins = s.asmLoadCoins(); // 42
    let sliceInt = s.asmLoadInt(10); // Slice remainder and 27
}
```

### Attributes {#asm-attributes}

The following attributes can be specified:

* `inline{:tact}` — does nothing, since assembly functions cannot be inlined yet.
* [`extends{:tact}`](#extension-function) — makes it the [extension function](#extension-function).
* [`mutates{:tact}`](#mutation-functions) (along with [`extends{:tact}`](#extension-function)) — makes it the [extension mutation function](#mutation-functions).

Those attributes _cannot_ be specified:

* `abstract{:tact}` — assembly functions must have a body defined.
* `virtual{:tact}` and `override{:tact}` — assembly functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#getter-functions) — assembly functions cannot be [getters](#getter-functions).

```tact
/// `Builder.storeCoins()` extension function
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    STVARUINT16
}

/// `Slice.skipBits()` extension mutation function
asm extends mutates fun skipBits(self: Slice, l: Int) {
    SDSKIPFIRST
}
```

:::note[Useful links:]

  [Fift language overview in TON Docs][fift]\
  [List of TVM instructions in TON Docs][tvm-instructions]

:::

## Receiver functions

Receiver functions are special functions that are responsible for receiving messages in contracts and could be defined only within a contract or trait.

```tact
contract Treasure {
    // This means that this contract can receive the comment "Increment" and this function would be called for such messages
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Getter Functions

Getter functions define getters on smart contracts and can be defined only within a contract or trait.
Getter functions cannot be used to read some other contract's state: if you need to obtain some data you need to do that by sending a message with a request and define a receiver which would process the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

As other functions in TVM contracts, getters have their *unique* associated function selectors which are some integers ids (called *method IDs*).
Some of those integers are reserved for internal purposes, e.g. -4, -3, -2, -1, 0 are reserved IDs and 
regular functions (internal to a contract and not callable from outside) are usually numbered by subsequent (small) integers starting from 1.
By default, getters have associated method IDs that are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows:
`crc16(<function_name>) & 0xffff) | 0x10000`.
Sometimes this can get you the same method ID for getters with different names.
If this happens, you can either rename some of the contract's getters or
specify the getter's method ID manually as a compile-time expression like so:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId) fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return 0;
    }
}
```

Note that you *cannot* use method IDs that are reserved by TVM and you cannot use some initial positive integers because those will be used as function selectors by the compiler.

User-specified method IDs are 19-bit signed integers, so you can use integers from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$.
[slice]: /book/cells#slices

Also, a few method IDs are reserved for the usage by the getters the Tact compiler can insert during compilation, those are 113617, 115390, 121275.
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tvm-instructions]: https://docs.ton.org/v3/documentation/tvm/instructions
[fift]: https://docs.ton.org/v3/documentation/smart-contracts/fift/overview
