---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters, and internal functions, plus the many attributes that allow for great flexibility and expressivity in the Tact language"
---

import { Badge, CardGrid, LinkCard } from '@astrojs/starlight/components';

Tact offers a diverse set of function kinds and attributes that provide great flexibility and expressivity.

<CardGrid>
  <LinkCard
    title="Receiver functions"
    href="#receivers"
  />
  <LinkCard
    title="Regular functions"
    href="#fun"
  />
  <LinkCard
    title="Getter functions"
    href="#get"
  />
  <LinkCard
    title="Init function"
    href="#init"
  />
  <LinkCard
    title="Native functions"
    href="#native"
  />
  <LinkCard
    title="Assembly functions"
    href="#asm"
  />
  <LinkCard
    title="Extension functions"
    href="#extends"
  />
  <LinkCard
    title="Extension mutation functions"
    href="#mutates"
  />
  <LinkCard
    title="Inheritance attributes"
    href="#inheritance"
  />
  <LinkCard
    title="Low-level representation"
    href="#bounced"
  />
</CardGrid>

## Receiver functions {#receivers}

Receiver functions are special functions responsible for receiving messages in contracts and can be defined only within a contract or trait.

```tact
contract Counter(counter: Int) {
    // This means that this contract can receive the Increment message body,
    // and this function would be called to handle such messages.
    receive(msg: Increment) {
        self.counter += 1;
    }
}

message Increment {}
```

There are three kinds of receiver functions in Tact:

* [`receive(){:tact}`](#receive), which receives internal messages from other contracts.
* [`bounced(){:tact}`](#bounced), which is processed when an outgoing message from this contract bounces back.
* [`external(){:tact}`](#external), which doesn't have a sender and can be sent by anyone in the world.

### `receive` — internal message receivers {#receive}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The most common receiver functions, `receive(){:tact}`, handle incoming messages from other contracts.

```tact
// This contract defines various kinds of receivers in their
// order of handling the corresponding incoming messages.
contract OrderOfReceivers() {
    // Empty receiver
    receive() {
        inMsg().bits; // 0
    }

    // Text receiver
    receive("yeehaw!") {
        inMsg().asString(); // "yeehaw!"
    }

    // Catch-all String receiver
    receive(str: String) {
        // ...
    }

    // Binary message receiver
    receive(msg: FancyMessage) {
        // ...
    }

    // Catch-all Slice receiver
    receive(rawMsg: Slice) {
        // ...
    }
}

message FancyMessage {}
```

Read more about them on their dedicated page: [Receive messages](/book/receive).

### `bounced` — bounced internal message receivers {#bounced}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `bounced(){:tact}` is a special kind of receivers which handle outgoing messages that were sent from this contract and bounced back to it.

```tact
contract Bouncy() {
    // Handles empty message bodies
    receive() {
        // Sending a message...
        message(MessageParameters{
            to: sender(),
            value: ton("0.1"),
            body: BB {}.toCell(), // ...with a BB message body
        });
    }

    // If the BB message body wasn't successfully processed by the recipient,
    // it can bounce back to our contract, in which case the following receiver
    // will handle it.
    bounced(msg: bounced<BB>) {
        // ...
    }
}

message BB {}
```

Read more about them on their dedicated page: [Bounced messages](/book/bounced).

### `external` — external message receivers {#external}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `external(){:tact}` is a special kind of receivers which handle external messages — they are sent from the off-chain world and do not have a sender address on the blockchain. Such messages are often sent to wallet contracts to process specific messages or simply to send funds to another wallet contract.

```tact
contract FeaturelessWallet(publicKey: Int as uint256) {
    external(msg: MessageWithSignedData) {
        // Can't be replied to as there's no sender!
        // Thus, many checks are required.
        throwUnless(35, msg.bundle.verifySignature(self.publicKey));
    }
}

message MessageWithSignedData {
    bundle: SignedBundle;
    walletId: Int as int32;
    seqno: Int as uint32;
}
```

Read more about them on their dedicated page: [External messages](/book/external).

## `fun` — regular functions {#fun}

<Badge text="Any scope" title="These functions can be declared or defined within contracts and at the top level" variant="note" size="medium"/><p/>

Regular functions are declared using the `fun{:tact}` keyword.

```tact
fun add(a: Int, b: Int): Int {
    return a + b;
}
```

{/* TODO: bring back intermediate contents */}
{/* TODO: ### Common parts */}

All functions, except for [receiver functions](#receivers), can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

<p/><Badge text="Available since Tact 1.6.1" variant="tip" size="medium"/><p/>

For all kinds of functions, naming a parameter with an underscore `_{:tact}` causes its value to be considered unused and discarded. This is useful when you don't access the parameter but want to include it in the signature for possible overrides. Note that such a wildcard parameter name `_{:tact}` cannot be accessed.

```tact
trait WildThing {
    // Using wildcards for parameter names
    virtual fun assure(_: Int, _: Int): Bool {
        return true;
    }
}

contract YouMakeMyHeartSing with WildThing {
    // And then overriding them with concrete names
    override fun assure(a: Int, b: Int): Bool {
        return a + b == b + a;
    }
}
```

### Global functions {#fun-global}

<Badge text="Global scope" variant="note" size="medium"/><p/>

You can define global functions anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= a;
    }
    return res;
}
```

### Internal functions {#fun-internal}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

These functions behave similarly to private methods in popular object-oriented languages — they're internal to contracts and can be called by prefixing them with a special [identifier `self{:tact}`](/book/contracts#self). That's why internal (or member) functions are sometimes referred to as "contract methods".

Internal functions can access the contract's [persistent state variables](/book/contracts#variables) and [constants](/book/contracts#constants).

They can only be called from [receivers](#receivers), [getters](#get), and other internal functions, but not from other contracts.

## `get fun` — offchain getter functions {#get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `get{:tact}` attribute is a special attribute that cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into so-called _getter functions_ (or getters for short). These functions are externally accessible off-chain, allowing direct reading of contract state without regular message passing.

Getter functions define getters on smart contracts and can be defined only within a contract or trait. Getter functions cannot be used to read another contract's state. If you need to obtain data, you should do so by sending a message with a request and defining a receiver function that processes the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

```tact
contract Counter(
    val: Int as uint32,
) {
    // Standard function with get attribute
    get fun value(): Int {
        return self.val;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are 19-bit signed integer identifiers commonly called _method IDs_.

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, the Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: 113617 for `supported_interfaces`, 115390 for `lazy_deployment_completed`, and 121275 for `get_abi_ipfs`.

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId() {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](#fun-internal) and some special functions are obtained sequentially: integers in the inclusive range from -4 to 0 are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are 19-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. It is recommended to specify method IDs only in these ranges to avoid collisions.

Furthermore, as the algorithm for generating method IDs only produces positive values and IDs -4 to 0 are reserved, by manually specifying negative IDs from $-2^{18}$ up to $-5$, you can guarantee that there would be no collisions with any other getters.

```tact
contract Antipositive() {
    // This getter's manually specified method ID
    // will not collide with any autogenerated IDs
    get(-42) fun negAns(): Int {
        return -42;
    }

    get fun posAns(): Int {
        return 42;
    }
}
```

## `init` — constructor function {#init}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The special constructor function `init(){:tact}` is run upon deployment of the contract. Unlike [contract parameters](/book/contracts#parameters), it performs a delayed initialization of the contract data, overriding the values of persistent state variables on-chain.

```tact
contract Example {
    // Persistent state variables
    var1: Int = 0; // initialized with default value 0
    var2: Int;     // must be initialized in the init() function
    var3: Int = 7; // initialized with default value 7

    // Constructor function, which is run only once
    init() {
        self.var2 = 42;
        self.var3 = 32; // overrides the default to 32
    }
}
```

For every receiver that doesn't alter the contract's variables, Tact optimizes away unnecessary storage overrides. However, contracts cannot benefit from such optimizations if the `init(){:tact}` function is present. That is because for contracts with `init(){:tact}` every receiver has to check whether the `init(){:tact}` function has run already and did that only once, and to do so, a special flag is implicitly stored in the contract's persistent state.

Effectively, the behavior or `init(){:tact}` function can be simulated when using contract parameters instead — through adding a special [`Bool{:tact}`](/book/types#booleans) field and a function that would be used in place of the `init(){:tact}`. That function would be called at the beginning of every receiver, while the boolean field would be used as a flag.

```tact
contract CounterBuiltinInit {
    // Persistent state variables
    counter: Int as uint32;

    // Constructor function, which is run only once
    init() {
        self.counter = 0;
    }

    receive() {
        cashback(sender());
    }

    receive(_: Increment) {
        self.counter += 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
}

contract CounterDIYInit(
    // Persistent state variables
    initialized: Bool, // set this field to `false` during deployment
    counter: Int as uint32, // set this field to `0` during deployment
) {
    // Internal function, which will be used in place of a pseudo-constructor function
    fun init() {
        // Stop further actions if this init() function was called before
        if (self.initialized) {
            return;
        }
        // Initialize
        self.initialized = true;
        self.counter = 0;
    }

    receive() {
        // Don't forget to add this call at the start of every receiver
        // that can be used for deployments.
        self.init();
        cashback(sender());
    }

    receive(_: Increment) {
        // Don't forget to add this call at the start of every receiver
        // that can be used for deployments.
        self.init();
        self.counter += 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
    
}

message Increment {}
```

None of the [attributes](#attributes) can be specified for the `init(){:tact}` function.

Read more about the `init(){:tact}` on its dedicated section: [Constructor function `init(){:tact}`](/book/contracts#init-function).

## `native` — native functions {#native}

<Badge text="Global scope" variant="note" size="medium"/><p/>

Native functions are Tact's FFI to FunC — they allow direct bindings to imported FunC functions. In order to declare them, you have to import a `.fc` or `.func` file first. Granted, the FunC's [standard library file, `stdlib.fc`](https://github.com/tact-lang/tact/blob/main/src/stdlib/stdlib/std/stdlib.fc), is always imported for you.

Consider the following FunC function:

```func title="import_me.fc"
;; Notice the tensor return type (int, int),
;; which means we would have to define at least one
;; Tact structure to bind to this function.
(int, int) minmax(int a, int b) {
    if (a < b) {
        return (a, b);
    } else {
        return (b, a);
    }
}
```

In Tact code, one could access that function as follows:

```tact
// 1. Import the FunC file that contains the function.
import "./import_me.fc";

// 2. Declare the native function binding.
@name(minmax) // name of the target FunC function
native minmax(a: Int, b: Int): MinMax;
//     ^^^^^^ name of the Tact function bind,
//            which can be the identical to its FunC counterpart

// 3. Define the necessary structs for the bind.
//    In our case, it is the MinMax structure to capture multiple return values.
struct MinMax {
    a: Int;
    b: Int;
}

// 4. Use the function whenever you would like.
//    It has the same properties as regular global functions.
fun example() {
    let res = minmax(20, 10);
    res.a; // 10
    res.b; // 20
}
```

The following attributes can be specified for `native{:tact}` functions:

* [`inline{:tact}`](#attributes-inline) — inlines the function contents at the call site.
* [`extends{:tact}`](#attributes-extends) — makes it an [extension function](#attributes-extends).
* [`mutates{:tact}`](#attributes-mutates), along with [`extends{:tact}`](#attributes-extends) — makes it an [extension mutation function](#attributes-mutates).

These attributes _cannot_ be specified:

* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — native functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#attributes-get) — native functions cannot be [getters](#get).

## `asm` — assembly functions {#asm}

<Badge text="Global scope" variant="note" size="medium"/>
<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

Assembly functions are top-level functions that allow you to write Tact assembly. Unlike all other functions, their bodies consist only of TVM instructions and some other primitives that serve as arguments to the instructions.

Furthermore, `asm{:tact}` functions are nearly devoid of all abstractions and give direct access to the underlying stack and register contents on which TVM operates.

Read more about them on their dedicated page: [Assembly functions](/book/assembly-functions).

## Function attributes {#attributes}

Attribute         | Scope    | Can be applied to
----------------- | -------- | -----------------
`extends{:tact}`  | global   | All global functions
`mutates{:tact}`  | global   | Functions with `extends{:tact}` attribute
`virtual{:tact}`  | contract | Internal functions
`abstract{:tact}` | contract | Internal functions
`override{:tact}` | contract | Internal functions that were previously marked with `virtual{:tact}` or `abstract{:tact}`
`inline{:tact}`   | any      | All [secondary](#secondary) functions
`get{:tact}`      | contract | Internal functions — turns them into [getters](#get)

Notice that the "contract" scope also includes the [traits][trait].

{/* TODO: clarify scopes in a hover — global (module-level/top-level), contract (internal/private), any (both) */}

### Extensions

<Badge text="Global scope" variant="note" size="medium"/><p/>

Extension functions provide a clean way to organize and extend code by allowing you to add new behaviors to existing types. The extension mutation functions also allow you to modify the value they operate on. Both kinds of extension functions can be called methods and both use special attributes.

#### `extends` — extension functions {#attributes-extends}

<Badge text="Global scope" variant="note" size="medium"/><p/>

TODO: ...

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The first argument MUST be named `self`, and the argument's type must be the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

TODO: better examples!

#### `mutates` — extension mutation functions {#attributes-mutates}

<Badge text="Global scope" variant="note" size="medium"/><p/>

TODO: ...

Mutation functions perform mutation on a value by replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

#### Static extension functions {#attributes-extends-static}

There is no such attribute yet, so the special static extension functions in the standard library of Tact are introduced directly by the compiler:

* [`Message.opcode(){:tact}`](/ref/core-cells#messageopcode)
* [`Message.fromCell(){:tact}`](/ref/core-cells#messagefromcell)
* [`Message.fromSlice(){:tact}`](/ref/core-cells#messagefromslice)
* [`Struct.fromCell(){:tact}`](/ref/core-cells#structfromcell)
* [`Struct.fromSlice(){:tact}`](/ref/core-cells#structfromslice)

### Inheritance

<Badge text="Contract scope" title="Functions can only be inherited from traits and never at the top level" variant="note" size="medium"/><p/>

The `with{:tact}` keyword allows a contract to inherit a [trait](/book/types#traits) with all its constants, fields, and functions, including those transitively inherited from other traits associated with the specified trait.

In particular, all functions of the trait become accessible in the contract, regardless of any inheritance-related attributes, such as `abstract{:tact}`, `virtual{:tact}`, or `override{:tact}`.

You can allow a contract inheriting a [trait][trait] to modify a [internal function](#fun-internal) marked with the `virtual{:tact}` keyword by using `override{:tact}`. A function can also be marked as `abstract{:tact}`, in which case the inheriting contract must define its implementation.

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;

    // Receivers can be inherited, but cannot be overridden
    receive() { cashback(sender()) }
}

contract Filter() with FilterTrait {
    // Overriding the default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

{/* TODO: inheritance table as per https://github.com/tact-lang/tact/issues/3030 */}

#### `abstract` {#attributes-abstract}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `abstract{:tact}` attribute allows declaring a [internal function](#fun-internal) with no body given at declaration. Functions with this attribute are meant to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

```tact
trait BlackSquare {
    abstract fun paint();
}

trait CompositionVII {
    abstract fun paintedWithOil(preliminary: Bool): Bool;
}

contract Abstractionism() with BlackSquare, CompositionVII {
    // All functions marked as abstract must be defined in the contract that inherits them.
    override fun paintedWithOil(preliminary: Bool): Bool {
        if (preliminary) {
            return false; // perhaps, watercolors were used...
        }
        return true;
    }

    // The override attribute gives you full control — the only thing must be kept
    // the same between the abstract declaration and resulting definition
    // is the name of the function. Return type or function parameters can be changed.
    override fun paint(color: String): Bool {
        if (color != "black") {
            return false;
        }
        return true;
    }
}
```

#### `virtual` {#attributes-virtual}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `virtual{:tact}` attribute allows a [internal function](#fun-internal) to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

This attribute is similar to the [`abstract{:tact}`](#attributes-abstract) attribute, except that you do not have to override bodies of functions with the `virtual{:tact}` attribute. But if you decide to override the function body, you may do it in any trait that depends on this trait and not only in the resulting contract.

```tact
import "@stdlib/ownable";

trait DeployableFilterV1 with Ownable {
    // Virtual functions can be optionally overridden by users of this trait.
    virtual fun filter() {
        // Not an owner
        throwUnless(TactExitCodeAccessDenied, sender() == self.owner);
    }

    // Whereas internal functions with an abstract attribute must be overriden
    // by the contract that will import this trait or any of the traits that depend on this trait.
    abstract fun specialFilter();

    // Receivers are inherited too,
    // but they cannot defined be virtual or abstract
    receive() { cashback(sender()) }
}

trait DeployableFilterV2 with DeployableFilterV1 {
    override fun filter() {
        // Not an owner
        throwUnless(TactExitCodeAccessDenied, sender() == self.owner);

        // Message carries too little Toncoin for our tastes
        throwUnless(TactExitCodeAccessDenied, context().value < ton("1"));
    }
}

contract Auth(owner: Address) with DeployableFilterV2 {
    override fun specialFilter() {
        if (randomInt() < 10) {
            throw(TactExitCodeAccessDenied);
        }
    }

    receive(_: TopSecretRequest) {
        self.filter();
        self.specialFilter();

        // ...subsequent logic...
    }
}

message TopSecretRequest {}
```

#### `override` {#attributes-override}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `override{:tact}` attribute is used to override an inherited [internal function](#fun-internal) that has either a [`virtual{:tact}`](#attributes-virtual) or [`abstract{:tact}`](#attributes-abstract) attribute specified in the declaration of that function in one of the parent traits.

### Miscellaneous

Various attributes that modify the behavior of functions in their special ways.

#### `inline` {#attributes-inline}

<Badge text="Any scope" title="This attribute can be applied to functions within contracts and functions at the top level" variant="note" size="medium"/><p/>

The `inline{:tact}` attribute embeds the code of the function to its call sites, which eliminates the overhead of the calls but potentially increases the code size if the function is called from multiple places.

This attribute can improve performance of large infrequently called functions or small, alias-like functions. It can be combined with any other attribute except for [`get{:tact}`](#attributes-get).

```tact
inline fun add(a: Int, b: Int) {
    // The following addition will be performed in-place,
    // at all the `add()` call sites.
    return a + b;
}
```

#### `get` {#attributes-get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `get{:tact}` attribute is a special attribute that cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into [getter functions](#get).

## Low-level representation

On [TVM][tvm] level, contracts and their functions are often represented as a dictionary (or ["hashmap"](/book/maps#low-level-representation)) of methods, from their numeric method IDs to their respective bodies composed of TVM instructions. Each function then is a method that transforms the stack and TVM registers.

A function call is, essentially, a call into the dictionary using the function's ID, after which:
1. Function arguments are pushed onto the stack
2. The function executes, manipulating the stack
3. Return values are left on top of the stack, provoking another dictionary call or resulting in the end of the transaction

When a so-called ["selector hack"](/book/config#optimizations-internalexternalreceiversoutsidemethodsmap) optimization is enabled, if a small number of receiver functions are defined in the contract, they are stored outside of that map and as plain instruction sequences. That saves gas but can cause the contract to be incorrectly recognized and misparsed by some explorers and user wallets, which expect the root of the contract's code (the root cell) to point at the method dictionary instead.

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[slice]: /book/cells#slices
[trait]: /book/types#traits

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
