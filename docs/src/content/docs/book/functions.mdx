---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters and storage functions, plus the many attributes that allow for great flexibility and expressivity of Tact language"
---

import { Badge } from '@astrojs/starlight/components';

Functions in Tact could be defined in different ways:

* Global static function
* Extension functions
* Mutation functions
* Native functions
* [Assembly functions](#asm)
* [Internal functions](/book/contracts#internal-functions)
* Receiver functions
* Getter functions

All functions, except for [receiver functions](#receiver-functions) can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

## Global static functions

You can define global function anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Virtual and abstract functions

You can allow the contract inheriting a [traits](/book/types#traits) to modify an internal function, if it has the `virtual{:tact}` keyword, using `override{:tact}`. The function can be also marked as `abstract{:tact}`, in which case the inheriting contract has to define its implementation:

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Overriding default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
````

## Extension function

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The name of the first argument MUST be named `self` and the type of this argument is the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Mutation functions

Mutation functions are performing mutation of a value replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Native functions

Native functions are direct bindings of FunC functions:

> **Note**
> Native functions could also be mutation and extension ones.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Assembly functions, `asm` {#asm}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

:::caution

  These are very advanced functions that require experience and vigilance in both definitions and usage. The logical errors in them are extremely hard to spot, the error messages are abysmal, and type checking isn't currently provided by Tact.

  That said, if you know what you're doing, they can offer you the smallest possible gas usage, the best performance and the most control over [TVM][tvm] execution. Remember — with great power comes great responsibility.

:::

Assembly functions (or `asm{:tact}` functions for short) are module-level functions that allow writing [TVM][tvm] assembly directly in Tact. Unlike all other functions, their bodies consist only of [TVM instructions][tvm-instructions], and don't use any [Tact statements](/book/statements).

```tact
// all assembly functions must start with "asm" keyword
// ↓
   asm fun answer(): Int { 42 INT }
//                         ------
//                         Notice, that the body contains
//                         only of numbers, strings and TVM instructions
```

### Caveats {#asm-caveats}

[TVM instructions][tvm-instructions] are case-sensitive and are always written in upper case (capital letters).

```tact
/// ERROR!
asm fun bad1(): Cell { mycode }

/// ERROR!
asm fun bad2(): Cell { MyCoDe }

/// 👍
asm fun good(): Cell { MYCODE }
```

It is not necessary to enclose TVM instructions in double quotes. On the contrary, they are then interpreted as strings, which is probably _not_ what you want:

```tact
// Pushes the string "MYCODE" onto the compile-time stack,
// where it gets discarded even before the compute phase starts
asm fun wrongMyCode() { "MYCODE" }

// Invokes the TVM instruction MYCODE during the compute phase,
// which returns the contract code as a Cell
asm fun myCode(): Cell { MYCODE }
```

The syntax for parameters and return values is the same as for other function kinds, but there is one caveat — argument values are pushed to the stack before the function body is executed, and return values are what's left on the stack afterward.

Since the bodies of `asm{:tact}` functions do not contain Tact statements, any direct references to parameters in function bodies will be recognized as [TVM][tvm] instructions, which can easily lead to very obscure error messages.

```tact
/// Simply returns back the value of `x`
asm fun identity(x: Int): Int { }

/// COMPILATION ERROR!
/// The `BOC` is not recognized as a parameter,
/// but instead is interpreted as a non-existent TVM instruction
asm fun bocchiThe(BOC: Cell): Cell { BOC }

/// Loads a signed `len`-bit integer from Slice `s`,
/// and returns it with the remainder of `s`
asm fun sliceLoadInt(s: Slice, len: Int): IntSlice { LDIX }
//                   ↑         ↑
//                   |         Pushed last, sits on top of the stack
//                   Pushed first, sits on the bottom of the stack

/// Maps onto values placed by LDIX on the stack
struct IntSlice { a: Int; b: Slice }
//                ↑       ↑
//                |       Pushed last, sits on top of the stack
//                Pushed first, sits on the bottom of the stack
```

The return values are provided bottom-up from the stack and the unused values are discarded.

```tact
// Same function as before, but now we don't use the `IntSlice` Struct
// and instead only take one value from the stack (going bottom-up)
asm fun sliceLoadInt(s: Slice, len: Int): Int { LDIX }
//                                        ↑
//                                        captures the Int value, discarding
//                                        the Slice one produced by LDIX instruction
```

### Arrangements {#asm-arrangements}

Sometimes it's useful to change the order of arguments pushed to the stack or the order of return values. You can do that with `asm{:tact}` arrangements in the following manner:

```tact
// Changing the order of arguments to match the STDICT signature:
// `c` will be pushed first and get on the bottom of the stack,
// while `self` will be pushed last and get on top of the stack
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }

// Changing the order of return values of LDVARUINT16,
// capturing only the last one as the return value of the whole function
asm(-> 1 0) extends mutates fun asmLoadCoins(self: Slice): Int { LDVARUINT16 }
//     ---
//     Notice, that return values are best thought as tuples with indexed access into them
//     and not as bottom-up representation of stack values

// Changing the order of return values while explicitly stating
// the default order of arguments as it is
asm(self len -> 1 0) extends fun asmLoadInt(self: Slice, len: Int): SliceInt { LDIX }

// Used to map onto values placed by LDIX on the stack in reversed order
struct SliceInt { a: Slice; b: Int }
```

Putting the above all together we get:

```tact
fun showcase() {
    let b = beginCell()
        .storeCoins(42)
        .storeInt(27, 10)
        .asmStoreDict(emptyMap());

    let s = b.asSlice();
    let coins = s.asmLoadCoins(); // 42
    let sliceInt = s.asmLoadInt(10); // Slice remainder and 27
}
```

### Attributes {#asm-attributes}

The following attributes can be specified:

* `inline{:tact}` — does nothing, since assembly functions cannot be inlined yet.
* [`extends{:tact}`](#extension-function) — makes it an [extension function](#extension-function).
* [`mutates{:tact}`](#mutation-functions) (along with [`extends{:tact}`](#extension-function)) — makes it an [extension mutation function](#mutation-functions).

Those attributes _cannot_ be specified:

* `abstract{:tact}` — assembly functions must have a body defined.
* `virtual{:tact}` and `override{:tact}` — assembly functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#getter-functions) — assembly functions cannot be [getters](#getter-functions).

```tact
/// `Builder.storeCoins()` extension function
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    STVARUINT16
}

/// `Slice.skipBits()` extension mutation function
asm extends mutates fun skipBits(self: Slice, l: Int) {
    SDSKIPFIRST
}
```

:::note[Useful links:]

  [TVM overview in TON Docs][tvm]\
  [List of TVM instructions in TON Docs][tvm-instructions]

:::

## Receiver functions

Receiver functions are special functions that are responsible for receiving messages in contracts and could be defined only within a contract or trait.

```tact
contract Treasure {
    // This means that this contract can receive the comment "Increment" and this function would be called for such messages
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Getter Functions

Getter functions define getters on smart contracts and can be defined only within a contract or trait.
Getter functions cannot be used to read some other contract's state: if you need to obtain some data you need to do that by sending a message with a request and define a receiver which would process the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are $19$-bit signed integer identifiers commonly called _method IDs_.

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: $113617$ for `supported_interfaces`, $115390$ for `lazy_deployment_completed`, and $121275$ for `get_abi_ipfs`.

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](/book/contracts#internal-functions) and some special functions are obtained sequentially: integers in the inclusive range from $-4$ to $0$ are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are $19$-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. To avoid collisions, it's recommended to specify method IDs only in these ranges, avoiding the method IDs of Tact-specific getters mentioned above.

[slice]: /book/cells#slices

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tvm-instructions]: https://docs.ton.org/v3/documentation/tvm/instructions
