---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters, and internal functions, plus the many attributes that allow for great flexibility and expressivity in the Tact language"
---

import { Badge, CardGrid, LinkCard } from '@astrojs/starlight/components';

Tact offers a diverse set of function kinds and attributes that provide great flexibility and expressivity. While some functions stand out, many of their [parts and behaviors are common](#commonalities).

<CardGrid>
  <LinkCard
    title="Receiver functions"
    href="#receivers"
  />
  <LinkCard
    title="Regular functions"
    href="#fun"
  />
  <LinkCard
    title="Extension functions"
    href="#extends"
  />
  <LinkCard
    title="Extension mutation functions"
    href="#mutates"
  />
  <LinkCard
    title="Getter functions"
    href="#get"
  />
  <LinkCard
    title="Init function"
    href="#init"
  />
  <LinkCard
    title="Native functions"
    href="#native"
  />
  <LinkCard
    title="Assembly functions"
    href="#asm"
  />
  <LinkCard
    title="Inheritance"
    href="#inheritance"
  />
  <LinkCard
    title="Inlining"
    href="#attributes-inline"
  />
  <LinkCard
    title="Commonalities"
    href="#commonalities"
  />
  <LinkCard
    title="Low-level representation"
    href="#low-level-representation"
  />
</CardGrid>

## Receiver functions {#receivers}

Receiver functions are special functions responsible for receiving messages in contracts and can be defined only within a contract or trait.

```tact
contract Counter(counter: Int) {
    // This means that this contract can receive the Increment message body,
    // and this function would be called to handle such messages.
    receive(msg: Increment) {
        self.counter += 1;
    }
}

message Increment {}
```

There are three kinds of receiver functions in Tact:

* [`receive(){:tact}`](#receive), which receives internal messages from other contracts.
* [`bounced(){:tact}`](#bounced), which is processed when an outgoing message from this contract bounces back.
* [`external(){:tact}`](#external), which doesn't have a sender and can be sent by anyone in the world.

### `receive` — internal message receivers {#receive}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The most common receiver functions, `receive(){:tact}`, handle incoming messages from other contracts.

```tact
// This contract defines various kinds of receivers in their
// order of handling the corresponding incoming messages.
contract OrderOfReceivers() {
    // Empty receiver
    receive() {
        inMsg().bits; // 0
    }

    // Text receiver
    receive("yeehaw!") {
        inMsg().asString(); // "yeehaw!"
    }

    // Catch-all String receiver
    receive(str: String) {
        // ...
    }

    // Binary message receiver
    receive(msg: FancyMessage) {
        // ...
    }

    // Catch-all Slice receiver
    receive(rawMsg: Slice) {
        // ...
    }
}

message FancyMessage {}
```

Read more about them on their dedicated page: [Receive messages](/book/receive).

### `bounced` — bounced internal message receivers {#bounced}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `bounced(){:tact}` is a special kind of receivers which handle outgoing messages that were sent from this contract and bounced back to it.

```tact
contract Bouncy() {
    // Handles empty message bodies
    receive() {
        // Sending a message...
        message(MessageParameters{
            to: sender(),
            value: ton("0.1"),
            body: BB {}.toCell(), // ...with a BB message body
        });
    }

    // If the BB message body wasn't successfully processed by the recipient,
    // it can bounce back to our contract, in which case the following receiver
    // will handle it.
    bounced(msg: bounced<BB>) {
        // ...
    }
}

message BB {}
```

Read more about them on their dedicated page: [Bounced messages](/book/bounced).

### `external` — external message receivers {#external}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `external(){:tact}` is a special kind of receivers which handle external messages — they are sent from the off-chain world and do not have a sender address on the blockchain. Such messages are often sent to wallet contracts to process specific messages or simply to send funds to another wallet contract.

```tact
contract FeaturelessWallet(publicKey: Int as uint256) {
    external(msg: MessageWithSignedData) {
        // Can't be replied to as there's no sender!
        // Thus, many checks are required.
        throwUnless(35, msg.bundle.verifySignature(self.publicKey));
    }
}

message MessageWithSignedData {
    bundle: SignedBundle;
    walletId: Int as int32;
    seqno: Int as uint32;
}
```

Read more about them on their dedicated page: [External messages](/book/external).

## `fun` — regular functions {#fun}

<Badge text="Any scope" title="These functions can be declared or defined within contracts and at the top level" variant="note" size="medium"/><p/>

Regular functions are defined using the `fun{:tact}` keyword.

```tact
fun add(a: Int, b: Int): Int {
    return a + b;
}
```

Read about common aspects of functions: [Commonalities](#commonalities).

### Global functions {#fun-global}

<Badge text="Global scope" variant="note" size="medium"/><p/>

Regular functions that can be defined only at the top (module) level are called global. They differ from [internal functions](#fun-internal) not only in the scope, but also in available [attributes](#attributes).

```tact
fun customPow(a: Int, c: Int): Int {
    let res: Int = 1;
    repeat (c) {
        res *= a;
    }
    return res;
}
```

The following attributes can be specified for global functions:

* [`inline{:tact}`](#attributes-inline) — embeds the function contents at the call site.
* [`extends{:tact}`](#attributes-extends) — makes it an [extension function](#extends).
* [`mutates{:tact}`](#attributes-mutates), along with [`extends{:tact}`](#attributes-extends) — makes it an [extension mutation function](#mutates).

These attributes _cannot_ be specified:

* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — global functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#attributes-get) — global functions cannot be [getters](#get).

### Internal functions {#fun-internal}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

These functions behave similarly to private methods in popular object-oriented languages — they are internal to contracts and can be called by prefixing their names with a special [identifier `self{:tact}`](/book/contracts#self). That is why internal (or member) functions are sometimes referred to as "contract methods".

Internal functions can access the contract's [persistent state variables](/book/contracts#variables) and [constants](/book/contracts#constants).

They can only be called from [receivers](#receivers), [getters](#get), and other internal functions, but not from other contracts.

```tact
contract InternalFun() {
    fun add(a: Int, b: Int): Int {
        return a + b;
    }
    get fun compute() {
        self.add(2, 2); // 4
    }
}
```

The following attributes can be specified for internal functions with no prior attributes:

* [`inline{:tact}`](#attributes-inline) — embeds the function contents at the call site.
* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — function [inheritance](#inheritance).
* [`get{:tact}`](#attributes-get) — internal functions can become [getters](#get).

These attributes _cannot_ be specified:

* [`extends{:tact}`](#attributes-extends) — internal function cannot become an [extension function](#extends).
* [`mutates{:tact}`](#attributes-mutates) — internal function cannot become an [extension mutation function](#mutates).

## `extends` — extension functions {#extends}

<Badge text="Global scope" variant="note" size="medium"/><p/>

To define an extension function, add an `extends{:tact}` attribute to any [global function](#fun-global) and name its first parameter as `self`. The type of `self` is the type that is being extended by the extension function.

```tact
extends fun customPow(self: Int, exp: Int): Int {
    let res: Int = 1;
    repeat (exp) {
        res *= self;
    }
    return res;
}
```

The special `self{:tact}` identifier inside an extension function is a copy of the value of the extended type. In other words, it is the argument value passed to the `self` parameter.

```tact
// You can call extension functions on instances of the extended type,
// such as variables...
let val = 42;
val.customPow(2); // 1764

// ...literals...
2.customPow(10); // 1024

// ...or any other values of that type.
pow2(2).customPow(5); // 1024
```

Most of the standard library functions that work with values of the [`Builder{:tact}`][builder] type are extension functions on that type. As such, they do not modify the original value they are applied to.

To preserve newly created values with extension functions, use intermediary assignments or make a long chained call in a single assignment.

```tact
let builder = beginCell();
let cell = builder
    .storeUint(42, 7)
    .storeInt(42, 7)
    .storeBool(true)
    .storeSlice(slice)
    .storeCoins(42)
    .storeAddress(address)
    .storeRef(cell)
    .endCell();
// Notice that the chained extension function call did not change
// the `builder` variable itself, which is still holding an empty Builder.
builder.refs(); // 0
builder.bits(); // 0
```

The first parameter of extension functions must be named `self`. Failure to do so leads to a compilation error.

Additionally, naming the first parameter of any non-extension function as `self{:tact}` leads to a compilation error too.

```tact
// COMPILATION ERROR! Extend function must have first parameter named "self"
extends fun add(this: Int, other: Int): Int {
    //          ~~~~~~~~~
    return this + other;
}

// COMPILATION ERROR! Parameter name "self" is reserved for functions with "extends"
fun add(self: Int, other: Int): Int {
    //  ~~~~~~~~~
    return self + other;
}
```

The following additional attributes can be specified:

* [`inline{:tact}`](#attributes-inline) — embeds the function contents at the call site.
* [`mutates{:tact}`](#attributes-mutates) — makes it into an [extension mutation function](#attributes-mutates).

These attributes _cannot_ be specified:

* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — extension functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#attributes-get) — extension functions cannot become [getters](#get).

## `mutates` — extension mutation functions {#mutates}

<Badge text="Global scope" variant="note" size="medium"/><p/>

The extension _mutation_ functions replace the value of the extended type with the new one at the end of its execution. That value would change only upon the assignment to `self{:tact}` within the function body.

To define an extension mutation function, add a `mutates{:tact}` attribute to the existing [extension function](#extends).

```tact
extends mutates fun customPow(self: Int, exp: Int) {
    let res: Int = 1;
    repeat (exp) {
        res *= self;
    }
    self = res;
}
```

For extension mutation functions, the special `self` identifier refers to the value of the extended type, and changes made to it will persist after the function call.

```tact
// It is most useful to call extension mutation functions on instances
// of the extended type that can keep the change stored either temporarily, i.e.,
// within the current transaction, or permanently — in the contract's state.
contract Mut(val: Int) {
    receive() {
        let valTmp = 2;
        valTmp.customPow(10);
        self.val.customPow(10);
        // Now, `valTmp` holds 1024, and `self.val` holds
        // its value prior to this transaction raised to the power 10.
    }
}
```

Extension mutation functions cannot modify [constants](/book/constants) because they are immutable.

```tact
const VAL: Int = 10;

fun noEffect() {
    VAL; // 10
    VAL.customPow(10);
    VAL; // still 10
}
```

The following additional attributes can be specified:

* [`inline{:tact}`](#attributes-inline) — embeds the function contents at the call site.

These attributes _cannot_ be specified:

* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — extension mutation functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#attributes-get) — extension mutation functions cannot become [getters](#get).

## `get fun` — off-chain getter functions {#get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The special `get{:tact}` attribute cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into so-called _getter functions_ (or getters for short). These functions are externally accessible off-chain, allowing direct reading of contract state without regular message passing.

```tact
contract StaleCounter(val: Int as uint32) {
    // Getter function that simply returns the current value of the state variable
    get fun value(): Int {
        return self.val;
    }

    // Getter function that performs basic calculations
    get fun valuePlus(another: Int): Int {
        return self.val + another;
    }
}
```

Despite the restriction on attributes, getter functions can still be considered internal or contract methods — calling them from within another contract function is possible. In those cases, their behavior would be identical to calling an internal function through `self{:tact}`, including any state modifications those functions can perform.

However, most of the time, getter functions are there to be called from the off-chain world. And when they are called that way and not via `self{:tact}`, their state modifications no longer persist between transactions (changes are discarded).

```tact
contract WillNotBudge(val: Int) {
    get fun changeVal() {
        self.val = randomInt();
        self.val; // ?, it is random!
        // However, after this function is done,
        // the self.val will be reset to its value prior to this function call.
    }
}
```

Furthermore, when **not** used as internal functions, getters do not pay the [compute fees](https://docs.ton.org/develop/howto/fees-low-level#computation-fees) and have their gas limits to prevent infinite loops or endless transactions. That is, getters can perform arbitrary computations if their internal gas limit is not surpassed in a single transaction.

Those gas limits depend on the API provider used to call a certain getter, but they are usually around 100 million gas units per getter call.

With that in mind, getters are most commonly used for fetching the current state of contract's persistent state variables. To do so in a convenient matter, Tact allows you to view the contract itself as a [struct][struct] of contract variables, i.e., to use `self{:tact}` to refer to the contract itself and return all of its state variable values at once in a single getter.

```tact
contract ManyFields(
    f1: Int,
    f2: Int,
    // ...
    f42: Int,
) {
    // Notice that the return type of this get function coincides
    // with the name of the contract, which makes that return type
    // view the contract as a struct of its variables.
    get fun state(): ManyFields {
        return self; // you do not have to list all fields of a contract for this
    }
}
```

### Method IDs

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are 19-bit signed integer identifiers commonly called [_method IDs_](#low-level-representation).

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, the Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: 113617 for `supported_interfaces`, 115390 for `lazy_deployment_completed`, and 121275 for `get_abi_ipfs`.

Thus, getters and their method IDs are an important part of the contract interfaces, to the point where explorers tend to recognize contracts based not on their entire code, but on the set of getters they expose to the off-chain world.

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId() {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](#fun-internal) and some special functions are obtained sequentially: integers in the inclusive range from -4 to 0 are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are 19-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. It is recommended to specify method IDs only in these ranges to avoid collisions.

Furthermore, as the algorithm for generating method IDs only produces positive values and IDs -4 to 0 are reserved, by manually specifying negative IDs from $-2^{18}$ up to $-5$, you can guarantee that there would be no collisions with any other getters.

```tact
contract AntiPositive() {
    // This getter's manually specified method ID
    // will not collide with any autogenerated IDs
    get(-42) fun negAns(): Int {
        return -42;
    }

    get fun posAns(): Int {
        return 42;
    }
}
```

## `init` — constructor function {#init}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The special constructor function `init(){:tact}` is run upon deployment of the contract. Unlike [contract parameters](/book/contracts#parameters), it performs a delayed initialization of the contract data, overriding the values of persistent state variables on-chain.

```tact
contract Example {
    // Persistent state variables
    var1: Int = 0; // initialized with default value 0
    var2: Int;     // must be initialized in the init() function
    var3: Int = 7; // initialized with default value 7

    // Constructor function, which is run only once
    init() {
        self.var2 = 42;
        self.var3 = 32; // overrides the default to 32
    }
}
```

For every receiver that doesn't alter the contract's variables, Tact optimizes away unnecessary storage overrides. However, contracts cannot benefit from such optimizations if the `init(){:tact}` function is present. That is because for contracts with `init(){:tact}` every receiver has to check whether the `init(){:tact}` function has run already and did that only once, and to do so, a special flag is implicitly stored in the contract's persistent state.

Effectively, the behavior or `init(){:tact}` function can be simulated when using contract parameters instead — through adding a special [`Bool{:tact}`](/book/types#booleans) field and a function that would be used in place of the `init(){:tact}`. That function would be called at the beginning of every receiver, while the boolean field would be used as a flag.

```tact
contract CounterBuiltinInit {
    // Persistent state variables
    counter: Int as uint32;

    // Constructor function, which is run only once
    init() {
        self.counter = 0;
    }

    receive() {
        cashback(sender());
    }

    receive(_: Increment) {
        self.counter += 1;
    }

    get fun counter(): Int {
        return self.counter;
    }
}

contract CounterDIYInit(
    // Persistent state variables
    initialized: Bool, // set this field to `false` during deployment
    counter: Int as uint32, // set this field to `0` during deployment
) {
    // Internal function, which will be used in place of a pseudo-constructor function
    fun init() {
        // Stop further actions if this init() function was called before
        if (self.initialized) {
            return;
        }
        // Initialize
        self.initialized = true;
        self.counter = 0;
    }

    receive() {
        // Don't forget to add this call at the start of every receiver
        // that can be used for deployments.
        self.init();
        cashback(sender());
    }

    receive(_: Increment) {
        // Don't forget to add this call at the start of every receiver
        // that can be used for deployments.
        self.init();
        self.counter += 1;
    }

    get fun counter(): Int {
        return self.counter;
    }

}

message Increment {}
```

None of the [attributes](#attributes) can be specified for the `init(){:tact}` function.

Read more about the `init(){:tact}` on its dedicated section: [Constructor function `init(){:tact}`](/book/contracts#init-function).

## `native` — foreign function interfaces {#native}

<Badge text="Global scope" variant="note" size="medium"/><p/>

Native functions are Tact's [FFI](https://en.wikipedia.org/wiki/Foreign_function_interface) to FunC — they allow direct bindings to imported FunC functions. In order to declare them, you have to import a `.fc` or `.func` file first. Granted, the FunC's [standard library file, `stdlib.fc`](https://github.com/tact-lang/tact/blob/main/src/stdlib/stdlib/std/stdlib.fc), is always imported for you.

Consider the following FunC function:

```func title="import_me.fc"
;; Notice the tensor return type (int, int),
;; which means we would have to define at least one
;; Tact structure to bind to this function.
(int, int) minmax(int a, int b) {
    if (a < b) {
        return (a, b);
    } else {
        return (b, a);
    }
}
```

In Tact code, one could access that function as follows:

```tact
// 1. Import the FunC file that contains the function.
import "./import_me.fc";

// 2. Declare the native function binding.
@name(minmax) // name of the target FunC function
native minmax(a: Int, b: Int): MinMax;
//     ^^^^^^ name of the Tact function bind,
//            which can be the identical to its FunC counterpart

// 3. Define the necessary structs for the bind.
//    In our case, it is the MinMax structure to capture multiple return values.
struct MinMax {
    min: Int;
    max: Int;
}

// 4. Use the function whenever you would like.
//    It has the same properties as regular global functions.
fun example() {
    let res = minmax(20, 10);
    res.min; // 10
    res.max; // 20
}
```

The following attributes can be specified for `native{:tact}` functions:

* [`inline{:tact}`](#attributes-inline) — embeds the function contents at the call site.
* [`extends{:tact}`](#attributes-extends) — makes it an [extension function](#extends).
* [`mutates{:tact}`](#attributes-mutates), along with [`extends{:tact}`](#attributes-extends) — makes it an [extension mutation function](#mutates).

These attributes _cannot_ be specified:

* [`abstract{:tact}`](#attributes-abstract), [`virtual{:tact}`](#attributes-virtual) and [`override{:tact}`](#attributes-override) — native functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#attributes-get) — native functions cannot be [getters](#get).

## `asm` — assembly functions {#asm}

<Badge text="Global scope" variant="note" size="medium"/>
<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

Assembly functions are top-level functions that allow you to write Tact assembly. Unlike all other functions, their bodies consist only of TVM instructions and some other primitives that serve as arguments to the instructions.

Furthermore, `asm{:tact}` functions are nearly devoid of all abstractions and give direct access to the underlying stack and register contents on which TVM operates.

Read more about them on their dedicated page: [Assembly functions](/book/assembly-functions).

## Function attributes {#attributes}

Attribute         | Scope    | Can be applied to
:---------------- | :------- | :----------------
`extends{:tact}`  | global   | All global functions
`mutates{:tact}`  | global   | Functions with `extends{:tact}` attribute
`virtual{:tact}`  | contract | Internal functions
`abstract{:tact}` | contract | Internal functions
`override{:tact}` | contract | Internal functions that were previously marked with `virtual{:tact}` or `abstract{:tact}`
`inline{:tact}`   | any      | All functions except for receivers and getters
`get{:tact}`      | contract | Internal functions — turns them into getters

Notice that the "contract" scope also includes the [traits][trait].

### Extensions

<Badge text="Global scope" variant="note" size="medium"/><p/>

[Extension functions](#extends) provide a clean way to organize and extend code by allowing you to add new behaviors to existing types. The [extension _mutation_ functions](#mutates) also allow you to modify the value they operate on. Both kinds of extension functions can be called methods and both use special attributes: [`extends{:tact}`](#attributes-extends) and [`mutates{:tact}`](#attributes-mutates), respectively.

#### `extends` {#attributes-extends}

<Badge text="Global scope" title="This attribute can be applied to top-level functions only" variant="note" size="medium"/><p/>

The `extends{:tact}` attribute can be applied to all top level functions, transforming them into statically dispatched methods on the extended type. These methods are called [extension functions](#extends).

cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into [getter functions](#get).

#### `mutates` {#attributes-mutates}

<Badge text="Global scope" title="This attribute can be applied to top-level functions only" variant="note" size="medium"/><p/>

The `mutates{:tact}` attribute can be applied to [extension functions](#extends) only, which enables the persistence of the modifications made to the value of the extended type through the `self{:tact}` identifier. They allow mutations, and so they are called [extension mutation functions](#mutates).

#### Static extension functions {#attributes-extends-static}

There is no such attribute yet, so the special static extension functions in the standard library of Tact are introduced directly by the compiler:

* [`Message.opcode(){:tact}`](/ref/core-cells#messageopcode)
* [`Message.fromCell(){:tact}`](/ref/core-cells#messagefromcell)
* [`Message.fromSlice(){:tact}`](/ref/core-cells#messagefromslice)
* [`Struct.fromCell(){:tact}`](/ref/core-cells#structfromcell)
* [`Struct.fromSlice(){:tact}`](/ref/core-cells#structfromslice)

### Inheritance

<Badge text="Contract scope" title="Functions can only be inherited from traits and never at the top level" variant="note" size="medium"/><p/>

The `with{:tact}` keyword allows a contract to inherit a [trait](/book/types#traits) with all its constants, fields, and functions, including those transitively inherited from other traits associated with the specified trait.

In particular, all functions of the trait become accessible in the contract, regardless of any inheritance-related attributes, such as `abstract{:tact}`, `virtual{:tact}`, or `override{:tact}`.

You can allow a contract inheriting a [trait][trait] to modify a [internal function](#fun-internal) marked with the `virtual{:tact}` keyword by using `override{:tact}`. A function can also be marked as `abstract{:tact}`, in which case the inheriting contract must define its implementation.

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;

    // Receivers can be inherited, but cannot be overridden
    receive() { cashback(sender()) }
}

contract Filter() with FilterTrait {
    // Overriding the default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

{/* TODO: inheritance table as per https://github.com/tact-lang/tact/issues/3030 */}

#### `abstract` {#attributes-abstract}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `abstract{:tact}` attribute allows declaring a [internal function](#fun-internal) with no body given at declaration. Functions with this attribute are meant to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

```tact
trait BlackSquare {
    abstract fun paint();
}

trait CompositionVII {
    abstract fun paintedWithOil(preliminary: Bool): Bool;
}

contract Abstractionism() with BlackSquare, CompositionVII {
    // All functions marked as abstract must be defined in the contract that inherits them.
    override fun paintedWithOil(preliminary: Bool): Bool {
        if (preliminary) {
            return false; // perhaps, watercolors were used...
        }
        return true;
    }

    // The override attribute gives you full control — the only thing must be kept
    // the same between the abstract declaration and resulting definition
    // is the name of the function. Return type or function parameters can be changed.
    override fun paint(color: String): Bool {
        if (color != "black") {
            return false;
        }
        return true;
    }
}
```

#### `virtual` {#attributes-virtual}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `virtual{:tact}` attribute allows a [internal function](#fun-internal) to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

This attribute is similar to the [`abstract{:tact}`](#attributes-abstract) attribute, except that you do not have to override bodies of functions with the `virtual{:tact}` attribute. But if you decide to override the function body, you may do it in any trait that depends on this trait and not only in the resulting contract.

```tact
import "@stdlib/ownable";

trait DeployableFilterV1 with Ownable {
    // Virtual functions can be optionally overridden by users of this trait.
    virtual fun filter() {
        // Not an owner
        throwUnless(TactExitCodeAccessDenied, sender() == self.owner);
    }

    // Whereas internal functions with an abstract attribute must be overridden
    // by the contract that will import this trait or any of the traits that depend on this trait.
    abstract fun specialFilter();

    // Receivers are inherited too,
    // but they cannot defined be virtual or abstract
    receive() { cashback(sender()) }
}

trait DeployableFilterV2 with DeployableFilterV1 {
    override fun filter() {
        // Not an owner
        throwUnless(TactExitCodeAccessDenied, sender() == self.owner);

        // Message carries too little Toncoin for our tastes
        throwUnless(TactExitCodeAccessDenied, context().value < ton("1"));
    }
}

contract Auth(owner: Address) with DeployableFilterV2 {
    override fun specialFilter() {
        if (randomInt() < 10) {
            throw(TactExitCodeAccessDenied);
        }
    }

    receive(_: TopSecretRequest) {
        self.filter();
        self.specialFilter();

        // ...subsequent logic...
    }
}

message TopSecretRequest {}
```

#### `override` {#attributes-override}

<Badge text="Contract scope" title="This attribute can be applied to internal functions only" variant="note" size="medium"/><p/>

The `override{:tact}` attribute is used to override an inherited [internal function](#fun-internal) that has either a [`virtual{:tact}`](#attributes-virtual) or [`abstract{:tact}`](#attributes-abstract) attribute specified in the declaration of that function in one of the parent traits.

### Miscellaneous

Various attributes that modify the behavior of functions in their special ways.

#### `inline` {#attributes-inline}

<Badge text="Any scope" title="This attribute can be applied to functions within contracts and functions at the top level" variant="note" size="medium"/><p/>

The `inline{:tact}` attribute embeds the code of the function to its call sites, which eliminates the overhead of the calls but potentially increases the code size if the function is called from multiple places.

This attribute can improve performance of large infrequently called functions or small, alias-like functions. It can be combined with any other attribute except for [`get{:tact}`](#attributes-get).

```tact
inline fun add(a: Int, b: Int) {
    // The following addition will be performed in-place,
    // at all the `add()` call sites.
    return a + b;
}
```

#### `get` {#attributes-get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The special `get{:tact}` attribute cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into [getter functions](#get).

## Commonalities

Functions commonly share the same aspects, parts, or behavior. For example, due to the nature of TVM, Tact uses the [call by value](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value) parameter-passing and binding strategy, which applies to all function kinds. That is, the evaluated value of any variable passed in a function call or assigned in the [`let{:tact}`](/book/statements#let) or [assignment](/book/statements#assignment) statement is copied.

Therefore, there are no modifications of the original values in different scopes, except for the [extension _mutation_ functions](#attributes-mutates). And even so, those functions do not mutate the original value denoted by the `self{:tact}` keyword — instead, they discard the old value and replace it with the new one obtained at the end of the function body.

The above applies to all functions except for [receivers](#receivers), because they cannot be called directly and are only executed upon receiving specific messages.

### Scope {#commonalities-scope}

All kinds of functions vary in scope: some can only be defined at the top level, such as [global functions](#fun-global), while others can only be defined within contracts and traits, such as [internal functions](#fun-internal) or [receivers](#receivers).

Functions are hoisted upon declaration, such that the ones declared earlier might call those declared later and vice versa.

```tact
// Global function first() is defined prior to the second() function,
// but we can call the second() one just fine.
fun first(): Bool {
    return second(true); // always true
}

// Global function second() is defined after the first() function,
// and call to the first() function works as expected.
fun second(flag: Bool): Bool {
    if (flag) {
        return true;
    }
    return first(); // always true, because of the prior condition
}
```

### Return values {#commonalities-return}

All functions return a value. If the function does not have an explicit return type specified, it has an implicit return type of `void` — a pseudo-value that represents "nothing" in the Tact compiler. This also applies to the functions that do not allow specifying a return type, such as [receivers](#receivers) or [`init(){:tact}`](#init).

Moreover, execution of any function can be ended prematurely with the [`return{:tact}` statement](/book/statements#return). This is also true for the [receiver functions](#receivers) and [`init(){:tact}`], where empty `return{:tact}` statements are allowed.

```tact
contract GreedyCashier(owner: Address) {
    receive() {
        // Stop the execution if the message is not from an `owner`.
        if (sender() != self.owner) {
            return;
        }
        // Otherwise, forward excesses back to the sender.
        cashback(sender());
    }
}
```

To return multiple values in a function, aggregate the values in a [struct][struct].

```tact
fun minmax(a: Int, b: Int): MinMax {
    if (a < b) {
        return MinMax { min: a, max: b };
    }
    return MinMax { min: b, max: a };
}

struct MinMax {
    min: Int;
    max: Int;
}
```

### Recursion {#commonalities-recursion}

Recursive functions are allowed, including the mutually recursive functions. There is no upper limit on the recursion depth or the number of calls — computations will continue until there is no more gas to spend.

```tact
fun produceOneFrom(a: Int): Int {
    if (a <= 1) { return 1 }
    return alsoProduceOneFrom(a - 1);
}

fun alsoProduceOneFrom(b: Int): Int {
    if (b <= 1) { return 1 }
    return produceOneFrom(b - 1);
}

fun example(someA: Int, someB: Int) {
    // This sum will always be 2, regardless of values of `someA` and `someB`.
    // The only exception is when their values are too big and there is not
    // enough gas to finish the computations, in which case the transaction
    // will fail with an exit code -14: Out of gas error.
    produceOneFrom(someA) + alsoProduceOneFrom(someB); // 2
}
```

### Trailing comma {#commonalities-comma}

All functions, except for [receiver functions](#receivers), can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

### Wildcard parameters {#commonalities-wildcard}

<Badge text="Available since Tact 1.6.1" variant="tip" size="medium"/><p/>

For all kinds of functions, naming a parameter with an underscore `_{:tact}` causes its value to be considered unused and discarded. This is useful when you do not access the parameter but want to include it in the signature for possible overrides. Note that such a wildcard parameter name `_{:tact}` cannot be accessed.

```tact
trait WildThing {
    // Using wildcards for parameter names
    virtual fun assure(_: Int, _: Int): Bool {
        return true;
    }
}

contract YouMakeMyHeartSing() with WildThing {
    // And then overriding them with concrete names
    override fun assure(a: Int, b: Int): Bool {
        return a + b == b + a;
    }

    // Wildcards are also useful when you do not intend to
    // use the contents of the message and only handle the proper one
    receive(_: FieldsDoNotLie) {
        // ...
    }
}

message FieldsDoNotLie {}
```

## Low-level representation

On [TVM][tvm] level, contracts and their functions are often represented as a dictionary (or ["hashmap"](/book/maps#low-level-representation)) of methods, from their numeric method IDs to their respective bodies composed of TVM instructions. Each function then is a method that transforms the stack and TVM registers.

A function call is, essentially, a call into the dictionary using the function's ID, after which:
1. Function arguments are pushed onto the stack
2. The function executes, manipulating the stack
3. Return values are left on top of the stack, provoking another dictionary call or resulting in the end of the transaction

When a so-called ["selector hack"](/book/config#optimizations-internalexternalreceiversoutsidemethodsmap) optimization is enabled, if the number of defined receivers is small, they are stored outside of that map as plain instruction sequences. That saves gas but can cause the contract to be incorrectly recognized and misparsed by some explorers and user wallets, which expect the root of the contract's code (the root cell) to point at the method dictionary.

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[cell]: /book/cells#cells
[builder]: /book/cells#builders
[slice]: /book/cells#slices
[trait]: /book/types#traits

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
