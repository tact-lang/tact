---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters and storage functions, plus the many attributes that allow for great flexibility and expressivity of Tact language"
---

import { Badge } from '@astrojs/starlight/components';

Functions in Tact could be defined in different ways:

* Global static function
* Extension functions
* Mutation functions
* Native functions
* [Assembly functions](#asm)
* [Internal functions](/book/contracts#internal-functions)
* Receiver functions
* Getter functions

All functions, except for [receiver functions](#receiver-functions) can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

## Global static functions

You can define global function anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Virtual and abstract functions

You can allow the contract inheriting a [traits](/book/types#traits) to modify an internal function, if it has the `virtual{:tact}` keyword, using `override{:tact}`. The function can be also marked as `abstract{:tact}`, in which case the inheriting contract has to define its implementation:

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Overriding default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
````

## Extension function

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The name of the first argument MUST be named `self` and the type of this argument is the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Mutation functions

Mutation functions are performing mutation of a value replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Native functions

Native functions are direct bindings of FunC functions:

> **Note**
> Native functions could also be mutation and extension ones.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Assembly functions, `asm` {#asm}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

:::caution

  These are very advanced functions that require experience and vigilance in both definitions and usage. The logical errors in them are extremely hard to spot, the error messages are abysmal, and type checking isn't currently provided by Tact.

  That said, if you know what you're doing, they can offer you the smallest possible gas usage, the best performance and the most control over [TVM][tvm] execution. Remember ‚Äî with great power comes great responsibility.

:::

Assembly functions (or asm functions for short) are module-level functions that allow you to write [Tact assembly](#asm-tact). Unlike all other functions, their bodies consist only of [TVM instructions][tvm-instructions] and [some other primitives](#asm-tact), and don't use any [Tact statements](/book/statements).

```tact
// all assembly functions must start with "asm" keyword
// ‚Üì
   asm fun answer(): Int { 42 INT }
//                         ------
//                         Notice, that the body contains only of
//                         TVM instructions and some primitives,
//                         like numbers or bitstrings
```

### Tact assembly {#asm-tact}

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Since [TVM][tvm] is a stack machine, writing assembly for it means manipulating the stack entries with [TVM instructions][tvm-instructions]. However, many instructions require the use of additional primitives, such as numbers or bitstrings. All needed primitives are provided in the Tact assembly, whose syntax looks familiar to Fift, but is much more minimal and comfortable to use.

Except for comments, everything in `asm{:tact}` function bodies must be separated by spaces or newline characters.

```tact
asm fun theLegendOfAsmTactina() {
    // String literals, useful for debug instructions
    "Anything inside double-quotes that's not a double-quote"

    // Hex bitstrings with optional padding via _,
    // which are represented by Slices without references
    // with up to 1023 data bits
    x{babecafe_}

    // Binary bitstrings, which are like their hex counterparts,
    // but do not have the optional padding
    b{0101}

    // Number literals, represented by Int values on TVM
    42 -13

    // TVM control registers
    c0 // c0, c1, ..., c15

    // TVM stack registers
    s0 // s0, s1, ..., s255

    // TVM instructions themselves
    MYCODE // without wrapping in double-quotes "..."!
}
```

:::caution

  The `i s()` syntax for referring to stack registers beyond the $0 - 15$ range is deprecated and recognized as an error in Tact 1.6. Whenever you see `[ii] s()` in the [TVM instructions list][tvm-instructions], use one of `s0`, `s1`, ..., `s255` instead.

:::

### Stack calling conventions {#asm-calling}

The syntax for parameters and return values is the same as for other function kinds, but there is one caveat ‚Äî argument values are pushed to the stack before the function body is executed, and return values are what's left on the stack afterward.

Since the bodies of `asm{:tact}` functions do not contain Tact statements, any direct references to parameters in function bodies will be recognized as [TVM][tvm] instructions, which can easily lead to very obscure error messages.

```tact
/// Simply returns back the value of `x`
asm fun identity(x: Int): Int { }

/// COMPILATION ERROR!
/// The `BOC` is not recognized as a parameter,
/// but instead is interpreted as a non-existent TVM instruction
asm fun bocchiThe(BOC: Cell): Cell { BOC }

/// Loads a signed `len`-bit integer from Slice `s`,
/// and returns it with the remainder of `s`
asm fun sliceLoadInt(s: Slice, len: Int): IntSlice { LDIX }
//                   ‚Üë         ‚Üë
//                   |         Pushed last, sits on top of the stack
//                   Pushed first, sits on the bottom of the stack

/// Mapped onto values placed by LDIX on the stack
struct IntSlice { a: Int; b: Slice }
//                ‚Üë       ‚Üë
//                |       Result pushed last by LDIX,
//                |       sits on top of the stack
//                Result pushed first by LDIX,
//                sits on the bottom of the stack
```

Thus, when the results are popped from the stack, the [Struct][struct] fields are filled from right to left: the top stack value is mapped to the last field, the second-to-top value is mapped to the second-to-last field, and so on.

Note, that when using [Structs][struct] as the return type, you must map all stack values onto respective Struct fields, otherwise an error with [exit code 7](/book/exit-codes#7) will be thrown: `Type check error`.

If you only need the bottom value from the stack, it is possible to specify a [primitive type][p] as the return value instead:

```tact
// Same function as before, but now we don't use the `IntSlice` Struct
// and instead only take the bottom result sitting in the stack
asm fun sliceLoadInt(s: Slice, len: Int): Int { LDIX }
//                                        ‚Üë
//                                        captures the Int value, discarding
//                                        the Slice one produced by LDIX instruction
```

### Stack registers {#asm-stack-registers}

The so-called _stack registers_ are conventional way of referring to the values at the top of the stack. In total, there are $256$ stack registers, i.e. values held on the stack at any given time. You can refer to any of them using any of `s0`, `s1`, ..., `s255`.

Register `s0` is the value at the top of the stack, register `s1` is the value immediately after it, and so on, until we reach the bottom of the stack, represented by `s255`, i.e. the $256$th stack register. When a value `x` is pushed onto a stack, it becomes the new `s0`. At the same time, old `s0` becomes new `s1`, old `s1` ‚Äî new `s2`, and so on.

```tact
asm fun takeSecond(a: Int, b: Int): Int {
    //             ‚Üë       ‚Üë
    //             |       Pushed last, sits on top of the stack
    //             Pushed first, sits second from the top of the stack

    // Now, let's swap the s0 (top of the stack) with s1 (second-to-top):
    s1 XCHG0

    // Then, let's drop the value from the top of the stack
    DROP

    // At the end, we have only one value on the stack, which is b
}

fun showcase() {
    takeFirst(5, 10); // 10, i.e. b
}
```

### Arrangements {#asm-arrangements}

Often times it's useful to change the order of arguments pushed to the stack or the order of return values without referring to stack registers in the body. You can do that with `asm{:tact}` arrangements in the following manner:

```tact
// Changing the order of arguments to match the STDICT signature:
// `c` will be pushed first and get on the bottom of the stack,
// while `self` will be pushed last and get on top of the stack
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }

// Changing the order of return values of LDVARUINT16,
// capturing only the last one as the return value of the whole function
asm(-> 1 0) extends mutates fun asmLoadCoins(self: Slice): Int { LDVARUINT16 }
//     ‚Üë ‚Üë
//     | Value of the stack register 0,
//     | which is the topmost value in the stack
//     Value of the stack register 1,
//     which is second-to-top value in the stack

// Changing the order of return values while explicitly stating
// the default order of arguments as it is
asm(self len -> 1 0) extends fun asmLoadInt(self: Slice, len: Int): SliceInt { LDIX }

// Used to map onto values placed by LDIX on the stack in reversed order
struct SliceInt { a: Slice; b: Int }

// Putting the above all together we get:
fun showcase() {
    let b = beginCell()
        .storeCoins(42)
        .storeInt(27, 10)
        .asmStoreDict(emptyMap());

    let s = b.asSlice();
    let coins = s.asmLoadCoins(); // 42
    let sliceInt = s.asmLoadInt(10); // Slice remainder and 27
}
```

### Caveats {#asm-caveats}

[TVM instructions][tvm-instructions] are case-sensitive and are always written in upper case (capital letters).

```tact
/// ERROR!
asm fun bad1(): Cell { mycode }

/// ERROR!
asm fun bad2(): Cell { MyCoDe }

/// üëç
asm fun good(): Cell { MYCODE }
```

It is not necessary to enclose [TVM instructions][tvm-instructions] in double quotes. On the contrary, they are then interpreted as strings, which is probably _not_ what you want:

```tact
// Pushes the string "MYCODE" onto the compile-time stack,
// where it gets discarded even before the compute phase starts
asm fun wrongMyCode() { "MYCODE" }

// Invokes the TVM instruction MYCODE during the compute phase,
// which returns the contract code as a Cell
asm fun myCode(): Cell { MYCODE }
```

### Attributes {#asm-attributes}

The following attributes can be specified:

* `inline{:tact}` ‚Äî does nothing, since assembly functions cannot be inlined yet.
* [`extends{:tact}`](#extension-function) ‚Äî makes it an [extension function](#extension-function).
* [`mutates{:tact}`](#mutation-functions) (along with [`extends{:tact}`](#extension-function)) ‚Äî makes it an [extension mutation function](#mutation-functions).

Those attributes _cannot_ be specified:

* `abstract{:tact}` ‚Äî assembly functions must have a body defined.
* `virtual{:tact}` and `override{:tact}` ‚Äî assembly functions cannot be defined within a contract or a trait.
* [`get{:tact}`](#getter-functions) ‚Äî assembly functions cannot be [getters](#getter-functions).

```tact
/// `Builder.storeCoins()` extension function
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    STVARUINT16
}

/// `Slice.skipBits()` extension mutation function
asm extends mutates fun skipBits(self: Slice, l: Int) {
    SDSKIPFIRST
}
```

:::note[Useful links:]

  [TVM overview in TON Docs][tvm]\
  [List of TVM instructions in TON Docs][tvm-instructions]

:::

## Receiver functions

Receiver functions are special functions that are responsible for receiving messages in contracts and could be defined only within a contract or trait.

```tact
contract Treasure {
    // This means that this contract can receive the comment "Increment" and this function would be called for such messages
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Getter Functions

Getter functions define getters on smart contracts and can be defined only within a contract or trait.
Getter functions cannot be used to read some other contract's state: if you need to obtain some data you need to do that by sending a message with a request and define a receiver which would process the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are $19$-bit signed integer identifiers commonly called _method IDs_.

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: $113617$ for `supported_interfaces`, $115390$ for `lazy_deployment_completed`, and $121275$ for `get_abi_ipfs`.

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](/book/contracts#internal-functions) and some special functions are obtained sequentially: integers in the inclusive range from $-4$ to $0$ are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are $19$-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. To avoid collisions, it's recommended to specify method IDs only in these ranges, avoiding the method IDs of Tact-specific getters mentioned above.

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[slice]: /book/cells#slices

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tvm-instructions]: https://docs.ton.org/v3/documentation/tvm/instructions
