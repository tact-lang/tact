---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters, and internal functions, plus the many attributes that allow for great flexibility and expressivity in the Tact language"
---

import { Badge } from '@astrojs/starlight/components';


Tact offers a diverse set of function kinds and attributes that provide great flexibility and expressivity.

All functions, except for [receiver functions](#receive), can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

<p/><Badge text="Available since Tact 1.6.1" variant="tip" size="medium"/><p/>

Naming a parameter with an underscore `_{:tact}` causes its value to be considered unused and discarded. This is useful when you don't access the parameter but want to include it in the signature for possible overrides. Note that such a wildcard parameter name `_{:tact}` cannot be accessed.

```tact
trait WildThing {
    // Using wildcards for parameter names
    virtual fun assure(_: Int, _: Int): Bool {
        return true;
    }
}

contract YouMakeMyHeartSing with WildThing {
    // And then overriding them with concrete names
    override fun assure(a: Int, b: Int): Bool {
        return a + b == b + a;
    }
}
```





## Receivers

Receiver functions are special functions responsible for receiving messages in contracts and can be defined only within a contract or trait.

```tact
contract Counter(counter: Int) {
    // This means that this contract can receive the Increment message body,
    // and this function would be called to handle such messages.
    receive(msg: Increment) {
        self.counter += 1;
    }
}

message Increment {}
```

### `receive` — internal message receivers {#receive}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The most common receiver functions, `receive(){:tact}`, handle incoming messages from other contracts.

```tact
// This contract defines various kinds of receivers in their
// order of handling the corresponding incoming messages.
contract OrderOfReceivers() {
    // Empty receiver
    receive() {
        inMsg().bits; // 0
    }

    // Text receiver
    receive("yeehaw!") {
        inMsg().asString(); // "yeehaw!"
    }

    // Catch-all String receiver
    receive(str: String) {
        // ...
    }

    // Binary message receiver
    receive(msg: FancyMessage) {
        // ...
    }

    // Catch-all Slice receiver
    receive(rawMsg: Slice) {
        // ...
    }
}

message FancyMessage {}
```

Read more about them on their dedicated page: [Receive messages](/book/receive).

### `bounced` — bounced internal message receivers {#bounced}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `bounced(){:tact}` is a special kind of receivers which handle outgoing messages that were sent from this contract and bounced back to it.

```tact
contract Bouncy() {
    // Handles empty message bodies
    receive() {
        // Sending a message...
        message(MessageParameters{
            to: sender(),
            value: ton("0.1"),
            body: BB {}.toCell(), // ...with a BB message body
        });
    }

    // If the BB message body wasn't successfully processed by the recipient,
    // it can bounce back to our contract, in which case the following receiver
    // will handle it.
    bounced(msg: bounced<BB>) {
        // ...
    }
}

message BB {}
```

Read more about them on their dedicated page: [Bounced messages](/book/bounced).

### `external` — external message receivers {#external}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `external(){:tact}` is a special kind of receivers which handle external messages — they are sent from the off-chain world and do not have a sender address on the blockchain. Such messages are often sent to wallet contracts to process specific messages or simply to send funds to another wallet contract.

```tact
contract FeaturelessWallet(publicKey: Int as uint256) {
    external(msg: MessageWithSignedData) {
        // Can't be replied to as there's no sender!
        // Thus, many checks are required.
        throwUnless(35, msg.bundle.verifySignature(self.publicKey));
    }
}

message MessageWithSignedData {
    bundle: SignedBundle;
    walletId: Int as int32;
    seqno: Int as uint32;
}
```

Read more about them on their dedicated page: [External messages](/book/external).

## `get fun` — offchain getter functions {#get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `get{:tact}` attribute is a special attribute that cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into so-called _getter functions_ (or getters for short).

The `get` attribute can be applied to standard functions within contracts and traits, transforming them into getter functions. These functions are externally accessible (off-chain) without requiring message passing, allowing direct reading of contract state.
Getter functions define getters on smart contracts and can be defined only within a contract or trait. Getter functions cannot be used to read another contract's state. If you need to obtain data, you should do so by sending a message with a request and defining a receiver function that processes the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

```tact
contract Counter(
    val: Int as uint32,
) {
    // Standard function with get attribute
    get fun value(): Int {
        return self.val;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are $19$-bit signed integer identifiers commonly called _method IDs_.

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, the Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: $113617$ for `supported_interfaces`, $115390$ for `lazy_deployment_completed`, and $121275$ for `get_abi_ipfs`.

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](#fun-internal) and some special functions are obtained sequentially: integers in the inclusive range from -4 to 0 are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are 19-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. To avoid collisions, it is recommended to specify method IDs only in these ranges, avoiding the method IDs of Tact-specific getters mentioned above.

## `fun` — regular functions {#fun}

<Badge text="Any scope" variant="note" size="medium"/><p/>

Regular functions are declared using the `fun{:tact}` keyword.

```tact
fun add(a: Int, b: Int): Int {
    return a + b;
}
```

TODO: adjust notes (attr, usage, self., dot not, params, ret type, mult ret vals and structs)
TODO: scope: top/module-level (global), local (?not in tact), member (!), extension (globally, but on a type).

### Global functions {#fun-global}

<Badge text="Global scope" variant="note" size="medium"/><p/>

TODO: adjust notes

You can define global functions anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

### Internal functions {#fun-internal}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

These functions behave similarly to private methods in popular object-oriented languages — they're internal to contracts and can be called by prefixing them with a special [identifier `self{:tact}`](/book/contracts#self). That's why internal (or member) functions are sometimes referred to as "contract methods".

Internal functions can access the contract's [persistent state variables](/book/contracts#variables) and [constants](/book/contracts#constants).

They can only be called from [receivers](#receive), [getters](#get), and other internal functions, but not from other contracts.


## `init` — constructor function {#init}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The special constructor function `init(){:tact}` is run upon deployment of the contract. Unlike contract parameters, it performs a delayed initialization of the contract data, overriding the values of persistent state variables on-chain.

```tact
contract Example {
    // persistent state variables
    var1: Int = 0; // initialized with default value 0
    var2: Int;     // must be initialized in the init() function
    var3: Int = 7; // initialized with default value 7

    // constructor function
    init() {
        self.var2 = 42;
        self.var3 = 32; // overrides the default to 32
    }
}
```

Read more about the `init(){:tact}` on its dedicated section: [Constructor function `init(){:tact}`](/book/contracts#init-function).

## `native` — native functions {#native}

<Badge text="Global scope" variant="note" size="medium"/><p/>

Native functions allow direct bindings to imported FunC functions. In order to declare them, you have to import a `.fc` or `.func` file first. Granted, the FunC's [standard library file, `stdlib.fc`](https://github.com/tact-lang/tact/blob/main/src/stdlib/stdlib/std/stdlib.fc) is always imported for you.

Native functions are direct bindings of FunC functions and map directly to FunC primitives:

> **Note**
> Native functions can also be mutation and extension functions.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## `asm` — assembly functions {#asm}

<Badge text="Global scope" variant="note" size="medium"/>
<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

Assembly functions are top-level functions that allow you to write Tact assembly. Unlike all other functions, their bodies consist only of TVM instructions and some other primitives that serve as arguments to the instructions.

Furthermore, `asm{:tact}` functions are nearly devoid of all abstractions and give direct access to the underlying stack and register contents on which TVM operates.

Read more about them on their dedicated page: [Assembly functions](/book/assembly-functions).

## Function attributes {#attributes}

Attribute         | Scope    | Can be applied to
----------------- | -------- | -----------------
`extends{:tact}`  | global   | All global functions
`mutates{:tact}`  | global   | Functions with `extends{:tact}` attribute
`virtual{:tact}`  | contract | Internal functions
`abstract{:tact}` | contract | Internal functions
`override{:tact}` | contract | Internal functions that were previously marked with `virtual{:tact}` or `abstract{:tact}`
`inline{:tact}`   | any      | All [secondary](#secondary) functions
`get{:tact}`      | contract | Internal functions — turns them into [getters](#get)

Notice that the "contract" scope also includes the [traits][trait].

{/* TODO: clarify scopes in a hover — global (module-level/top-level), contract (internal/private), any (both) */}

### Extensions

<Badge text="Global scope" variant="note" size="medium"/><p/>

Extension functions provide a clean way to organize and extend code by allowing you to add new behaviors to existing types. The extension mutation functions also allow you to modify the value they operate on. Both kinds of extension functions can be called methods and both use special attributes.

#### `extends` — extension functions {#attributes-extends}

<Badge text="Global scope" variant="note" size="medium"/><p/>

TODO: ...

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The first argument MUST be named `self`, and the argument's type must be the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

TODO: better examples!

#### `mutates` — extension mutation functions {#attributes-mutates}

<Badge text="Global scope" variant="note" size="medium"/><p/>

TODO: ...

Mutation functions perform mutation on a value by replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

#### Static extension functions {#attributes-extends-static}

There is no such attribute yet, so the special static extension functions in the standard library of Tact are introduced directly by the compiler:

* [`Message.opcode(){:tact}`](/ref/core-cells#messageopcode)
* [`Message.fromCell(){:tact}`](/ref/core-cells#messagefromcell)
* [`Message.fromSlice(){:tact}`](/ref/core-cells#messagefromslice)
* [`Struct.fromCell(){:tact}`](/ref/core-cells#structfromcell)
* [`Struct.fromSlice(){:tact}`](/ref/core-cells#structfromslice)

### Inheritance

<Badge text="Contract scope" variant="note" size="medium"/><p/>

You can allow a contract inheriting a [trait][trait] to modify a [internal function](#fun-internal) marked with the `virtual{:tact}` keyword by using `override{:tact}`. A function can also be marked as `abstract{:tact}`, in which case the inheriting contract must define its implementation.

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;

    // Receivers can be inherited, but cannot be overridden
    receive() { cashback(sender()) }
}

contract Filter() with FilterTrait {
    // Overriding the default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

{/* TODO: inheritance table or other way to represent https://github.com/tact-lang/tact/issues/3030 */}

#### `abstract` {#attributes-abstract}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `abstract{:tact}` attribute allows declaring a [internal function](#fun-internal) with no body given at declaration. Functions with this attribute are meant to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

```tact
// TODO: example
```

#### `virtual` {#attributes-virtual}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `virtual{:tact}` attribute allows a [internal function](#fun-internal) to be overridden later in the inheritance hierarchy by either an intermediate trait or the contract inheriting it.

This attribute is similar to the [`abstract{:tact}`](#attributes-abstract) attribute, except that

TODO: ...

#### `override` {#attributes-override}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `override{:tact}` attribute is used to override an inherited [internal function](#fun-internal) that has either a `virtual{:tact}` or `abstract{:tact}` attribute specified in the declaration of that function in one of the parent traits.

```tact
// TODO:...
```

TODO: ...can transform an abstract to virtual and then virtual no regular
TODO: ...can transform one virtual to another virtual
TODO: ...can transform one abstract to another abstract
TODO: when combined with prior `virtual{:tact}`...

### Miscellaneous

Various attributes that modify the behavior of functions in their special ways.

#### `inline` {#attributes-inline}

<Badge text="Any scope" variant="note" size="medium"/><p/>

The `inline{:tact}` attribute embeds the code of the function to its call sites, which eliminates the overhead of the calls but potentially increases the code size if the function is called from multiple places.

This attribute can improve performance of large infrequently called functions or small, alias-like functions. It can be combined with any other attribute except for [`get{:tact}`](#attributes-get).

```tact
inline fun add(a: Int, b: Int) {
    // The following addition will be performed in-place,
    // at all the `add()` call sites.
    return a + b;
}
```

#### `get` {#attributes-get}

<Badge text="Contract scope" variant="note" size="medium"/><p/>

The `get{:tact}` attribute is a special attribute that cannot be combined with any other attribute. It is applied to [internal functions](#fun-internal), transforming them into [getter functions](#get).

## Low-level representation

On [TVM][tvm] level, contracts and their functions are often represented as a dictionary (map) of methods, from their numeric method IDs to their respective bodies composed of TVM instructions. Each function then is a method that transforms the stack and TVM registers.

A function call is, essentially, a call into the dictionary using the function's ID, after which:
1. Function arguments are pushed onto the stack
2. The function executes, manipulating the stack
3. Return values are left on top of the stack, provoking another dictionary call or resulting in the end of the transaction

When a so-called ["selector hack"](/book/config#optimizations-internalexternalreceiversoutsidemethodsmap) optimization is enabled, if a small number of receiver functions are defined in the contract, they are stored outside of that map and as plain instruction sequences. That saves gas but can cause the contract to be incorrectly recognized and misparsed by some explorers and user wallets, which expect the root of the contract's code (the root cell) to point at the method dictionary instead.

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[slice]: /book/cells#slices
[trait]: /book/types#traits

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
