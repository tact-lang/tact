---
title: Contract upgrade
description: "Traits to upgrade your contracts after deployment"
link: /cookbook
label: Cookbook overview
---

This page describes two traits for updating a contract after deployment, simple and time-locked.

## Straightforward upgrade

The following code shows an example of trait for simple upgrades for deployed contracts.
With this trait, the contract code and data are updated without any timeout.

```tact
import "@stdlib/ownable";

/// Message for upgrading contract code and data.
message Upgrade {
    /// Optional new contract code as Cell.
    code: Cell? = null;
    /// Optional new contract data as Cell.
    data: Cell? = null;
}

/// Trait that enables contract upgradeability.
/// Implements basic upgrade mechanism with owner validation.
trait Upgradable with Ownable {
    /// Contract owner address that can perform upgrades.
    owner: Address;

    /// Current contract version, increments after each upgrade.
    version: Int as uint32;

    /// Handles upgrade message.
    /// Validates sender, performs upgrade and increments version.
    receive(msg: Upgrade) {
        let ctx = context();
        self.upgrade_validate(ctx, msg);
        self.upgrade(ctx, msg);

        self.version += 1;
    }

    /// Validates upgrade request.
    /// By default only allows owner to upgrade. Can be overridden.
    virtual inline fun upgrade_validate(ctx: Context, _: Upgrade) {
        self.requireOwner();
    }

    /// Performs the actual upgrade.
    /// Updates contract code and optionally data.
    virtual inline fun upgrade(_: Context, msg: Upgrade) {
        if (msg.code != null) {
            setCode(msg.code!!);
        }
        if (msg.data != null) {
            setData(msg.data!!);
            // prevents second call of `set_data` later in FunC compiled code
            throw(0);
        }
    }

    /// Returns whether contract is upgradable
    /// Always returns true since this implementation is upgradable
    get fun isUpgradable(): Bool {
        return true;
    }

    /// Returns current contract version.
    get fun version(): Int {
        return self.version;
    }
}

asm fun setCode(code: Cell) { SETCODE }

asm fun setData(data: Cell) { c4 POP }
```

## Time-lock upgrade

To perform a time-locked upgrade in two stages, you can use the following code based on the `Upgradable` trait.

Updating the code with this trait requires sending two messages:

1. Message for an upgrade, which specifies a timeout after which the upgrade can be completed
2. Message for confirmation and launch of the upgrade

If the second message is sent before the timeout expires, the contract will throw an error and the contract will not be updated.

```tact
/// Message for upgrading contract code and data.
message Upgrade {
    /// Optional new contract code as Cell.
    code: Cell? = null;
    /// Optional new contract data as Cell.
    data: Cell? = null;
    /// Delay in nanoseconds before upgrade can be confirmed.
    /// Zero means upgrade can be confirmed immediately.
    /// Used only for `DelayedUpgradable`.
    timeout: Int = 0;
}

/// Message to confirm delayed upgrade execution.
/// Must be sent after timeout period specified in `Upgrade` message has passed.
/// Can only be processed by contracts implementing `DelayedUpgradable` trait.
message Confirm {}

/// Extended version of Upgradable that adds a delay mechanism.
/// Upgrade process happens in two steps:
/// 1. Owner initiates upgrade by sending `Upgrade` message.
/// 2. After timeout period, owner confirms upgrade with `Confirm` message.
trait DelayedUpgradable with Upgradable {
    /// Contract owner address that can perform upgrades.
    owner: Address;

    /// Current contract version, increments after each upgrade.
    version: Int as uint32;

    /// Timestamp when upgrade was initiated.
    /// Used to enforce timeout period before confirmation.
    initiated_at: Int;

    /// Stores information about pending upgrade.
    /// Contains new code, optional data and timeout period.
    upgrade_info: Upgrade;

    /// Confirms and executes pending upgrade after timeout period.
    /// Can only be called after `upgrade_info.timeout` nanoseconds have passed.
    receive(msg: Confirm) {
        require(now() > self.initiated_at + self.upgrade_info.timeout, "DelayedUpgradable: Cannot confirm upgrade before timeout");

        if (self.upgrade_info.code != null) {
            setCode(self.upgrade_info.code!!);
        }
        if (self.upgrade_info.data != null) {
            setData(self.upgrade_info.data!!);
            throw(0);
        }
    }

    /// Stores upgrade information for later confirmation.
    /// Instead of performing upgrade immediately, saves details for delayed execution.
    override inline fun upgrade(_: Context, msg: Upgrade) {
        self.upgrade_info = msg;
    }
}
```
