---
title: Advanced
description: "Advanced, niche or dangerous functions from the Core library of Tact"
---

import { Badge } from '@astrojs/starlight/components';

Various niche, dangerous or unstable features which can produce unexpected results and are meant to be used by the more experienced users.

:::caution

  Proceed with caution.

:::

## gasConsumed

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun gasConsumed(): Int;
```

Returns the [nanoToncoin][nanotoncoin] [`Int{:tact}`][int] amount of [gas][gas] consumed by [TVM][tvm] in the current transaction so far. The resulting value includes the cost of calling this function.

Usage example:

```tact
let gas: Int = gasConsumed();
```

:::note[Useful links:]

  [Gas in TON Docs](https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees#gas)

:::

## myStorageDue

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun myStorageDue(): Int;
```

Returns the [nanoToncoin][nanotoncoin] [`Int{:tact}`][int] amount of the accumulated [storage fee][storage-fee] debt. Storage fees are deducted from the incoming message value before the new contract balance is calculated.

Usage example:

```tact
let debt: Int = myStorageDue();
```

:::note[Useful links:]

  [Storage fee in TON Docs][storage-fee]\
  [Storage fee calculation in TON Docs][storage-fee-calc]

:::

## getStorageFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getStorageFee(cells: Int, bits: Int, seconds: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [storage fee][storage-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for storing a contract with a given number of `cells` and `bits` for a number of `seconds`. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 18 of TON Blockchain](https://docs.ton.org/develop/howto/blockchain-configs#param-18).

Note, that the values of `cells` and `bits` are taken modulo their maximum values plus $1$. That is, specifying values higher than those listed in [account state limits (`max_acc_state_cells` and `max_acc_state_bits`)](/book/exit-codes#50) will have the same result as with specifying the exact limits. In addition, make sure you take into account the [deduplication of cells with the same hash][deduplication].

Attempts to specify negative number of `cells`, `bits` or `seconds` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getStorageFee(1_000, 1_000, 1_000, false);
//                           -----  -----  -----  -----
//                           ↑      ↑      ↑      ↑
//                           |      |      |      Isn't on the masterchain,
//                           |      |      |      but on the basechain
//                           |      |      Number of seconds to calculate
//                           |      |      the storage fee for
//                           |      Number of bits in a contract
//                           Number of cells in a contract
```

:::note[Useful links:]

  [Storage fee in TON Docs][storage-fee]\
  [Storage fee calculation in TON Docs][storage-fee-calc]

:::

## getComputeFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getComputeFee(gasUsed: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [compute fee][compute-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for a transaction that consumed `gasUsed` amount of [gas][gas]. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 20 for the masterchain and config param 21 for the basechain][param-20-21] of TON Blockchain.

When the `gasUsed` is less than a certain threshold called [`flat_gas_limit`][param-20-21], there's a minimum price to pay based on the value of [`flat_gas_price`][param-20-21]. The less gas is used below this threshold, the higher the minimum price will be. See the example for [`getSimpleComputeFee(){:tact}`](#getsimplecomputefee) to derive that threshold.

Attempts to specify negative value of `gasUsed` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getComputeFee(1_000, false);
//                           -----  -----
//                           ↑      ↑
//                           |      Isn't on the masterchain,
//                           |      but on the basechain
//                           Number of gas units
//                           consumed per transaction
```

:::note[Useful links:]

  [Compute fee in TON Docs][compute-fee]\
  [Compute fee calculation in TON Docs][compute-fee-calc]\
  [`getSimpleComputeFee(){:tact}`](#getsimplecomputefee)

:::

## getSimpleComputeFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getSimpleComputeFee(gasUsed: Int, isMasterchain: Bool): Int;
```

Similar to [`getComputeFee(){:tact}`](#getcomputefee), but without the [`flat_gas_price`][param-20-21], i.e. without a minimum price to pay if the `gasUsed` is less than a certain threshold called [`flat_gas_limit`][param-20-21]. Calculates and returns only the `gasUsed` times the current gas price.

Attempts to specify negative value of `gasUsed` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee = getComputeFee(0, false);
let feeNoFlat = getSimpleComputeFee(0, false);
let maxFlatPrice = fee - feeNoFlat;
```

:::note[Useful links:]

  [Compute fee in TON Docs][compute-fee]\
  [Compute fee calculation in TON Docs][compute-fee-calc]\
  [`getComputeFee(){:tact}`](#getcomputefee)

:::

## Context.readForwardFee

```tact
extends fun readForwardFee(self: Context): Int;
```

Extension function for the [`Context{:tact}`](/ref/core-common#context).

Reads [forward fee](https://docs.ton.org/develop/smart-contracts/guidelines/processing) and returns it as [`Int{:tact}`][int] amount of [nanoToncoins][nanotoncoin].

Usage example:

```tact
let fwdFee: Int = context().readForwardFee();
```

:::note[Useful links:]

  [`getOriginalFwdFee(){:tact}`](#getoriginalfwdfee)

:::

## getForwardFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [forward fee][forward-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for an outgoing message consisting of a given number of `cells` and `bits`. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 24 for the masterchain and config param 25 for the basechain][param-24-25] of TON Blockchain.

If both the source and the destination addresses are in the [basechain][basechain], then specify `isMasterchain` as `false{:tact}`. Otherwise, specify `true{:tact}`.

Note, that the values of `cells` and `bits` are taken modulo their maximum values plus $1$. That is, specifying values higher than those listed in [account state limits (`max_msg_cells` and `max_msg_bits`)](/book/exit-codes#50) will have the same result as with specifying the exact limits.

However, regardless of the values of `cells` and `bits`, this function always adds the minimum price based on the value of [`lump_price`][param-24-25]. See the example for [`getSimpleForwardFee(){:tact}`](#getsimpleforwardfee) to derive it. In addition, make sure you take into account the [deduplication of cells with the same hash][deduplication], since for example the root cell and its data bits don't count towards the forward fee and are covered by the [`lump_price`][param-24-25].

Attempts to specify negative number of `cells` or `bits` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getForwardFee(1_000, 1_000, false);
//                           -----  -----  -----
//                           ↑      ↑      ↑
//                           |      |      Both source and destination
//                           |      |      isn't on the masterchain,
//                           |      |      but on the basechain
//                           |      Number of bits in a message
//                           Number of cells in a message
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`CDATASIZEQ` instruction for computing the number of distinct cells, data bits and refs in a `Cell{:tact}`](https://docs.ton.org/v3/documentation/tvm/instructions#F940)\
  [`getSimpleForwardFee(){:tact}`](#getsimpleforwardfee)\
  [`getOriginalFwdFee(){:tact}`](#getoriginalfwdfee)

:::

## getSimpleForwardFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getSimpleForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int;
```

Similar to [`getForwardFee(){:tact}`](#getforwardfee), but without the [`lump_price`][param-24-25], i.e. without the minimum price to pay regardless of the amount of `cells` or `bits`. Calculates and returns only the `cells` times the current cell price plus `bits` times the current bit price.

Attempts to specify negative number of `cells` or `bits` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee = getForwardFee(1_000, 1_000, false);
let feeNoLump = getSimpleForwardFee(1_000, 1_000, false);
let lumpPrice = fee - feeNoLump;
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`getForwardFee(){:tact}`](#getforwardfee)

:::

## getOriginalFwdFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getOriginalFwdFee(fwdFee: Int, isMasterchain: Bool): Int;
```

Calculates and returns the so-called _original_ [forward fee][forward-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for an outgoing message based on the `fwdFee` obtained from the incoming message. If both the source and the destination addresses are in the [basechain][basechain], then specify `isMasterchain` as `false{:tact}`. Otherwise, specify `true{:tact}`.

This function is useful when the outgoing message depends heavily on the structure of the incoming message, so much so that you cannot fully predict the fee using [`getForwardFee(){:tact}`](#getforwardfee) alone. Even if you could, calculating the exact fee with [nanoToncoin][nanotoncoin]-level precision can be very expensive, so the approximation given by this function is often good enough.

Attempts to specify a negative value of `fwdFee` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fwdFee: Int = context().readForwardFee();
let origFee: Int = getOriginalFwdFee(fee, false);
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`getForwardFee(){:tact}`](#getforwardfee)\
  [`Context.readForwardFee(){:tact}`](#contextreadforwardfee)

:::

## getConfigParam

```tact
fun getConfigParam(id: Int): Cell?;
```

Loads a [configuration parameter](https://docs.ton.org/develop/howto/blockchain-configs) of TON Blockchain by its `id` number.

Usage examples:

```tact
// Parameter 0, address of a special smart contract that stores the blockchain's configuration
let configAddrAsCell: Cell = getConfigParam(0)!!;

// Parameter 18, configuration for determining the prices for data storage
let dataStorageFeeConfig: Cell = getConfigParam(18)!!;
```

:::note

  Standard library [`@stdlib/config`](/ref/stdlib-config) provides two related helper functions:\
  [`getConfigAddress(){:tact}`](/ref/stdlib-config#getconfigaddress) for retrieving config [`Address{:tact}`][p]\
  [`getElectorAddress(){:tact}`](/ref/stdlib-config#getconfigaddress) for retrieving elector [`Address{:tact}`][p]

  Read more about other parameters: [Config Parameters in TON Docs](https://docs.ton.org/develop/howto/blockchain-configs).

:::

## acceptMessage

```tact
fun acceptMessage();
```

Agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.

Usage example:

```tact {10}
contract Timeout {
    timeout: Int;

    init() {
        self.timeout = now() + 5 * 60; // 5 minutes from now
    }

    external("timeout") {
        if (now() > self.timeout) {
            acceptMessage(); // start accepting external messages once timeout went out
        }
    }
}
```

:::note

  For more details, see: [Accept Message Effects in TON Docs](https://docs.ton.org/develop/smart-contracts/guidelines/accept).

:::

## commit

```tact
fun commit();
```

Commits the current state of [registers](https://docs.ton.org/learn/tvm-instructions/tvm-overview#control-registers) `c4` ("persistent data") and `c5` ("actions"), so that the current execution is considered "successful" with the saved values even if an exception in compute phase is thrown later.

Usage example:

```tact {1}
commit();  // now, transaction is considered "successful"
throw(42); // and this won't fail it
```

## nativePrepareRandom

```tact
fun nativePrepareRandom();
```

Prepares a random number generator by using [`nativeRandomizeLt(){:tact}`](#nativerandomizelt). Automatically called by [`randomInt(){:tact}`](/ref/core-random#randomint) and [`random(){:tact}`](/ref/core-random#random) functions.

Usage example:

```tact
nativePrepareRandom(); // prepare the RNG
// ... do your random things ...
```

## nativeRandomize

```tact
fun nativeRandomize(x: Int);
```

Randomizes the pseudo-random number generator with the specified seed `x`.

Usage example:

```tact
nativeRandomize();          // now, random numbers are less predictable
let idk: Int = randomInt(); // ???, it's random!
```

## nativeRandomizeLt

```tact
fun nativeRandomizeLt();
```

Randomizes the random number generator with the current [logical time](https://docs.ton.org/develop/smart-contracts/guidelines/message-delivery-guarantees#what-is-a-logical-time).

Usage example:

```tact
nativeRandomizeLt();        // now, random numbers are unpredictable for users,
                            // but still may be affected by validators or collators
                            // as they determine the seed of the current block.
let idk: Int = randomInt(); // ???, it's random!
```

## nativeRandom

```tact
fun nativeRandom(): Int;
```

Generates and returns an $256$-bit random number just like [`randomInt(){:tact}`](/ref/core-random#randomint), but doesn't initialize the random generator with [`nativePrepareRandom(){:tact}`](#nativepreparerandom) beforehand.

:::note

  Don't use this function directly, and prefer using [`randomInt(){:tact}`](/ref/core-random#randomint) instead.

:::

## nativeRandomInterval

```tact
fun nativeRandomInterval(max: Int): Int;
```

Generates and returns a $256$-bit random number in the range from $0$ to `max` similar to [`random(){:tact}`](/ref/core-random#random), but doesn't initialize the random generator with [`nativePrepareRandom(){:tact}`](#nativepreparerandom) beforehand.

:::note

  Don't use this function directly, and prefer using [`random(){:tact}`](/ref/core-random#random) instead.

:::

## nativeSendMessage

```tact
fun nativeSendMessage(cell: Cell, mode: Int);
```

[Queues the message](/book/send#outbound-message-processing) to be sent by specifying the complete `cell` and the [message `mode`](/book/message-mode).

:::note

  Prefer using a much more common and user-friendly [`send(){:tact}`](/ref/core-common#send) function unless you have a complex logic that can't be expressed otherwise.

:::

## nativeReserve

```tact
fun nativeReserve(amount: Int, mode: Int);
```

Calls native `raw_reserve` function with specified amount and mode. The `raw_reserve` is a function that creates an output action to reserve a specific amount of [nanoToncoins][nanotoncoin] from the remaining balance of the account.

It has the following signature in FunC:

```func
raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
```

The function takes two arguments:
* `amount`: The number of [nanoToncoins][nanotoncoin] to reserve.
* `mode`: Determines the reservation behavior.

Function `raw_reserve` is roughly equivalent to creating an outbound message carrying the specified `amount` of [nanoToncoins][nanotoncoin] (or `b` $-$ `amount` [nanoToncoins][nanotoncoin], where `b` is the remaining balance) to oneself. This ensures that subsequent output actions cannot spend more money than the remainder.

It's possible to use raw [`Int{:tact}`][int] values and manually provide them for the `mode`, but for your convenience there's a set of constants which you may use to construct the compound `mode` with ease. Take a look at the following tables for more information on base modes and optional flags.

:::caution

  Currently, `amount` must be a non-negative integer, and `mode` must be in the range $0..31$, inclusive.

:::

### Base modes {#nativereserve-base-modes}

The resulting `mode` value can have the following base modes:

Mode value | Constant name                 | Description
---------: | :---------------------------- | -----------
$0$        | `ReserveExact{:tact}`         | Reserves exactly the specified `amount` of [nanoToncoins][nanotoncoin].
$1$        | `ReserveAllExcept{:tact}`     | Reserves all, but the specified `amount` of [nanoToncoins][nanotoncoin].
$2$        | `ReserveAtMost{:tact}`        | Reserves at most the specified `amount` of [nanoToncoins][nanotoncoin].

### Optional flags {#nativereserve-optional-flags}

Additionally, the resulting `mode` can have the following optional flags added:

Flag value | Constant name                      | Description
---------: | :--------------------------------- | -----------
$+4$       | `ReserveAddOriginalBalance{:tact}` | Increases the `amount` by the original balance of the current account (before the compute phase), including all extra currencies.
$+8$       | `ReserveInvertSign{:tact}`         | Negates the `amount` value before performing the reservation.
$+16$      | `ReserveBounceIfActionFail{:tact}` | Bounces the transaction if reservation fails.

### Combining modes with flags {#nativereserve-combining-modes-with-flags}

To make the [`Int{:tact}`][int] value for `mode` parameter, you just have to combine base modes with optional flags by applying the [bitwise OR](/book/operators#binary-bitwise-or) operation:

```tact
nativeReserve(ton("0.1"), ReserveExact | ReserveBounceIfActionFail);
//            ----------  ----------------------------------------
//            ↑           ↑
//            |           mode, which would bounce the transaction if exact reservation would fail
//            amount of nanoToncoins to reserve
```

## parseStdAddress

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun parseStdAddress(slice: Slice): StdAddress;
```

Converts a [`Slice{:tact}`][slice] containing an address into the `StdAddress{:tact}` [Struct][s] and returns it. The `StdAddress{:tact}` is a built-in [Struct][s] that consists of:

Field       | Type                           | Description
:---------- | :----------------------------- | :----------
`workchain` | [`Int as int8{:tact}`][int]    | Workchain ID of the address, usually $0$ (basechain) or $-1$ (masterchain)
`address`   | [`Int as uint256{:tact}`][int] | Address in the specified `workchain`

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the `StdAddress{:tact}` or to load more data than a given [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let addr = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
let parsedAddr = parseStdAddress(addr.asSlice());

parsedAddr.workchain; // 0
parsedAddr.address;   // 107...lots of digits...287

// Using newAddress() function with the contents of StdAddress will yield the initial Address:
let addr2: Address = newAddress(parsedAddr.workchain, parsedAddr.address);
addr2 == addr; // true
```

:::note

  For parsing addresses of variable length, see the [`parseVarAddress(){:tact}`](#parsevaraddress) function.

:::

## parseVarAddress

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun parseVarAddress(slice: Slice): VarAddress;
```

Converts a [`Slice{:tact}`][slice] containing an address of variable length into the `VarAddress{:tact}` [Struct][s] and returns it. The `VarAddress{:tact}` is a built-in [Struct][s] consisting of:

Field       | Type                         | Description
:---------- | :--------------------------- | :----------
`workchain` | [`Int as int32{:tact}`][int] | Workchain ID of the variable length address
`address`   | [`Slice{:tact}`][slice]      | Address in the specified `workchain`

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the `VarAddress{:tact}` or to load more data than a given [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let varAddrSlice = beginCell()
    .storeUint(6, 3)     // to recognize the following as a VarAddress
    .storeUint(123, 9)   // make address occupy 123 bits
    .storeUint(234, 32)  // specify workchain ID of 234
    .storeUint(345, 123) // specify address of 345
    .asSlice();
let parsedVarAddr = parseVarAddress(varAddrSlice);

parsedVarAddr.workchain;             // 234
parsedVarAddr.address;               // CS{Cell{002...2b3} bits: 44..167; refs: 0..0}
parsedVarAddr.address.loadUint(123); // 345
```

:::caution

  Variable-length addresses are intended for future extensions, and while validators must be ready to accept them in inbound messages, the standard (non-variable) addresses are used whenever possible.

:::

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[slice]: /book/cells#slices
[s]: /book/structs-and-messages#structs
[masterchain]: /book/masterchain
[cell-hash]: /ref/core-cell#cellhash
[nanotoncoin]: /book/integers#nanotoncoin

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[basechain]: https://docs.ton.org/v3/concepts/ton-blockchain/smart-contract-addresses#address-components
[deduplication]: https://docs.ton.org/v3/documentation/data-formats/tlb/library-cells

[storage-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees-low-level#storage-fee
[storage-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#storage-fee

[gas]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees#gas
[compute-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees-low-level#computation-fees
[compute-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#computation-fee
[param-20-21]: https://docs.ton.org/v3/documentation/network/configs/blockchain-configs#param-20-and-21

[forward-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/forward-fees
[forward-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#forward-fee
[param-24-25]: https://docs.ton.org/v3/documentation/network/configs/blockchain-configs#param-24-and-25
